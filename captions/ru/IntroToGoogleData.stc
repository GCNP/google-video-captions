
*TC 00:12:19;27
Привет, я Джефф Фишер.
Если вы это смотрите, 

*TC 00:00:04;10
вы, вероятно, разработчик, 
которому интересно работать 

*TC 00:00:06;07
с продуктами Google, используя
их API.

*TC 00:00:07;28
В частности, API, использующими
протокол данных Google.

*TC 00:00:11;27
Вы можете спросить меня, что
такое протокол данных Google.

*TC 00:00:14;25
Ну, прежде чем ответить,  

*TC 00:00:17;10
я кое-что поясню.

*TC 00:00:19;03
Я полагаю, что вы уже
знакомы с 

*TC 00:00:21;19
технологиями HTTP и XML.

*TC 00:00:24;11
Уже давно веб-сайты
ищут  
 
*TC 00:00:26;16
альтернативные способы
распространения содержания, 

*TC 00:00:28;19
более понятные для
компьютеров.

*TC 00:00:30;19
Компьютеры не очень умные,
им надо 

*TC 00:00:32;23
помогать понимать нашу
информацию так же, как мы.

*TC 00:00:36;12
Возьмем простой пример, 
скажем, блог.

*TC 00:00:39;27
На сайте с блогами есть
несколько новых статей, 

*TC 00:00:42;23
которые объединены в большой 
список, для каждой есть сводка, 

*TC 00:00:45;11
название: кто их написал, когда.

*TC 00:00:48;03
Это основная информация.

*TC 00:00:49;17 
Как представить это способом,
понятным компьютеру?

*TC 00:00:52;17
Первая попытка это сделать
— RSS,

*TC 00:00:55;14
но сегодня я буду
говорить о 

*TC 00:00:57;15
формате синдикации Atom.

*TC 00:00:59;18
Atom — это способ (на основе
XML) описать данные 

*TC 00:01:02;14
на этих веб-сайтах и сделать так,
чтобы компьютерам 

*TC 00:01:05;08
было легко извлекать эту
информацию.

*TC 00:01:07;16
В основе лежит
элемент канала, 

*TC 00:01:11;10
содержащий несколько записей,
а в каждой записи будут все 

*TC 00:01:14;18 
метаданные, связанные с
сообщением в блоге.

*TC 00:01:18;10
Что ж, здорово, теперь у
нас есть удобный способ 

*TC 00:01:21;02
емко описать все содержание
в этом блоге.

*TC 00:01:23;18
Но что если мне нужно
создать программу, которая
редактирует этот блог, а 

*TC 00:01:26;18
не просто его читает?

*TC 00:01:28;22
Я могу сделать для этого
какой-нибудь совершенно
новый механизм, 

*TC 00:01:31;21
абсолютно не похожий на
этот механизм 

*TC 00:01:34;18
канала, который я только
что описал, 

*TC 00:01:36;22
либо можно попробовать
воспользоваться им повторно.

*TC 00:01:38;09
Итак, если я хочу еще
раз использовать этот формат, 

*TC 00:01:40;07
который так здорово 
описывает мое сообщение
с помощью XML,

*TC 00:01:44;06
как мне передавать данные
на сервер?

*TC 00:01:46;12
Так как сообщения 
получаются через HTTP, 

*TC 00:01:49;08
тот же HTTP можно использовать
для изменения и удаления
содержания, 

*TC 00:01:52;22
а также для создания
нового содержания.

*TC 00:01:54;26
Как хорошо, что можно
повторно использовать то, что
у нас уже есть, и просто применить 

*TC 00:01:59;05
в HTTP другие команды, вроде
put, post и delete.

*TC 00:02:04;00
Теперь у нас есть полный
цикл для управления
содержанием блога, 

*TC 00:02:07;28
и для этого пришлось лишь 
немного измененить канал.

*TC 00:02:10;12
А что если в нем нет
записей блога?

*TC 00:02:14;01
Что если это не блог? Вдруг это что-то вроде 

*TC 00:02:16;14
календаря или таблицы?
Как тогда представить данные?

*TC 00:02:20;23
Можно 

*TC 00:02:22;06
опять попробовать
сделать это новым способом

*TC 00:02:24;14
или снова попробовать
применить Atom.

*TC 00:02:27;28
Если вы
используете метод Atom,

*TC 00:02:29;11
то вы делаете именно то,
что пытаются делать
данные Google.

*TC 00:02:32;28 
Итак,

*TC 00:02:35;05
посмотрим
пример  

*TC 00:02:37;13
того, на что похож канал Atom.

*TC 00:02:39;04
Канал Atom — это XML, 

*TC 00:02:41;09
как мы уже говорили,
и он содержит записи. 

*TC 00:02:44;27
В каждом канале есть свои
метаданные и для каждой записи.

*TC 00:02:49;20
Можно заметить, что у каждой
записи есть уникальный
идентификатор, 

*TC 00:02:53;08
отличающий ее от всех
остальных записей на сайте.  

*TC 00:02:56;15
Еще есть некоторые сведения
для ее редактирования.

*TC 00:03:01;10
Итак, 

*TC 00:03:03;10
взяв это и 
придав ему 

*TC 00:03:06;16 
редактируемый вид,
мы назовем это 

*TC 00:03:08;02
протоколом публикации Atom.  

*TC 00:03:09;25
Протокол публикации Atom
извлекает все записи и 

*TC 00:03:13;14
превращает их в ресурсы.

*TC 00:03:15;15
Эти ресурсы могут быть
обычными текстовыми ресурсами, 

*TC 00:03:19;11
а могут быть мультимедиа и 
содержать изображение или видео.

*TC 00:03:24;04
Он также заново использует
запросы HTTP, о которых мы 

*TC 00:03:27;20
уже говорили, для управления
этими данными, а затем он 

*TC 00:03:30;26
использует коды ответов
HTTP, чтобы понять, 

*TC 00:03:32;18
была ли операция успешной,
произошли ошибки 

*TC 00:03:35;04
или была нужна аутентификация.

*TC 00:03:37;16
Есть еще одна вещь,
которую обычно называют 

*TC 00:03:40;00
протоколом с архитектурой REST, он
использует семантику с архитектурой REST

*TC 00:03:44;24
для изменения этих ресурсов, 
поэтому все запросы 

*TC 00:03:48;02
не зависят друг от друга и
не требуют 

*TC 00:03:51;19
дополнительного контекста,
например, сеанса, чтобы знать,
что делать.

*TC 00:03:55;17
Вот пример сообщения, 
показывающий, как создавать 

*TC 00:03:59;07
записи в блоге с
помощью AtomPub;

*TC 00:04:02;04
вы заметите, что здесь есть
кое-какая аутентификация, 

*TC 00:04:04;07
еще какие-то части мета-
данных, но в целом 

*TC 00:04:06;29
мы размещаем просто
запись Atom, 

*TC 00:04:08;24
такую же, какую мы получили
бы из канала Atom.

*TC 00:04:10;21
Отправив все это
вместе с данными, мы 

*TC 00:04:14;15
создали запись и получаем назад
запись такой, как  мы ее создали, 

*TC 00:04:17;00
плюс дополнительные 
элементы, например, ссылка
для редактирования, 

*TC 00:04:19;10
на случай если нам надо
будет изменить ее, а еще мы 
получаем 

*TC 00:04:22;04
что-то вроде строки версии.

*TC 00:04:23;14
В нашем случае здесь отображается "Etag", 

*TC 00:04:25;10
который уникальным образом
идентифицирует конкретную
версию сообщения.

*TC 00:04:29;13
Код ответа 201 
обозначает, что 

*TC 00:04:32;01
содержание успешно
создано на сервере.

*TC 00:04:35;20
Итак, что такое данные Google? Как их использовать?  

*TC 00:04:40;02
Это абстрактный способ
анализировать каналы Atom.

*TC 00:04:43;22
Что вам будет нужно,
если вы хотите представить 

*TC 00:04:45;15
что-то, что не было записью
в блоге, через Atom?

*TC 00:04:47;20
Видимо, какой-то пользовательский
XML, описывающий эти записи.  

*TC 00:04:50;21
Здесь нам помогут типы данных. Типы данных Google используются для 

*TC 00:04:50;21
представления абстрактных идей,
встречающихся во многих API, например, 

*TC 00:04:59;16
что такое место, что такое время, 

*TC 00:05:01;21
что такое знакомый. Вещи, которые
не хочется 

*TC 00:05:04;10
придумывать заново всякий
раз, специфицируя новый API, 

*TC 00:05:06;16
или работая над
другим продуктом.

*TC 00:05:08;22
Теперь у нас есть XML, который
хорошо подходит  

*TC 00:05:11;21
к модели Atom,
так как Atom позволяет 

*TC 00:05:13;18
расширять XML.
Что еще может понадобиться?

*TC 00:05:17;02
Есть несколько вещей, вроде
языков запросов 

*TC 00:05:22;03
и аутентификации, которые мы
добавили в AtomPub 

*TC 00:05:22;02
как часть данных Google.
Данные Google позволяют

*TC 00:05:24;23
заполнять пробелы между тем, что
может сделать AtomPub и тем, 

*TC 00:05:29;19
что мы бы хотели делать, 
используя их как API.

*TC 00:05:33;00
Как я уже упоминал, 
есть определенная форма  

*TC 00:05:34;21
аутентификации, которую нужно
иметь, чтобы работать со 

*TC 00:05:36;19
службами Googlе и
привязываться к аккаунтам Google, 

*TC 00:05:39;13
а еще у нас есть способ 
ограничивать тип содержания, 

*TC 00:05:43;07
к которому вы пытаетесь
получить доступ с помощью
этого канала, 

*TC 00:05:47;19
и наконец, нам нужен способ
разбираться с конфликтами, если 

*TC 00:05:51;02
два человека пытаются добавить
одну и ту же информацию 

*TC 00:05:52;25
одновременно.

*TC 00:05:52;25
У нас есть эти общие
элементы, чтобы выражать, 

*TC 00:05:56;01
что представляет из себя
та информация, с которой
мы работаем.

*TC 00:05:58;03
У нас есть и другие 
приятные вещи, 

*TC 00:05:59;20 
не входящие в
спецификации Atom, 

*TC 00:06:02;08
например, пакетная обработка
и поддержка мультимедиа.

*TC 00:06:05;01
Если мы делаем запрос
в канал Atom или 

*TC 00:06:07;17 
канал данных Google, 
что он собой представляет?

*TC 00:06:10;29
В принципе это просто
URL, содержащий 

*TC 00:06:14;05
сведения, сообщающие,
какой тип записей 

*TC 00:06:16;28
нам ожидать.

*TC 00:06:17;28
Таким образом, 
у нас есть URL, описывающий 

*TC 00:06:22;11
все документы  

*TC 00:06:23;26
чьего-нибудь аккаунта
Документов.

*TC 00:06:26;14
Может быть, нам нужно
только знать, 

*TC 00:06:28;19
какие там таблицы.

*TC 00:06:29;25
Поэтому второй URL
очень похож на первый, 

*TC 00:06:32;21
но использует запрос категории,
ограничивающий 

*TC 00:06:35;18
результаты только документами
с типом "таблица".

*TC 00:06:38;28
Наконец, мы можем, конечно,
получить только все 

*TC 00:06:40;20
отдельные записи и
связанную с ними информацию, 

*TC 00:06:43;17
передавая URL, содержащий
какой-то ключ документа.

*TC 00:06:47;18
Удобная вещь в 
данных Google,  

*TC 00:06:49;02
это то, что они содержат
совместимые функции во всех 

*TC 00:06:52;03
API, например, разные
форматы вывода, 

*TC 00:06:54;14
как JSON и RSS,
если ваша программа 

*TC 00:06:57;03
имеет встроенную
поддержку этих форматов.

*TC 00:06:59;07
В них есть также эта
модель аутентификации, 

*TC 00:07:01;25
о которой мы поговорим,
позволяющая 

*TC 00:07:03;25
аутентифицировать
пользователей в их
аккаунты Google 

*TC 00:07:06;01
и получать надежный
доступ к своим данным.

*TC 00:07:08;09
Мы создали несколько 
клиентских библиотек 

*TC 00:07:10;23
для многих языков, которые
анализируют эти данные XML и

*TC 00:07:14;19
Atom в удобную объектно-
ориентированную модель, 

*TC 00:07:18;06
которой можно управлять
прямо в том 

*TC 00:07:20;01
языке, к которому
вы привыкли.

*TC 00:07:21;18
Мы также предоставляем
некоторые настройки протокола, 

*TC 00:07:24;13
о которых я говорил, для
вещей, которые в Atom еще не сделаны, 

*TC 00:07:26;15
например, обработка пакетов,

*TC 00:07:27;20
если вам нужно сделать
несколько операций сразу. 

*TC 00:07:30;06
Как видите, есть несколько
API данных Google 

*TC 00:07:33;26
для многих популярных
продуктов Google,  

*TC 00:07:36;02
например, Календарь Google, Таблицы Google, Picasa и YouTube.

*TC 00:07:39;18
Теперь можно получать доступ
к данным в любом из этих продуктов, 

*TC 00:07:42;21
используя описываемую
мной семантику.

*TC 00:07:47;04
Например, 
попробуем пройти 

*TC 00:07:49;10
простым путем, который
я как программист мог бы 

*TC 00:07:51;28
использовать для
взаимодействия с API Календаря Google. 

*TC 00:07:55;24
Сперва мне нужен
какой-то способ аутентификации 

*TC 00:07:58;18
запроса, который
я собираюсь сделать.

*TC 00:08:00;26
Здесь у меня есть два варианта.  

*TC 00:08:02;15 
Один — AuthSub, а
второй — ClientLogin.

*TC 00:08:05;19
ClientLogin предназначен для
приложений для ПК, 

*TC 00:08:09;09
которые могут напрямую
получать учетные данные
пользователя 

*TC 00:08:13;10
и затем отправлять запросы 
на сервера Google. 

*TC 00:08:15;09
А AuthSub предназначен для
того, чтобы сторонние веб-сайты 

*TC 00:08:18;15
перенаправляли пользователей
на страницу входа Google и 

*TC 00:08:22;19
потом направляли назад
на веб-сайт. 

*TC 00:08:27;09
Оба эти способа дают
вашей программе 

*TC 00:08:29;25
нечто вроде идентификатора,
который можно передавать 

*TC 00:08:31;19
вместе с запросом и делать его,
таким образом, аутентифицированным.

*TC 00:08:35;07
Сперва посмотрим, что
нужно сделать, чтобы 

*TC 00:08:37;06
получить все события
из чьего-нибудь календаря.

*TC 00:08:39;12
Это очень просто, 
нужно лишь 

*TC 00:08:41;00
получить канал, передав
учетные данные, 

*TC 00:08:43;14
чтобы запрос был
аутентифицированным.

*TC 00:08:47;05
Обратно мы получаем его
уже с кодом "200 ОК", 

*TC 00:08:49;16
то есть запрос 
был успешным.

*TC 00:08:50;29
Также мы получаем канал
Atom, который кое-что нам 
сообщает 

*TC 00:08:54;00
о календаре, например, что
это календарь пользователя Тест,
 

*TC 00:08:57;16
и что он находится вне
зоны тихоокеанского времени.

*TC 00:09:02;03
Как вы можете заметить в этом
канале, у него нет событий 

*TC 00:09:05;20
в календаре, он, наверное,
очень одинок,

*TC 00:09:08;22
и, может быть, стоит
пригласить его в гости.

*TC 00:09:10;14
Я покажу, как создать
событие  

*TC 00:09:13;20
в его календаре, 

*TC 00:09:14;24
используя
семантику post HTTP.

*TC 00:09:17;28
Мы по сути просто
создаем запись Atom 

*TC 00:09:20;28
и отправляем ее в канал.

*TC 00:09:23;16
Как видите, мы
установили время начала, 

*TC 00:09:26;00
11:30, это начало
обеденного перерыва в Google.

*TC 00:09:28;21
Мы написали сведения о
нем в описании и

*TC 00:09:31;03
использовали эту категорию,
этот тип событий,

*TC 00:09:35;12
чтобы было понятно, что
это запись Atom, 

*TC 00:09:37;11
представляющая собой
событие календаря.
Мы его сделали 

*TC 00:09:40;28
и получаем
ответ 201 created,

*TC 00:09:42;16
то есть оно было успешно
добавлено в его календарь.

*TC 00:09:44;14
Обратно мы получаем
ту же запись, только теперь 

*TC 00:09:47;12
можно заметить ссылку для
редактирования в записи Atom,

*TC 00:09:51;23
которая позволяет вернуться к
записи и поменять ее.

*TC 00:09:54;04
Красным обозначен длинный
идентификатор, который  

*TC 00:09:58;11
определяет это событие.
Кроме того, вы заметите 

*TC 00:10:00;26
синим цветом строку версии,
которая представляет 

*TC 00:10:02;20
версию этого события,
коротая, естественно, 

*TC 00:10:04;25
первая, ведь мы
только что его создали.

*TC 00:10:06;23
Но мы же забыли
установить, 

*TC 00:10:10;14
где будет происходить
это событие.

*TC 00:10:12;07
Пользователь мистер
Тест не то чтобы гений, 

*TC 00:10:14;13
поэтому лучше сказать
ему, где это будет. 

*TC 00:10:15;14
Надо это 
отредактировать.

*TC 00:10:17;09
Теперь я использую
put, чтобы изменить 

*TC 00:10:19;18
только что созданное событие.

*TC 00:10:21;07
Обратите внимание, что
мы совершаем операцию put на ссылку
для редактирования, 

*TC 00:10:23;17
которая была в
предыдущем кадре.

*TC 00:10:25;27
Мы делаем этот запрос
на ссылку для редактирования 

*TC 00:10:28;16
со строкой той версии,
которую мы только что
использовали, 

*TC 00:10:30;29
и передаем сведения
для аутентификации, 

*TC 00:10:33;11
а затем просто размещаем
эту же запись Atom, 

*TC 00:10:36;24
только теперь мы
добавили (снизу, синим)

*TC 00:10:39;01
элемент "где", 
указывающий, что Google

*TC 00:10:42;11
находится в Калифорнии, Майнтин-Вью.

*TC 00:10:45;10
Теперь, когда запрос
пройдет, мы получим ответ "ОК",

*TC 00:10:48;10
теперь можно увидеть
последнюю версию события 

*TC 00:10:51;21
в его календаре.

*TC 00:10:53;07
Оно содержит все подробности,
чтобы он смог нас найти 

*TC 00:10:55;17
и пообедать с нами,
и это здорово.

*TC 00:10:57;16
Но вообще-то нам, может
быть, не понравится мистер
Тест, 

*TC 00:11:01;07
он слишком много разговаривает, 

*TC 00:11:02;11
поэтому его никто никуда
и не приглашает. 

*TC 00:11:05;07
Поэтому давайте
удалим это событие, 

*TC 00:11:07;25 
пока он его не увидел.

*TC 00:11:09;12
Для удаления события
нам нужно  

*TC 00:11:13;00
создать запрос удаления
с URL редактирования, 

*TC 00:11:15;02
который мы получили
с обновленной формой.

*TC 00:11:17;15
Заметьте, что я сказал URL
редактирования, который мы только
что получили.

*TC 00:11:20;12
Если мы возьмем исходный URL
редактирования, который мы 
применяли для изменения события, 

*TC 00:11:24;13
он не будет работать, 
так как эта 

*TC 00:11:26;29
синяя строка в конце, 
идентификатор версии 

*TC 00:11:28;24 
будет уже другой.

*TC 00:11:30;12
Но мы взяли правильный
и получаем 200 OK.

*TC 00:11:33;28
Если бы мы взяли
старый,  

*TC 00:11:35;14
мы бы увидели здесь
ошибку 409 conflict 

*TC 00:11:38;01
вместо 200 OK. Это 
значит, что теперь

*TC 00:11:40;15
на сервере есть более
новая версия события 

*TC 00:11:43;03
чем та, которую мы
пытаемся удалить.

*TC 00:11:44;18
Вы посмотрели пятнадцать
минут стремительного 

*TC 00:11:48;15
обзора того, как использовать
данные Google для некоторых
вещей. 

*TC 00:11:51;13
Теперь вы знаете, что
такое данные Google 

*TC 00:11:54;12
и как это работает с
XML и HTTP. 

*TC 00:11:58;09
Но, как и большинству людей, 
вам может быть лень создавать  

*TC 00:12:01;07
весь этот XML самостоятельно. Вам могут понравиться  

*TC 00:12:03;25
клиентские библиотеки высокого
уровня, которые мы поддерживаем
для большинства языков.

*TC 00:12:07;22
Поэтому стоит пойти по адресу code.google.com/apis/gdata, 

*TC 00:12:13;10
узнать больше подробностей и
загрузить нужную клиентскую
библиотеку.