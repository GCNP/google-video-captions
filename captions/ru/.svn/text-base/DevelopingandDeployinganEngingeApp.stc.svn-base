*TC 00:00:02;24
Привет! Я Бретт Слакен,
разработчик программного обеспечения в

*TC 00:00:05;08
группе, работающей над механизмом приложений Google 

*TC 00:00:06;28
Механизм приложений позволяет 
редакторам создавать веб-приложения

*TC 00:00:09;05
в инфраструктуре Google.

*TC 00:00:10;20
Сегодня я покажу вам, как
быстро создать приложение

*TC 00:00:12;15
гостевой книги, используя
механизм приложений.
Начнем.

*TC 00:00:16;10
Сначала мы создадим каталог 
для нового приложения и

*TC 00:00:18;24
откроем его в моем редакторе.

*TC 00:00:24;00
Теперь я создам файл 
"app.yamo"с конфигурацией

*TC 00:00:25;14
моего приложения.

*TC 00:00:29;23
Я введу название своего приложения.

*TC 00:00:32;06
Затем – версию приложения, 

*TC 00:00:34;11
в нашем случае это первая версия.

*TC 00:00:36;01
Далее – версию API, которые я 
буду использовать.

*TC 00:00:38;05
И среда, у нас – Python.

*TC 00:00:42;00
Теперь я объявляю, как мои URL
будут сопоставляться

*TC 00:00:43;13
с приложением.

*TC 00:00:45;19
В этом случае я сделаю так, чтобы
все URL шли в один

*TC 00:00:48;16
сценарий Python под названием "main".

*TC 00:00:51;09
Я создам свой основной
файл Python.

*TC 00:00:56;18
Я задам очень простоеприложение, выводящее надпись "Hello world".

*TC 00:01:06;17
Теперь я отправлюсь на
терминал и запущу

*TC 00:01:08;01
веб-сервер разработки.

*TC 00:01:12;00
Теперь сервер работает, я
могу пойти и посмотреть

*TC 00:01:13;29
"на приложение "Hello world".

*TC 00:01:19;26
Давайте сделаем теперь что-то
посложнее и создадим 

*TC 00:01:21;16
веб-приложение.

*TC 00:01:23;28
Для этого у нас есть очень
простая среда для веб-приложений,

*TC 00:01:26;10
которая называется "Web App".

*TC 00:01:28;01
Я импортирую модуль
"Web App" и определяю

*TC 00:01:33;19
обработчик, который займется
запросами от

*TC 00:01:35;21
приложения.

*TC 00:01:42;03
Методы этого класса будут
обрабатывать запросы HTTP.

*TC 00:01:45;03
В этом случае я просто хочу
обработать запрос get и 

*TC 00:01:47;22
вывестисообщение "Hello world".

*TC 00:01:54;03
В качестве обработчика схемы
текста я буду использовать "wsgiref",
это

*TC 00:01:57;09
стандартный контейнер 
веб-приложений Python.

*TC 00:02:11;28
Я определю "WSGIApplication" во всех

*TC 00:02:15;00
доступах URL к моему
простейшему обработчику.

*TC 00:02:31;10
И, конечно, задам Python
выполнение моей главной функции.

*TC 00:02:40;08
Теперь посмотрим на
это в браузере.

*TC 00:02:44;19
Здорово. Текст появляется, и
все работает.

*TC 00:02:48;01
Теперь используем шаблоны,
чтобы эта страница лучше выглядела.

*TC 00:02:50;23
Для этого мы предоставляем 
базовую библиотеку.

*TC 00:02:54;22
Создадим файл шаблона
с помощью шаблонов Django.

*TC 00:03:01;23
Сначала создадим фрагмент
кода HTML, который выводит 

*TC 00:03:04;00
надпись "Hello world".

*TC 00:03:09;08
Я импортирую наш
модуль шаблона.

*TC 00:03:18;02
Затем я его выведу.

*TC 00:03:28;12
Теперь посмотрим, как это 
выглядит в браузере.

*TC 00:03:34;06
Теперь давайте создадим
простой пользовательский
интерфейс для своего веб-
приложения.

*TC 00:03:37;26
Вернемся к файлу
шаблона и начнем писать

*TC 00:03:40;23
пользовательский интерфейс
и HTML.
Возьмем форму.

*TC 00:03:47;05
Выберем метод post.

*TC 00:03:49;18
В форме будет пара
полей. 

*TC 00:03:51;00
Так как это гостевая книга,
начнем с сообщения,

*TC 00:03:53;13
которое нам нужно.

*TC 00:03:55;19
У нас это просто текстовые
поля, содержащие "message"
(сообщение).

*TC 00:04:01;29
Мы сделаем так, чтобы
кнопка отправки сообщения
называлась "shout" (прокричать).

*TC 00:04:08;03
Теперь можно вернуться
и посмотреть на то,
что получилось, в браузере.

*TC 00:04:12;07
Теперь пусть наше веб-
приложение обработает запрос

*TC 00:04:14;00
post, а потом займемся
чем-нибудь более интересным.

*TC 00:04:18;05
Я изменю "MyHandler", чтобы
он обрабатывал запросы post, как и

*TC 00:04:20;23
запросы "get".

*TC 00:04:36;07 
Теперь свяжем это
с хранилищем данных.

*TC 00:04:39;02
Для использования хранилища
данных я импортирую 
модуль dv, 

*TC 00:04:41;25
и чтобы найти класс 
модели, который говорит, 
какие поля нужно сохранить

*TC 00:04:45;24
в хранилище данных.

*TC 00:04:48;02
В нашем случае класс модели
будет называться "Shout".

*TC 00:04:54;27
Я сделаю два поля. Сначала сообщение.

*TC 00:05:02;04
А затем время, когда
было оставлено сообщение.

*TC 00:05:13;05
Теперь в методе post я 
воспользуюсь параметрами
запроса, чтобы

*TC 00:05:16;07
создать новый "Shout" и
разместить его в хранилище
данных.

*TC 00:05:28;16
Затем я перенаправлю пользователя
обратно на главную страницу.

*TC 00:05:32;26
Теперь я могу вернуться
в браузер и убедиться,

*TC 00:05:34;18
что пока все работает.

*TC 00:05:38;25
Теперь мы обрабатываем
post, размещаем сообщения 
и данные в

*TC 00:05:40;13
хранилище данных,
но не получаем их.

*TC 00:05:42;12
Давайте создадим запрос
для получения оттуда данных

*TC 00:05:44;19
и представления их пользователю.

*TC 00:05:46;14
Для этого я создам 
"GqlQuery".

*TC 00:05:57;13
Затем я использую результаты
запроса для

*TC 00:06:00;03
заполнения своих шаблонов.

*TC 00:06:04;23
Передает значения в 
обработчик шаблонов.

*TC 00:06:10;22
Теперь, если я зайду в свой
шаблон, я могу использовать
результаты

*TC 00:06:12;22
запроса и вывести их
пользователю.

*TC 00:06:19;10
В этом случае я
использую шаблоны Django.

*TC 00:06:30;16
Теперь я могу вернуться 
в браузер и убедиться,

*TC 00:06:32;14
что все работает.

*TC 00:06:36;15
Есть два моих запроса,
созданных раньше.

*TC 00:06:39;21
Теперь я могу ввести
и другие сообщения.

*TC 00:06:43;08
Вы видите, что они не в
каком-то определенном 
порядке.

*TC 00:06:45;07
Я хотел бы добавить
в запрос порядок сортировки.

*TC 00:06:59;21
Новые сообщения будут
сверху.

*TC 00:07:04;29
Я изменю модель, чтобы 
в ней было другое свойство,

*TC 00:07:07;07
гласящее
"кто разместил сообщение?"

*TC 00:07:09;16
В этом случае оно 
дополнительное, потому что
некоторые сообщения

*TC 00:07:11;17
не имеют явного
отправителя.

*TC 00:07:15;24
Теперь я пойду в
свой шаблон и добавлю

*TC 00:07:16;24
это новое поле.

*TC 00:07:29;07
Было бы неплохо иметь
подписи для этих полей ввода.

*TC 00:07:33;06
Затем мне нужно убедиться, 
что при создании сообщения
я

*TC 00:07:35;04
правильно заполнил
поле "кто".

*TC 00:07:41;03
Я бы также хотел вывести сведения о том,
кто отправил каждое сообщение.

*TC 00:07:43;03
Поэтому я вернусь к шаблону
и добавлю это тоже.

*TC 00:07:51;18
Если поле "кто" пусто, 
я просто скажу, что

*TC 00:07:53;12
оно анонимное.

*TC 00:08:10;06
Теперь пойдем снова в
браузер и посмотрим,

*TC 00:08:11;09
как это выглядит.

*TC 00:08:13;29
Вы видите, что все сообщения
анонимные, потому что

*TC 00:08:15;29
ни у одного из них не было
отправителя.

*TC 00:08:17;08
Добавим новое, отправителем
буду я.

*TC 00:08:24;10
Появилось мое имя.

*TC 00:08:27;11
Последнее, что я хочу сделать,
это задать такое название, которое
бы показывало, что

*TC 00:08:30;08
это мое приложение и оно 
называется "shoutout!"

*TC 00:08:36;00
Для этого приложения я
воспользуюсь App Config Tool.

*TC 00:08:39;09
Я просто введу "appcfig
update" для развертывания 

*TC 00:08:41;21
приложения и затем
несущего название каталога
приложения.

*TC 00:08:48;18
Готово.

*TC 00:08:49;26
Теперь можно получить
доступ к этому приложению
на appspot.com.

*TC 00:08:57;24
Теперь разместим сообщение.

*TC 00:09:04;25
Вот и все. Мы создали и развернули
приложение.

*TC 00:09:08;10
Надеемся, вы заинтересовались
механизмом приложений Google. 

*TC 00:09:10;02
Будем рады вашим
комментариям.

*TC 00:09:12;01
Если вы хотите узнать
о механизме приложений
подробнее, присоединяйтесь

*TC 00:09:13;23
к нам на Google IO, 
мероприятии Google для 
разработчиков

*TC 00:09:16;16
28 и 29 мая.

*TC 00:09:18;17
Спасибо за внимание.



