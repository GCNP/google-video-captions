
*TC 00:12:19;27
您好，我是 Jeff Fisher，
如果您正在观看本视频， 

*TC 00:00:04;10
那么您可能是一位对于
通过 Google 产品的 API， 

*TC 00:00:06;07
或者更具体地说，是对于

*TC 00:00:07;28
通过遵守 Google 数据协议的 API
来使用这些产品感兴趣的开发人员。

*TC 00:00:11;27
您可能会问我，什么
是 Google 数据协议？

*TC 00:00:14;25
回答这个问题之前，
我必须先介绍一些 

*TC 00:00:17;10
背景信息。

*TC 00:00:19;03
我猜想您
已经熟悉 

*TC 00:00:21;19
HTTP 和 XML 技术。

*TC 00:00:24;11
很久以来，众多网站
都在寻找替代的方式， 
 
*TC 00:00:26;16
以便可以通过更便于
计算机理解的方式 

*TC 00:00:28;19
来分发
网站内容。

*TC 00:00:30;19
计算机并不是非常智能，
因此它们也需要 

*TC 00:00:32;23
些许帮助来像我们
一样理解信息。

*TC 00:00:36;12
下面让我们看一个简单的
例子，比如博客网站。

*TC 00:00:39;27
博客网站具有
大量的新闻文章， 

*TC 00:00:42;23
这些文章显示在
庞大的列表中， 

*TC 00:00:45;11
并具有摘要、标题、
作者以及发表日期。

*TC 00:00:48;03
这是基本信息。

*TC 00:00:49;17 
如何以便于计算机理解的
方式来表示这些信息呢？

*TC 00:00:52;17
要解决这个问题，首先
可以尝试使用 RSS，

*TC 00:00:55;14
不过现在我要
谈论的是 

*TC 00:00:57;15
Atom 联合格式。

*TC 00:00:59;18
Atom 是基于 XML 的
方法，用来描述 

*TC 00:01:02;14
这些网站上的数据，
可以使计算机 

*TC 00:01:05;08
轻松地分析出该信息。

*TC 00:01:07;16
这样，在底层
您可以有 

*TC 00:01:11;10
包含多个条目的供稿元素，
并且每个条目都将具有 

*TC 00:01:14;18 
与该博客网站上的帖子
相关联的所有元数据。

*TC 00:01:18;10
由此，现在可以通过
一种简洁的方式 

*TC 00:01:21;02
来描述该博客上的所有
内容，这真是太棒了！

*TC 00:01:23;18
但是，如果要创建编辑该博客，
而不仅仅是读取其内容的方案， 

*TC 00:01:26;18
应该怎么办呢？

*TC 00:01:28;22
要达到该目的，我可以
创建全新的机制， 

*TC 00:01:31;21
并且使这个机制
与上述供稿机制 

*TC 00:01:34;18
截然不同；
我也可以 

*TC 00:01:36;22
尝试再次使用上述供稿机制。

*TC 00:01:38;09
如果要再次使用
这种可以在 

*TC 00:01:40;07
XML 中非常恰当地
描述帖子的格式，

*TC 00:01:44;06
如何将该数据
传送到服务器呢？

*TC 00:01:46;12
由于已经使用 HTTP 
对这些帖子进行了检索， 

*TC 00:01:49;08
因此只需使用 HTTP，
便可以编辑和 

*TC 00:01:52;22
删除该内容
以及创建新内容。

*TC 00:01:54;26
现在我们可以通过再次使用
已有机制，并且只使用 

*TC 00:01:59;05
HTTP 中的其他动作，例如
put、post 和 delete，

*TC 00:02:04;00
就可以周而复始地通过
仅在底层编辑供稿 

*TC 00:02:07;28
来管理博客内容。
这真是太棒了！

*TC 00:02:10;12
如果没有博客条目，
该怎么办呢？

*TC 00:02:14;01
如果不是博客，该怎么办呢？
如果是 

*TC 00:02:16;14
日历或电子表格等网站，
如何表示该数据呢？

*TC 00:02:20;23
您可以 

*TC 00:02:22;06
通过新的方式
尝试表示数据，

*TC 00:02:24;14
也可以尝试再次使用
这种 Atom 方法。

*TC 00:02:27;28
如果您使用
Atom 方法，

*TC 00:02:29;11
这也正是 Google 数据
尝试采用的方法，

*TC 00:02:32;28 
那么，

*TC 00:02:35;05
我将向您
举例说明  

*TC 00:02:37;13
Atom 供稿的基本内容。

*TC 00:02:39;04
Atom 供稿类似于 

*TC 00:02:41;09
我们之前谈论的 XML，
它包含多个条目。 

*TC 00:02:44;27
每个供稿都具有自己的
元数据以及每个条目。

*TC 00:02:49;20
您还将注意到，每个条目
都具有唯一的标识符， 

*TC 00:02:53;08
使其区别于网站上的
其他所有条目，  

*TC 00:02:56;15
还有一些用于对该条目
进行编辑的信息。

*TC 00:03:01;10
这样， 

*TC 00:03:03;10
获取该条目并
将其放置到 

*TC 00:03:06;16 
可编辑表单中后，
我们便将其称为 

*TC 00:03:08;02
Atom 发布协议。  

*TC 00:03:09;25
Atom 发布协议将
提取所有这些条目， 

*TC 00:03:13;14
并将其转变为资源。

*TC 00:03:15;15
现在，这些资源可以
是传统文本资源， 

*TC 00:03:19;11
也可以是图片文件和
视频等媒体资源。

*TC 00:03:24;04
它也会再次使用我们已经
讨论过的 HTTP 请求 

*TC 00:03:27;20
来处理该数据，
然后使用 

*TC 00:03:30;26
HTTP 响应代码
来表明 

*TC 00:03:32;18
该操作是
成功、出错 

*TC 00:03:35;04
还是需要验证。

*TC 00:03:37;16
现在，Atom 发布协议通常
被称为 RESTful 协议， 

*TC 00:03:40;00
该协议使用
RESTful 语法

*TC 00:03:44;24
来修改这些资源，
因此，所有请求 

*TC 00:03:48;02
都相互独立，并且
无需请求 

*TC 00:03:51;19
其它任何诸如会话等上下文
便可以知道要执行的操作。

*TC 00:03:55;17
下面我们来看一个发布
实例，它的目的是 

*TC 00:03:59;07
使用 AtomPub 在博客上
创建一个条目

*TC 00:04:02;04
您会注意到存在
某些验证信息， 

*TC 00:04:04;07
还有其他一些元数据，
但是基本上我们 

*TC 00:04:06;29
要发布的所有内容
只是 Atom 条目， 

*TC 00:04:08;24
就是在 Atom 供稿上
获取的内容。

*TC 00:04:10;21
发布这部分数据之后，
我们就已经创建了该条目。 

*TC 00:04:14;15
取回我们创建的条目，
该条目还具有其它一些 

*TC 00:04:17;00
成员，例如编辑链接，
如果愿意，您可以 

*TC 00:04:19;10
进行编辑，该条目
还具有 

*TC 00:04:22;04
某种类型的版本字符串。

*TC 00:04:23;14
在本例中，
您会看到“Etag”， 

*TC 00:04:25;10
它可唯一标识
对该贴子的特定修订。

*TC 00:04:29;13
响应代码 201
用来指示 

*TC 00:04:32;01
已在服务器上成功
创建该内容。

*TC 00:04:35;20
那么，什么是 Google 数据呢？
如何使用 Google 数据呢？  

*TC 00:04:40;02
这是查看 Atom 
供稿的抽象方式。

*TC 00:04:43;22
如果要使用 Atom 表示
不是博客帖子的条目， 

*TC 00:04:45;15
需要
什么呢？

*TC 00:04:47;20
可能需要描述这些条目的
一些自定义 XML。  

*TC 00:04:50;21
关联的元素将位于其中。
Google Data 关联的元素 

*TC 00:04:50;21
用来表示许多 API 中
的抽象概念，例如： 

*TC 00:04:59;16
位置在哪里？
时间是何时？ 

*TC 00:05:01;21
联系哪个设备？  不必在
每次指定新 API 

*TC 00:05:04;10
或使用其他产品时
重复设置 

*TC 00:05:06;16
这些
内容。

*TC 00:05:08;22
由于 Atom 允许您
扩展其 XML， 

*TC 00:05:11;21
那么，在具有这种可以
完美适合 Atom 模型的 

*TC 00:05:13;18
XML 之后，
还需要什么呢？

*TC 00:05:17;02
还需要已作为 Google
数据的一部分 

*TC 00:05:22;03
添加到 AtomPub
的内容，例如 

*TC 00:05:22;02
查询语言和验证。
通过将这些内容用作 API，

*TC 00:05:24;23
Google 数据一般可以使
AtomPub 试图实现的操作 

*TC 00:05:29;19
符合
我们的预期。

*TC 00:05:33;00
正如我已经提到的，
需要某种形式的 

*TC 00:05:34;21
验证
才能使用 

*TC 00:05:36;19
Google 服务，并绑定
到 Google 帐户， 

*TC 00:05:39;13
我们还需要使用
某种方式来限制 

*TC 00:05:43;07
使用该供稿尝试
访问的内容类型。 

*TC 00:05:47;19
然后，我们需要使用
某种方式来处理 

*TC 00:05:51;02
两个用户尝试同时
添加相同信息时 

*TC 00:05:52;25
产生的冲突。

*TC 00:05:52;25
然后，使这些通用元素
表示我们正在使用的 

*TC 00:05:56;01
是哪些信息。我们还具有
其它一些绑定内容，

*TC 00:05:58;03
例如批处理和
媒体支持， 

*TC 00:05:59;20 
它们
不是 

*TC 00:06:02;08
Atom 规范的
一部分。

*TC 00:06:05;01
那么在这个例子中，对 Atom
供稿或 Google 数据供稿 

*TC 00:06:07;17 
进行查询时，
应该输入什么呢？

*TC 00:06:10;29
一般应该只
输入网址， 

*TC 00:06:14;05
该网址应包含充足的信息
来说明我们希望获得 

*TC 00:06:16;28
哪种类型的条目。

*TC 00:06:17;28
这里的第一个
网址表示 

*TC 00:06:22;11
查询某人的  

*TC 00:06:23;26
文档和电子表格帐户中的
所有文档。

*TC 00:06:26;14
可能我们真正
关心的只是 

*TC 00:06:28;19
它们具有哪些电子表格。

*TC 00:06:29;25
这里的第二个网址
与第一个非常类似， 

*TC 00:06:32;21
但是它使用类别查询
来限制结果集里 

*TC 00:06:35;18
只显示
电子表格文档类型。

*TC 00:06:38;28
最后一个网址
包含某种类别的 

*TC 00:06:40;20
文档密钥，
可以用来 

*TC 00:06:43;17
检索单个条目
及其相关信息。

*TC 00:06:47;18
Google 数据
的优点是  

*TC 00:06:49;02
在所有 API 中
具有一致的功能， 

*TC 00:06:52;03
例如 Json 和 RSS 等
替代输出格式。 

*TC 00:06:54;14
如果需要，您在
本地使用的软件 

*TC 00:06:57;03
可以使用
这些格式。

*TC 00:06:59;07
Google 数据
还具有 

*TC 00:07:01;25
我们将要谈论的验证模型，
这个模型允许您 

*TC 00:07:03;25
验证用户的
Google 帐户 

*TC 00:07:06;01
以及安全访问
他们的数据。

*TC 00:07:08;09
我们已为多种语言
创建了许多客户端库， 

*TC 00:07:10;23
这些库可以将
该 XML 和 Atom 数据

*TC 00:07:14;19
分析为易用的
面向对象的模型， 

*TC 00:07:18;06
您可以使用
熟悉的语言 

*TC 00:07:20;01
直接
进行操作。

*TC 00:07:21;18
我们还提供了某些
协议自定义功能， 

*TC 00:07:24;13
比如我已提到的
Atom 尚未规范的功能， 

*TC 00:07:26;15
例如批处理。

*TC 00:07:27;20
如果需要，您可以
一次执行多个操作。 

*TC 00:07:30;06
正如您所看到的，许多
流行的 Google 产品 

*TC 00:07:33;26
具有大量
Google 数据 API， 

*TC 00:07:36;02
例如 Google 日历、Google 电子表格、
Picasa 和 Youtube。

*TC 00:07:39;18
现在您可以使用
我向您介绍的相同语法 

*TC 00:07:42;21
来访问任意产品中
的数据。

*TC 00:07:47;04
例如，
简单的设想一下， 

*TC 00:07:49;10
假如我是
编程人员， 

*TC 00:07:51;28
要与 Google 日历
API 进行交流， 

*TC 00:07:55;24
那么，首先我需要使用
某种方式来验证 

*TC 00:07:58;18
我将要
提出的请求。

*TC 00:08:00;26
我可以使用两种方式。  

*TC 00:08:02;15 
一种是 AuthSub，
另一种是 ClientLogin。

*TC 00:08:05;19
ClientLogin 是针对基于
桌面的应用程序设计的， 

*TC 00:08:09;09
用户可以直接
输入其凭证， 

*TC 00:08:13;10
然后向 Google 的服务器
提出他们的请求。 

*TC 00:08:15;09
而 AuthSub 旨在允许
第三方网站 

*TC 00:08:18;15
将用户重新导向 Google 的
登录页面，然后 

*TC 00:08:22;19
重新导回
存在问题的网站。 

*TC 00:08:27;09
这两种方式都将
为您的程序授予 

*TC 00:08:29;25
某种类型的令牌，
您可以将其与请求 

*TC 00:08:31;19
一同传送，并使其
成为经验证的请求。

*TC 00:08:35;07
首先，让我们了解要
检索某人的日历中的 

*TC 00:08:37;06
所有事件，必须
执行哪些操作。

*TC 00:08:39;12
这非常简单，
我们只需 

*TC 00:08:41;00
向下拖动
传递凭证的供稿， 

*TC 00:08:43;14
并提出这个
已验证的请求。

*TC 00:08:47;05
这样，当取回该供稿时，
结果显示“200 OK”， 

*TC 00:08:49;16
这意味着，
该请求是成功的，

*TC 00:08:50;29
我们取回的 Atom 供稿
说明了有关此日历的 

*TC 00:08:54;00
一些信息，例如这是
Test User 先生的日历， 

*TC 00:08:57;16
而且他的日历以
太平洋时区为根据。

*TC 00:09:02;03
但是，正如您在此供稿中
看到的，当前他的日历中 

*TC 00:09:05;20
没有任何事件，因此，
他是一个非常孤独的人，

*TC 00:09:08;22
也许，我们应该
邀请他共进午餐。

*TC 00:09:10;14
现在我要演示如何
使用 HTTP 的 

*TC 00:09:13;20
post 语法 

*TC 00:09:14;24
在此日历上
创建事件。

*TC 00:09:17;28
实际上，我们只需
创建 Atom 条目， 

*TC 00:09:20;28
然后发送到供稿就可以了。

*TC 00:09:23;16
正如您所看到的，我们
将 11：30 设置为 

*TC 00:09:26;00
在 Google 享用午餐
的开始时间。

*TC 00:09:28;21
我们在说明中设置了
与其有关的某些信息，

*TC 00:09:31;03
我们使用的是这种类别，
这类事件。

*TC 00:09:35;12
因此，用户
知道这是 

*TC 00:09:37;11
表示日历事件的 Atom 条目。
创建该事件之后， 

*TC 00:09:40;28
会收到响应
“201 created”，

*TC 00:09:42;16
这意味着已成功地
将事件添加到他的日历，

*TC 00:09:44;14
并将取回同一条目，
此外，您还将注意到 

*TC 00:09:47;12
该 Atom 条目中
具有编辑链接，

*TC 00:09:51;23
该链接可以让我们
返回并进行修改，

*TC 00:09:54;04
条目中还有一个
红色的长 ID， 

*TC 00:09:58;11
它可唯一标识此特定事件，
您会注意到有一个 

*TC 00:10:00;26
蓝色的版本字符串，
它表示此事件的版本， 

*TC 00:10:02;20
当然，这是事件
自创建之后的 

*TC 00:10:04;25
第一个
版本。

*TC 00:10:06;23
不过，您会注意到，
在该条目中 

*TC 00:10:10;14
忘记了设置
事件发生的地点，

*TC 00:10:12;07
Test User 先生
并非无所不知， 

*TC 00:10:14;13
因此，最好告诉他
事件发生的地点， 

*TC 00:10:15;14
我们最好编辑一下
这个条目。

*TC 00:10:17;09
现在，我们要
使用 put 编辑 

*TC 00:10:19;18
刚才创建的事件。

*TC 00:10:21;07
您会看到，我们将对
上一张幻灯片中显示的 

*TC 00:10:23;17
编辑链接
执行 put 操作。

*TC 00:10:25;27
因此，现在我们使用
刚才用到的版本字符串 

*TC 00:10:28;16
向编辑链接
发出请求， 

*TC 00:10:30;29
然后要传送
我们的验证信息， 

*TC 00:10:33;11
我们只需放置同一个
Atom 条目就可以了。 

*TC 00:10:36;24
此外，我们在底部
添加了蓝色。

*TC 00:10:39;01
蓝色元素指明
Google 位于

*TC 00:10:42;11
加利福尼亚的
山景城。

*TC 00:10:45;10
现在已发出请求，
结果为“OK”，

*TC 00:10:48;10
您可以在他的
日历上看到 

*TC 00:10:51;21
此事件的最新表单，

*TC 00:10:53;07
该表单有他要找到我们
所需的所有细节， 

*TC 00:10:55;17
这样他就可以与我们
共进午餐，这真是太棒了。

*TC 00:10:57;16
但是，可能我们并不真正
喜欢 Test User 先生， 

*TC 00:11:01;07
比如，他话太多， 

*TC 00:11:02;11
出于某种原因，
没有人愿意邀请他， 

*TC 00:11:05;07
因此，我们希望在他看到
与他有关的事件之前 

*TC 00:11:07;25 
删除该事件。

*TC 00:11:09;12
现在要删除事件，
我们只需  

*TC 00:11:13;00
使用我们刚刚从
更新的表单中 

*TC 00:11:15;02
取回的编辑网址来
发送删除请求就可以了。

*TC 00:11:17;15
请注意，我说的是刚刚
取回的表单中的编辑网址，

*TC 00:11:20;12
如果使用最初编辑事件所
使用的原始编辑网址， 

*TC 00:11:24;13
它将不再起
作用，因为 

*TC 00:11:26;29
末尾的蓝色字符串，
也就是版本 ID 

*TC 00:11:28;24 
已发生变化。

*TC 00:11:30;12
不过由于我们使用正确，
因此结果显示“200 OK”。

*TC 00:11:33;28
如果我们使用了
前一个网址， 

*TC 00:11:35;14
这里将会显示
“409 conflict error”， 

*TC 00:11:38;01
而不是“200 OK”。 这就是说

*TC 00:11:40;15
服务器上事件的版本
比我们想要删除 

*TC 00:11:43;03
的事件版本更新。

*TC 00:11:44;18
现在，我们花了
15 分钟 

*TC 00:11:48;15
快速学习了如何通过特定事件
来使用 Google 数据， 

*TC 00:11:51;13
您已了解
Google 数据的基本概念， 

*TC 00:11:54;12
及其如何在 XML 的底层起作用
以及如何使用 HTTP。 

*TC 00:11:58;09
但是，也许您
和大多数人一样，  

*TC 00:12:01;07
并不想自行构建全部 XML，
您可能对 

*TC 00:12:03;25
更高层的客户端库更感兴趣。
我们支持您选择的语言。

*TC 00:12:07;22
现在，您应访问
code.google.com/apis/gdata 

*TC 00:12:13;10
以查找更多信息，以及
下载所选的客户端库。