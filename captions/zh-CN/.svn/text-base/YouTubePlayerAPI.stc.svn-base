*TC 00:00:07;06
您好！我是 Stephanie Liu，
我是 YouTube API

*TC 00:00:10;00
和工具团队的一员。 

*TC 00:00:11;06
现在，我要来讲讲
使用新的播放器 API

*TC 00:00:13;21
和 Chromeless 播放器
的一些简单示例。 首先来了解一下

*TC 00:00:16;24
背景知识。  过去，如果要
将 YouTube 视频

*TC 00:00:19;06
嵌入到您的站点上，
您所能做的只是选择

*TC 00:00:21;21
一个标准的嵌入式播放器，
然后将其放在您的站点上。 作为一名开发人员，

*TC 00:00:24;24
您实际上并不了解
整个过程运行的

*TC 00:00:26;15
具体情况。  而现在，您可以做的
绝不仅仅只有这些。 我们刚刚发布的

*TC 00:00:26;15
JavaScript API 和
Flash API 可让您

*TC 00:00:31;27
控制我们的嵌入式播放器。
您可以发出命令，例如播放、

*TC 00:00:35;00
暂停、找到视频中的特定位置、
静音、设置音量；另外还有

*TC 00:00:38;12
获取数据，例如获取当前时间
以及视频的缓冲

*TC 00:00:42;09
进度。 还可以订阅
事件，例如

*TC 00:00:44;12
播放器状态的更改。
现在的 Chromeless 播放器

*TC 00:00:47;18
是没有播放器控件的 swf 播放器。
因此也就没有 YouTube 按钮

*TC 00:00:51;03
或进度条。 您可以加入自己的按钮
并将其自定义成适合

*TC 00:00:53;18
您站点风格的
播放器。 好的，现在我们

*TC 00:00:57;09
开始讲讲 JavaScript 播放器 API
能实现一些什么样的功能。

*TC 00:01:00;29
这里，我们已准备了常规的
YouTube 嵌入式播放器。 我想

*TC 00:01:03;11
大家对此都已
非常熟悉了。

*TC 00:01:06;29
它可以播放，那现在我要
告诉您如何设置这种嵌入

*TC 00:01:11;11
的播放器，以便我们可以
对其进行 API 调用。 您要做的第一件事

*TC 00:01:14;26
就是加入
“swfobject.js”。 这里，我建议

*TC 00:01:19;02
使用 swfobject 的原因
是因为它使 Flash 内容 

*TC 00:01:21;05
的嵌入容易很多。
它会为您处理很多事情，

*TC 00:01:23;20
例如检测用户的
 Flash 版本。 用户需要具有

*TC 00:01:27;02
8 或以上的版本
才能正常地显示

*TC 00:01:29;20
您的播放器。 然而这里就是要
放置嵌入内容的

*TC 00:01:36;20
div。 您会注意到，我们将其命名为
“ytapiplayer”，

*TC 00:01:40;17
这个我们会
在后面用到。 然而，如果用户不具有

*TC 00:01:43;26
8 或以上版本，他们
看到的将是这行文本，

*TC 00:01:46;02
而不是一个损坏的播放器。
现在，我们将进入

*TC 00:01:50;02
您最关心的环节。 在这里我们准备
实际对嵌入对象

*TC 00:01:52;17
进行设置。 

*TC 00:01:58;08
您可以看到这里就是
我们在嵌入对象中

*TC 00:02:00;28
所需要设置的参数。
我们需要

*TC 00:02:02;28
将“allowScriptAccess:” 设置为“always”。
这表示 YouTube swf 可以

*TC 00:02:07;10
调用您的 HTML 页面。
并且，您的 HTML 页面

*TC 00:02:10;10
可以调用播放器 swf。 还有一个我们需要设置的
就是将属性的 ID 设置为

*TC 00:02:14;22
“myytplayer”。 它将成为
嵌入对象

*TC 00:02:20;10
的名称。 稍后，您可以使用 
JavaScript 命令

*TC 00:02:24;01
geteElementById 来通过
此名称为播放器获取参考。

*TC 00:02:33;22
这样，“swfobject.embedSWF”
将实际从 YouTube 加载

*TC 00:02:37;07
播放器，并将其嵌入
到您的 HTML 页面中。 我们来看一下

*TC 00:02:41;10 
此处您所需要的
所有参数。 第一个参数

*TC 00:02:45;28
是 swf 播放器的 URL 地址。
“enableksopi=1”可以使

*TC 00:02:53;04
播放器接收
API 调用。 

*TC 00:02:57;25 
而“playerapiid”
则是在播放器加载完成

*TC 00:03:02;03
并准备运行时要作为
第一个自变量传递给

*TC 00:03:05;24
“onYouTubePlayerReady”
的参数。 接着，您需要

*TC 00:03:09;06
命名播放器，因为
当页面上有多个视频

*TC 00:03:12;18
需要加载时，您将
希望知道哪个

*TC 00:03:16;21
播放器已将
视频加载完成。 此处的第二个参数

*TC 00:03:23;15
是 HTML div 的 ID，
嵌入的内容将放置在

*TC 00:03:26;24
这里面。 正如您看到的，
我们此处

*TC 00:03:31;18
调用的就是“ytopiplayer”。 然后，这里是
宽度、高度，以及

*TC 00:03:36;15
用户所需要的 
Flash 的最低版本 因此，请记住，

*TC 00:03:41;06
他们需要“8”
或以上版本

*TC 00:03:43;18
才能正常地观看您的内容。 然后是一组
我们将不使用

*TC 00:03:48;09
的可选参数。 还有就是
我们在这里

*TC 00:03:51;03
所设置的参数和属性。 好了，现在已经将
嵌入的内容设置为

*TC 00:03:55;03
可以接收 API 调用，接下来
让我们来做一些更有趣的事情。

*TC 00:03:57;15
我们可以输入一些命令。

*TC 00:03:58;27
在这里，我已经
添加了一组链接，

*TC 00:04:01;14
我们可以不使用按钮，
而使用这些链接来

*TC 00:04:03;17
控制播放器。 我来进行播放，
然后暂停。 停止。 静音。 取消静音。 接下来，

*TC 00:04:12;08
我来告诉您
设置这些链接所需的

*TC 00:04:15;11
非常简单的调用。 我前面讲过，
播放器

*TC 00:04:18;20
加载完成并准备运行时，
它会调用

*TC 00:04:20;29
“onYouTubePlayerReady”。

*TC 00:04:23;02
所以，在这里我们将
定义此函数。 我们只不过是

*TC 00:04:26;23
获取播放器的参考，
并将其存储，这样

*TC 00:04:29;14
我们便可以对其进行 API 调用。 设置完这些内容后，
我们便可以开始

*TC 00:04:33;11
设置这些链接了。

*TC 00:04:35;17
这里就是我们设置
这些链接的过程。 非常的简单，

*TC 00:04:39;29
只不过是一个伴随“onclick”动作
即调用此播放函数的链接。 而这里

*TC 00:04:44;20
就是我们定义该函数的过程。
只不过是执行了一些

*TC 00:04:44;20
错误检查，以确保它不为空，
然后调用

*TC 00:04:50;08
“ytplayer.playVideo”。
就是这样简单。 同样，

*TC 00:04:55;23
对于“暂停”，我们调用
“.pauseVideo”，对于“停止”，

*TC 00:04:59;20
调用“stopVideo”，
“静音”和“取消静音”也一样。 这就像直接

*TC 00:05:05;16
向播放器发出
这些命令一样简单。 现在我们已经发出了一些

*TC 00:05:08;07
基本的命令，接下来让我们
尝试进行一些输入，

*TC 00:05:10;28
并找到到该视频中
90 秒的位置。

*TC 00:05:18;19
该过程的设置与其他命令
的使用一样简单，我现在来

*TC 00:05:21;01
告诉您如何完成。

*TC 00:05:22;28
这里是我们做的一个小表单，
可以让用户输入视频中

*TC 00:05:27;16
要找到位置的
秒数。 我们在此处将调用

*TC 00:05:30;16
“seekTo”函数，
然后只不过是获取

*TC 00:05:33;10
文本框中的值。 这里就是
我们定义

*TC 00:05:36;13
该函数的过程，
“ytplayer.seekTo”

*TC 00:05:38;16
前面的部分与我们之前定义的过程很相似。 这里是我们输入的秒数，
以及当“seekTo”指向

*TC 00:05:42;16
的秒数超过已加载视频的秒数时，
是否要向服务器

*TC 00:05:46;01
发送新
的请求。 现在我们已

*TC 00:05:52;07
向播放器发出了命令，
现在来尝试

*TC 00:05:54;07
从中获取一些数据。 可以获取的
有用数据有：

*TC 00:05:58;10
播放器的当前时间以及
用户的播放进度。 例如，

*TC 00:06:01;24
如果我们点击播放，
您会看到 div 在此处

*TC 00:06:07;18
正在更新的当前时间。

*TC 00:06:10;09
为了连续显示
视频的当前时间，

*TC 00:06:12;09
我们要返回到

*TC 00:06:13;21
“onYouTubePlayerReady”。 我们将添加
一个 250 毫秒

*TC 00:06:18;21
的时间间隔。 因此，
每 250 毫秒

*TC 00:06:21;24
将调用一次
“updateCurrentTime”，也就是

*TC 00:06:23;18
调用一次
“ytplayer.getCurrentTime”并更新

*TC 00:06:26;15
HTML。 您也可以
获取其他数据，

*TC 00:06:30;06
例如视频的持续时间、
视频的 URL 以及

*TC 00:06:34;18
嵌入代码。  现在我们已经向播放器
发出了命令，

*TC 00:06:38;15
也从中获取了数据。 让我们来看看
如何订阅事件。

*TC 00:06:41;24
在本例中，我们将让播放器
告诉我们，它的状态已发生

*TC 00:06:46;06
更改。 就在这里，
您可以看到

*TC 00:06:49;09
播放器正处于状态 5，
也就是视频已在队列中。 如果点击播放，

*TC 00:06:53;21
播放器将开始缓冲，
然后进入状态 1，也就是播放。

*TC 00:06:58;03
如果点击暂停，它将进入
状态 2，以此类推。 现在我来告诉您

*TC 00:07:01;08
如何订阅事件。
如果要连续显示

*TC 00:07:04;20
播放器的当前状态，
需要返回到

*TC 00:07:07;26
“onYouTubePlayerReady”，
我们需要添加一个

*TC 00:07:10;20
事件侦听器
“ytplayer.addEventListener”。

*TC 00:07:15;20
我们准备订阅
“onStateChange”事件。

*TC 00:07:19;08
“onStateChange”事件
将要使用我们这里的

*TC 00:07:22;29
回调函数，并向其传递
当前状态。

*TC 00:07:28;11
而此处，我们只不过
是在更新 HTML。 现在，您了解了

*TC 00:07:33;11
JavaScript API 的基本知识。
如何发出命令、

*TC 00:07:36;02
如何获取数据以及
如何侦听事件。 Flash API

*TC 00:07:39;08
具有所有相同的调用
和相同的功能，

*TC 00:07:41;29
但是要将 YouTube 播放器 swf
加载到另一个 swf 有点

*TC 00:07:44;14
麻烦。 都是因为
播放器的 swf 结构

*TC 00:07:47;11
使用动作脚本的内置
MovieClipLoader

*TC 00:07:49;08
"无法为您提供
有关播放器

*TC 00:07:51;17
何时准备好的准确信息。

*TC 00:07:52;26
这里有一段代码，
可以将 YouTube 播放器

*TC 00:07:55;05
加载到 Flash 中。 我们在此
创建了新的“MovieClipLoader”。

*TC 00:08:01;13
然后再向其中加载 YouTube swf ，
并将其命名为“ytPlayer”。

*TC 00:08:07;10
此侦听器将每 250 毫秒
将检查一次播放器

*TC 00:08:12;07
是否已加载。 这是
不属于

*TC 00:08:16;13
JavaScript API
的附加调用。在动作脚本中应使用

*TC 00:08:20;07
“ytplayer.isPlayerLoaded”
来检查播放器

*TC 00:08:22;16
是否已加载。 如果已加载，我们就可以
继续进行我前面所讲的

*TC 00:08:27;25
使用 JavaScript API
可以做的所有事情，

*TC 00:08:30;01
例如调用 addEventListeners。

*TC 00:08:33;13
现在，您了解了所有有关
播放器 API 的知识后，

*TC 00:08:36;04
我们来讲讲 Chromeless 播放器。

*TC 00:08:37;25
就像我前面讲过的，
Chromeless 播放器只不过

*TC 00:08:40;07
是一个没有按钮的 swf 播放器。 您可以按照
自己的喜好

*TC 00:08:44;07
对其进行自定义。 例如，在此站点上，
他们使用的就是

*TC 00:08:48;07
Chromeless 播放器。 并且他们采用他们自己的按钮

*TC 00:08:51;04
并且使用播放器 API
来对其进行控制。

*TC 00:09:03;03
这里有个例子，
与前面讲的很类似，

*TC 00:09:05;12
只不过这里我们要使用的是
Chromeless 播放器。 您会注意到

*TC 00:09:07;24
按钮和进度条
都不见了。

*TC 00:09:10;09
唯一留下来的
只是右下角的

*TC 00:09:13;03
YouTube 徽标。 所使用的 JavaScript API 与
我们前面讲过的相同，

*TC 00:09:16;09
所以我可以使用
这些链接来控制它。

*TC 00:09:19;09
播放。 暂停。您已经差不多熟悉了
如何对此进行设置，

*TC 00:09:23;21
只不过 swf URL
有些不同。 所以现在让我向您

*TC 00:09:26;27
展示一下。 Chromeless 播放器
与

*TC 00:09:29;15
常规嵌入式播放器
的一个不同点在于

*TC 00:09:32;12
需要开发人员密钥
才能访问它。 因此，

*TC 00:09:35;03
如果您没有开发人员密钥，
可以去 code.google.com

*TC 00:09:38;12
注册一个。 注册是免费的，
并且非常简单。 您应该

*TC 00:09:43;18
很熟悉
这段代码。 在页面中

*TC 00:09:47;15
嵌入 Chromeless 播放器与
嵌入常规 YouTube 嵌入式播放器

*TC 00:09:49;21
唯一的不同点
就是

*TC 00:09:52;00
swf URL。 因此，您可以看到
此处 Chromeless 播放器 swf

*TC 00:09:55;24
的 URL 是
gdata.youtube.com/apiplayer。

*TC 00:10:00;27
这里是放置
开发人员密钥的位置。

*TC 00:10:03;06
而其他两个参数
则与前面相同。

*TC 00:10:09;06
现在您了解了如何
加载 Chromeless 播放器，

*TC 00:10:11;12
接下来让我讲一下
它与常规

*TC 00:10:13;15
JavaScript API 的几点区别。 您在这里可以看到，
这是您刚开始

*TC 00:10:16;24
加载 Chromeless swf 时，
该播放器的实际外观，

*TC 00:10:18;21
因为那个时候，它
还没有视频 ID。

*TC 00:10:21;03
而这里我们有一个可以调用
的加载视频 ID 的函数。

*TC 00:10:28;09
这样它就开始播放了。 这里还有一个
可以调用的

*TC 00:10:36;03
队列视频函数。 此函数只是用来
加载缩略图并

*TC 00:10:40;12
获取视频，但不会
进行播放。 要将新视频

*TC 00:10:44;27
加载到 Chromeless 播放器，
我们只需调用

*TC 00:10:47;06 
“ytplaer.loadVideoById”，
在其中输入“ID”，

*TC 00:10:51;21
还可以输入在播放器中
开始进行播放的时间位置。 同样，对于

*TC 00:10:56;06
“cueNewVideo”，
我们调用“ytplaer.cueVideoBGyId”，

*TC 00:11:00;29
输入“ID”，以及在
播放器发出播放命令后

*TC 00:11:04;29
我们希望其开始播放的
时间位置。 但愿这可以

*TC 00:11:09;29
帮助您
很好地了解这些新工具

*TC 00:11:12;05
以及它们的功能。 还有很多内容
这里没有提到，

*TC 00:11:14;05
因此
请务必

*TC 00:11:16;17
阅读 code.google.com 上的文档



