


*TC 00:00:01;14
我要告诉您
一些有关 

*TC 00:00:03;16
Google Apex 
语言 API 的内容。

*TC 00:00:06;17
我正在使用
一个小书签， 

*TC 00:00:11;00
现在我们可以
将它用来， 

*TC 00:00:12;18
比如说，查看
我的 Twitter。

*TC 00:00:14;03
我们看到过各种语言的
稀奇古怪的内容。

*TC 00:00:16;16
同样，我也看到过某些
法语内容， 

*TC 00:00:18;03
但是不知道
它们的意思。 

*TC 00:00:20;08
于是，我只要继续
并选中该内容。

*TC 00:00:21;25
单击“翻译”，这个
小书签就会检查该内容， 

*TC 00:00:23;26
并提供
实际的译文。

*TC 00:00:26;19
换一个例子。

*TC 00:00:29;18
相同的情况会在
皇家马德里出现， 

*TC 00:00:31;27
观看足球比赛时，如果想知道
Calderon 说了些什么。

*TC 00:00:36;22
继续。

*TC 00:00:38;13
点击这里。  它会检查内容
并告诉我们

*TC 00:00:41;02
共享快乐的时刻。

*TC 00:00:43;02
现在，当然， 

*TC 00:00:44;26
获取的译文
并不是

*TC 00:00:46;22
完美无缺。
要获得完美的译文的确很难。

*TC 00:00:50;20
但是，它可提供
充足的信息。

*TC 00:00:53;23
例如，
实际上

*TC 00:00:54;28
我正在使用
可使其内嵌的条形码，

*TC 00:00:58;24
而现在我通过
原型 Widget 来 

*TC 00:01:01;28
进行构建， 

*TC 00:01:02;26
因此，我只想
明白
 
*TC 00:01:04;01
人们谈论的
内容， 

*TC 00:01:05;20
回答和
内容 

*TC 00:01:06;24
实际位于
一个德国网站上。  同样，

*TC 00:01:08;22
我可以
进行检查

*TC 00:01:10;15
并获取
译文。

*TC 00:01:11;25 
它会提供
充足的信息， 

*TC 00:01:13;19
因此，即使实际上
译文并不完美， 

*TC 00:01:15;18
我也能在
一定程度上 

*TC 00:01:19;02
了解他们的谈话内容。

*TC 00:01:22;02
这个小书签只是
我快速创建的工具，

*TC 00:01:25;26
而这里的
大段代码 

*TC 00:01:29;00
将执行实际的
翻译过程。

*TC 00:01:30;04
我会进行检查，
加载语言 API，

*TC 00:01:34;21
并为其
提供一些  

*TC 00:01:37;06
我想要
传回的内容的信息。

*TC 00:01:39;10
首先，我会
进行检测， 

*TC 00:01:41;23
使系统
自动获知 

*TC 00:01:43;20
这可能是西班牙语，
这是意大利语， 

*TC 00:01:45;14
这是德语，
当我们 

*TC 00:01:48;16
真正获得
返回内容时， 

*TC 00:01:49;24
如果这个小书签
认为里面 

*TC 00:01:51;00
真的有些内容，
则会进行检查 

*TC 00:01:51;22
并
进行翻译。 

*TC 00:01:53;21
现在，它会开始尝试
并进行翻译， 

*TC 00:01:56;06
并且 

*TC 00:01:58;06
如果里面有些内容， 

*TC 00:01:59;11
它会进行检查
并为我进行翻译， 

*TC 00:02:01;20
否则，
它会告诉我

*TC 00:02:03;09
没有实际内容。

*TC 00:02:05;14
向下移到这里，
我真正要做的是 

*TC 00:02:08;05
执行
显示逻辑，

*TC 00:02:11;24
从而可以使用新的
原型 UI 窗口 

*TC 00:02:13;12
提升
该小窗口

*TC 00:02:16;21
以设置信息。

*TC 00:02:18;14
页眉、页脚和
内容，

*TC 00:02:19;21
如果由于某种原因，
例如具有小书签 

*TC 00:02:21;25
而
没有加载， 

*TC 00:02:24;00
有时您会
遇到冲突， 

*TC 00:02:25;13
会显示
这样的内容。 

*TC 00:02:27;15
别管它，然后使用简单的
方式解除锁定就可以了。

*TC 00:02:31;04
这是从小书签
向文件 

*TC 00:02:34;16
实际加载的
所有晦涩内容。

*TC 00:02:36;24
继续进行并实际加载
主要 JavaScript，

*TC 00:02:39;28
为这个小的 Widget
加载 CSS。

*TC 00:02:43;20
最后，
做好所有准备， 

*TC 00:02:46;05
这是加载 Google API
的实际初始调用。

*TC 00:02:50;14
请注意此处，
我们已添加了回调。

*TC 00:02:53;12
实际上，这是一种新方法，
几个月前才发明， 

*TC 00:02:57;06 
但是，这是将动态访问分组的
一种相当新颖的方式， 

*TC 00:03:00;28
过程
将继续 

*TC 00:03:03;14
并会调用
已加载的 API。

*TC 00:03:07;09
如果没有添加回调，
则只能手动进行调用。

*TC 00:03:09;28
这是
准备就绪的情况， 

*TC 00:03:11;24
它供 

*TC 00:03:13;15
准备开始工作的人
使用。

*TC 00:03:15;16
我们再次在此处
进行另一个回调，

*TC 00:03:18;11
我们已多少了解了这个
可以为我们提供所需内容的 

*TC 00:03:20;19
递归回调。

*TC 00:03:23;14
前几天，我发现一件
饶有趣味的事情， 

*TC 00:03:26;23
我注意到
Mibbit IRC 客户端 

*TC 00:03:30;10
完全基于 Web，
 
*TC 00:03:31;24
如果我们进入聊天室，希望进行交谈， 

*TC 00:03:36;08
便可以看到此新译文。

*TC 00:03:42;04
我们可以继续，
比如使用英语交谈， 

*TC 00:03:48;24
并将内容翻译为法语，
人们便可以就此展开对话。

*TC 00:03:53;15
就是这样。 

*TC 00:03:54;02
我们看到它自动将
内容翻译为法语。

*TC 00:03:56;27
它获取英语，
然后将其翻译为法语。 

*TC 00:04:00;14
并且可在我进入
非英语频道时为

*TC 00:04:05;12
我进行翻译，
我只需进入，并键入本国语言， 

*TC 00:04:08;09
它便可以
为我

01:04:10;16
翻译为英语。

*TC 00:04:13;06
我认为
这太酷了。

*TC 00:04:16;19
最后一点
令人称道的是， 

*TC 00:04:18;25
如果您深入研究该文档，
您会注意到， 

*TC 00:04:22;16
我们只是添加了此新的 Flash 和
其他非 Javascript 环境代码。

*TC 00:04:26;06
这
意味着， 

*TC 00:04:27;28
您可以在服务器端
执行检查和翻译。 

*TC 00:04:30;27
因此，您无需
全面学习 Ajax， 

*TC 00:04:34;06
您只需调用 Json，

*TC 00:04:37;14
并模仿此处的代码，
便可以执行翻译。

*TC 00:04:40;29
您可以执行翻译
或使用服务端技术 


*TC 00:04:44;08
或任何可理解 HTTP
和 JSON 的技术。

*TC 00:04:48;06
我希望大家利用
新的语言 API 

*TC 00:04:51;07
进行一些有趣的应用。





