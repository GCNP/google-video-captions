
*TC 00:12:19;27
Jeff Fisher です
これを見ているあなたは 

*TC 00:00:04;10
Google API を使用した
製品、さらに言えば 

*TC 00:00:06;07
Google Data プロトコルを
使用した API での作業に

*TC 00:00:07;28
興味をお持ちのデベロッパーの方
だと思います

*TC 00:00:11;27
Google Data プロトコルとは
何かという

*TC 00:00:14;25
ご質問にお答えする前に 

*TC 00:00:17;10
いくつかの予備知識を
ご紹介しておきましょう

*TC 00:00:19;03
あなたが既に
HTTP や XML に 

*TC 00:00:21;19
精通していると
仮定してお話しします

*TC 00:00:24;11
長年にわたりウェブサイトは
より多くのコンピュータで 
 
*TC 00:00:26;16
コンテンツを配布するための
代替方法を模索してきました 

*TC 00:00:28;19
これはユーザーにわかりやすい
方法である必要があります

*TC 00:00:30;19 
コンピュータはそれほど
利口ではないので 

*TC 00:00:32;23
人間が見るように情報を理解するには
若干の助けが必要です

*TC 00:00:36;12
ブログ サイトのような
簡単な例を見てみましょう

*TC 00:00:39;27
ブログ サイトでは新着記事が
ビッグ リストに掲載され 

*TC 00:00:42;23
その要約とタイトルの他 

*TC 00:00:45;11
記事の作成者や作成日時が
書かれています

*TC 00:00:48;03
これらの基本的な情報を
コンピュータでユーザーに

*TC 00:00:49;17 
わかりやすく表示するには
どんな方法があるでしょう？


*TC 00:00:52;17
この問題を解決するための
最初の試みが RSS でした

*TC 00:00:55;14
しかし、今日お話ししようとしているのは 

*TC 00:00:57;15
Atom シンジケーション フォーマット
についてです

*TC 00:00:59;18
Atom は XML ベースのアプローチで 

*TC 00:01:02;14
ウェブサイトのデータを記述し
コンピュータが情報を 

*TC 00:01:05;08
パースしやすくするものです

*TC 00:01:07;16
基本的には 1 つのフィード要素に
複数のエントリを格納し 

*TC 00:01:11;10
各エントリにはブログサイトの 
POST に関連付けられた
 

*TC 00:01:14;18 
メタデータがすべて含まれます

*TC 00:01:18;10
さあ、このブログのすべての
コンテンツを記述する 

*TC 00:01:21;02
コンパクトな方法が見つかりました

*TC 00:01:23;18
でも、ブログを読むだけでなく
編集するためのプログラムを 

*TC 00:01:26;18
作成するとしたらどうでしょう

*TC 00:01:28;22
このためには完全に新しい
機構を構築し 

*TC 00:01:31;21
先に話したフィード機構とは
根本的に違うものにするか 

*TC 00:01:34;18
前のものを再利用してみるか 

*TC 00:01:36;22
どちらかしかありません

*TC 00:01:38;09
XML で POST をうまく記述できる形式を 

*TC 00:01:40;07
再利用することにしましょう

*TC 00:01:44;06
サーバーにデータを送信するには
どうすればよいでしょう？

*TC 00:01:46;12
これらの POST は既に
HTTP で取り出されています 

*TC 00:01:49;08
ですから HTTP を使用して
コンテンツを編集および削除し 

*TC 00:01:52;22
新しいコンテンツを作成すればよいのです

*TC 00:01:54;26
既にあるものを再利用して
PUT、POST、DELETE など 

*TC 00:01:59;05
HTTP の他の動詞を利用できます

*TC 00:02:04;00
基本的にはフィードを編集するだけで 

*TC 00:02:07;28
ブログ コンテンツを管理する
完全な方法が得られます

*TC 00:02:10;12
では、ブログ エントリが
ない場合はどうでしょう？

*TC 00:02:14;01
ブログでない場合はどうでしょう？
カレンダーやスプレッドシートのような場合は 

*TC 00:02:16;14
どうやってデータを表示するでしょう？

*TC 00:02:20;23
そうですね 

*TC 00:02:22;06
新しい方法を試してみるか

*TC 00:02:24;14
Atom 形式をもう一度
使ってみるしかありません

*TC 00:02:27;28
もし Atom 形式を使用するならば

*TC 00:02:29;11
それは Google Data が
試みていることです

*TC 00:02:32;28 
では

*TC 00:02:35;05
Atom フィードの外観の  

*TC 00:02:37;13
一例をお見せしましょう

*TC 00:02:39;04
先ほど申しあげたように
Atom フィードは 

*TC 00:02:41;09
エントリを格納する XML です 

*TC 00:02:44;27
各フィードは各エントリの他
自身のメタデータを持ちます


*TC 00:02:49;20
また、各エントリは編集に
使用する情報の他に
 

*TC 00:02:53;08
サイトの他のすべてのエントリと
区別するための  

*TC 00:02:56;15
一意の識別子を持っています

*TC 00:03:01;10
そこで 

*TC 00:03:03;10
この識別子を 

*TC 00:03:06;16 
編集可能な形にしたものを 

*TC 00:03:08;02
Atom Publishing Protocol と呼びます  

*TC 00:03:09;25
Atom Publishing Protocol は
これらの各エントリを抽出して 

*TC 00:03:13;14
リソースに返します

*TC 00:03:15;15
これらのリソースは
従来のテキスト リソース、 

*TC 00:03:19;11
または画像ファイルや動画といった
メディア リソースです


*TC 00:03:24;04
リソースは、先にお話しした
HTTP リクエストを再利用し 

*TC 00:03:27;20
このデータを処理します 

*TC 00:03:30;26
次に HTTP レスポンス コードを使用して 

*TC 00:03:32;18
この処理が成功したか
エラーになったか 

*TC 00:03:35;04
認証を要求しているか
を通知します

*TC 00:03:37;16
これがいわゆる
RESTful プロトコルです 

*TC 00:03:40;00
これは RESTful な
セマンティックを使用して

*TC 00:03:44;24
リソースを変更し各リクエストを
他のリクエストから独立させます 

*TC 00:03:48;02
これは動作を聞くセッションのような
追加コンテキストを 

*TC 00:03:51;19
要求させないようにするのが目的です

*TC 00:03:55;17
AtomPub を使用して
ブログのエントリを作成する 

*TC 00:03:59;07
POST の例をお見せします

*TC 00:04:02;04
許可がいくつかと
その他のメタデータがありますが、 

*TC 00:04:04;07
基本的に POST しているものはすべて 

*TC 00:04:06;29
Atom フィードで取得するような 

*TC 00:04:08;24
Atom エントリです

*TC 00:04:10;21
このエントリを作成したデータを POST し 

*TC 00:04:14;15
返されたエントリを見ると 

*TC 00:04:17;00
編集リンクなど他のメンバーが追加されています 

*TC 00:04:19;10
これを変更した場合、
返されるエントリには 

*TC 00:04:22;04
何らかのバージョン文字列が
付加されます

*TC 00:04:23;14
ここでは「Etag」が付いています 

*TC 00:04:25;10
Etag は POST の更新を一意に識別します

*TC 00:04:29;13
201 レスポンス コードは
このコンテンツがサーバーで 

*TC 00:04:32;01
正常に作成されたことを
通知するものです

*TC 00:04:35;20
さて、Google Data とは何でしょう？どう使用するのでしょう？  

*TC 00:04:40;02
Google Data は Atom フィードを
見る方法を抽象化します

*TC 00:04:43;22
ブログの POST ではない何かを
Atom で表現したい場合 

*TC 00:04:45;15
何が必要でしょう？

*TC 00:04:47;20
カスタム XML の中にはエントリを
記述できるものがあります  

*TC 00:04:50;21
そこで Gdataの登場ですGdata の用途は 

*TC 00:04:50;21
API に付随する様々な
抽象概念を表現することです 

*TC 00:04:59;16
場所とは何か？時間とは何か？ 

*TC 00:05:01;21
コンタクトとは何か？
など新しい API を指定したり 

*TC 00:05:04;10
異なる製品で作業するたびに 

*TC 00:05:06;16
再考する必要のない物事のことです

*TC 00:05:08;22
この XML を使えば
Atom モデルに 

*TC 00:05:11;21
ぴったりフィットしますなぜなら、Atom では 

*TC 00:05:13;18
この XML.を拡張できるからです
他に何が必要でしょう？

*TC 00:05:17;02
Google Data の一部として
Atom Pub に追加された 

*TC 00:05:22;03
クエリ言語や認証が存在します
 

*TC 00:05:22;02Google データでは基本的に
Atom Pub が達成しようとすることと、

*TC 00:05:24;23
ユーザーが API で達成しようとすることの 

*TC 00:05:29;19
ギャップを埋めることができます

*TC 00:05:33;00
このため既にお話ししたように
Google サービスを利用したり 

*TC 00:05:34;21
Google アカウントに一致させるのに必要な 

*TC 00:05:36;19
何らかの形の認証が存在します
 

*TC 00:05:39;13
このフィードを使用すると
ユーザーがアクセスしようとする 

*TC 00:05:43;07
コンテンツの種類を
何らかの方法で制限できます 

*TC 00:05:47;19
また次に必要なのは
2 人の人が同時に同じ情報を 

*TC 00:05:51;02
追加しようとしたとき 

*TC 00:05:52;25
衝突を何らかの形で処理できる方法です

*TC 00:05:52;25
これらの共通要素は
我々が処理している情報が 

*TC 00:05:56;01
何かを表現するためのものです

*TC 00:05:58;03
他にも細かい事項が
いくつかありますが 

*TC 00:05:59;20 
これらはバッチ処理や
メディア サポートといった 

*TC 00:06:02;08
Atom 仕様の一部ではありません

*TC 00:06:05;01
Atom フィードや
Google Data フィードで 

*TC 00:06:07;17 
クエリを作成するとき

*TC 00:06:10;29
これは、基本的に URL です
 

*TC 00:06:14;05
この URL には、予想される
エントリの種類を通知する情報が
 

*TC 00:06:16;28
含まれています

*TC 00:06:17;28
まず 1 番目の URL は 

*TC 00:06:22;11
ドキュメント アカウントと
スプレッドシート アカウントの  

*TC 00:06:23;26
すべてのドキュメントを表しています

*TC 00:06:26;14
私たちの関心は 

*TC 00:06:28;19
スプレッドシートのみにあるかもしれません

*TC 00:06:29;25
2 番目の URL は最初のとよく似ていますが 

*TC 00:06:32;21
結果をスプレッドシート
ドキュメントのみに絞る 

*TC 00:06:35;18
カテゴリ クエリが使用されています

*TC 00:06:38;28
ドキュメント キーを含む
URL を渡すことで
 

*TC 00:06:40;20
最終的に
個々のエントリと 

*TC 00:06:43;17
これらに関連付けられた
情報を取り出せます


*TC 00:06:47;18
Google Data のメリットは  

*TC 00:06:49;02
Json や RSS といった
代替出力形式の API 全体で 

*TC 00:06:52;03
一貫した機能を備えていることです 

*TC 00:06:54;14
代替出力形式は
ソフトウェアが特定の形式を 

*TC 00:06:57;03
消費してしまう場合に使用されます

*TC 00:06:59;07
また Google Data には
認証モデルがあります 

*TC 00:07:01;25
これによってユーザーを
Google アカウントに認証し 

*TC 00:07:03;25
そのデータに安全に 

*TC 00:07:06;01
アクセスさせることができます

*TC 00:07:08;09
また、多くの言語に対応した
クライアント ライブラリが作成されています 

*TC 00:07:10;23
XML データと Atom データを

*TC 00:07:14;19 
使いやすいオブジェクト指向
モデルにパースするものです 

*TC 00:07:18;06
このモデルを使えば 

*TC 00:07:20;01
慣れた言語で直接操作できます

*TC 00:07:21;18
Atom はバッチ処理などには
未対応であると述べましたが 

*TC 00:07:24;13
複数のプロトコル カスタマイズ 

*TC 00:07:26;15
も提供されています

*TC 00:07:27;20
バッチ処理は複数の処理を
一度に行うとき使用されます
 

*TC 00:07:30;06
Google Data API の例を
お見せします 

*TC 00:07:33;26
Google カレンダーやスプレッドシート、
Picasa、YouTube 
 

*TC 00:07:36;02
お馴染みの Google 製品たちです

*TC 00:07:39;18
これらの製品の任意のデータに
同じセマンティックを 

*TC 00:07:42;21
使用してアクセスできます
これについてご説明します

*TC 00:07:47;04
たとえば 

*TC 00:07:49;10
プログラマーとして Google Calendar API を扱う 

*TC 00:07:51;28
簡単な方法を見てみましょう 

*TC 00:07:55;24
私が作成しようとする
リクエストを認証するための 

*TC 00:07:58;18
何らかの方法が必要です


*TC 00:08:00;26
2 つのオプションがあります  

*TC 00:08:02;15 
1 つは AuthSub、そして
もう 1 つは ClientLogin です

*TC 00:08:05;19
ClientLogin はデスクトップ
アプリケーション向けです 

*TC 00:08:09;09
ClientLogin ではユーザーは
認証情報を直接入力し 

*TC 00:08:13;10
次に Google のサーバーに
リクエストします 

*TC 00:08:15;09
一方の AuthSub では、まず
サードパーティーのウェブサイトが 

*TC 00:08:18;15
ユーザーを Google の
ログイン ページにリダイレクトし 

*TC 00:08:22;19
次に、元のウェブサイトに
リダイレクトできます 

*TC 00:08:27;09
これらは両方ともある種の
トークン プログラムを設定します 

*TC 00:08:29;25
ユーザーはリクエストと共にトークンを渡し、 

*TC 00:08:31;19
これを認証済みのリクエストに
することができます

*TC 00:08:35;07
まず誰かのカレンダーから
すべてのイベントを取り出す場合に 

*TC 00:08:37;06
すべきことを見てみましょう

*TC 00:08:39;12
すべきことはきわめて簡単です 

*TC 00:08:41;00
認証情報を運ぶ
フィードを引き出し 

*TC 00:08:43;14
これを認証済みの
リクエストにするだけです

*TC 00:08:47;05
返されたエントリで
200 OK を受け取ります 

*TC 00:08:49;16
これはリクエストが成功
したことを意味します

*TC 00:08:50;29
カレンダーの情報を含む
Atom フィードも返されます 

*TC 00:08:54;00
たとえば Mr. Test User のカレンダー 

*TC 00:08:57;16
彼は太平洋タイム ゾーンに
基づいていることがわかります

*TC 00:09:02;03
しかし、このフィードを見ると
カレンダーには今のところ 

*TC 00:09:05;20
何のイベントもありません
彼はとても孤独な人です

*TC 00:09:08;22
彼をランチに誘ってあげるべきかもしれません

*TC 00:09:10;14
では、彼のカレンダーに
イベントを作成する方法を 

*TC 00:09:13;20
ご説明しましょう 

*TC 00:09:14;24
これには HTTP の POST 
セマンティックを使用します

*TC 00:09:17;28
Atom エントリを作成し 

*TC 00:09:20;28
これをフィードに送信するだけです

*TC 00:09:23;16
ご覧のとおり
開始時刻を設定しました 

*TC 00:09:26;00
11:30、Google でのランチの時間です

*TC 00:09:28;21
この説明に関する情報を設定しました

*TC 00:09:31;03
このカテゴリ、この種類の
イベントを使用することで

*TC 00:09:35;12
これがカレンダー イベントを表す 

*TC 00:09:37;11
Atom エントリだとわかります
作成に成功すると 

*TC 00:09:40;28
201 Created レスポンスを受け取ります

*TC 00:09:42;16
これはカレンダー イベントの
追加に成功したことを示します

*TC 00:09:44;14
同じエントリが返されますが
違うのは 

*TC 00:09:47;12
Atom エントリのリンク内に
編集リンクがあり

*TC 00:09:51;23
ここから戻って変更を行えることです

*TC 00:09:54;04
赤い文字の長い ID があります 

*TC 00:09:58;11
これはこの特定のイベントを
明確に識別するものです 

*TC 00:10:00;26
青い字で書かれた
バージョン文字列は 

*TC 00:10:02;20
このイベントの更新を示します 

*TC 00:10:04;25
作成したばかりですから
当然これは 1 です

*TC 00:10:06;23
しかし、場所の設定を
忘れたことに 

*TC 00:10:10;14
お気づきですね

*TC 00:10:12;07
Mr. Test User がいつも
賢いとは限らないので 

*TC 00:10:14;13
彼に場所を教えてあげた
ほうがよいでしょう 

*TC 00:10:15;14
これを編集することにします

*TC 00:10:17;09
PUT を使用して 

*TC 00:10:19;18
作成したばかりのイベントを編集します

*TC 00:10:21;07
前のスライドで見たばかりの
編集リンクであることが 

*TC 00:10:23;17
おわかりですね

*TC 00:10:25;27
使用したばかりの
特定のリビジョン文字列で 

*TC 00:10:28;16
リンクを編集するための
リクエストを作成し 

*TC 00:10:30;29
次に、認証情報を渡そうとしています 

*TC 00:10:33;11
すべきことは同じ Atom エントリを
PUT するだけです 

*TC 00:10:36;24
違うのは Google の拠点が

*TC 00:10:39;01
カリフォルニア州マウンテンビューにある
ことを示すために

*TC 00:10:42;11
Where 要素を一番下に
追加したことです

*TC 00:10:45;10
リクエストが通過し
OK レスポンスを受け取りました

*TC 00:10:48;10
彼のカレンダーに最新の
イベント フォームが
 

*TC 00:10:51;21
あるのがわかります

*TC 00:10:53;07
我々と会うための情報が
すべて含まれているので 

*TC 00:10:55;17
彼はランチに来ることができます

*TC 00:10:57;16
でも、我々は本当に彼が
好きなわけではありません 

*TC 00:11:01;07
彼はどうもしゃべりすぎるんです 

*TC 00:11:02;11
誰も彼を誘わない理由は
この辺にあるのでしょう 

*TC 00:11:05;07
そこで、できれば彼が
これを見る前に 

*TC 00:11:07;25 
このイベントを削除したいと思います

*TC 00:11:09;12
削除するためにすべきことは  

*TC 00:11:13;00
編集 URL で削除するだけです 

*TC 00:11:15;02
更新されたフォームが返されました

*TC 00:11:17;15
返されたばかりのフォームの
編集 URL と言いました

*TC 00:11:20;12
イベントの編集に使用した
元の編集 URL を使用すると 
 

*TC 00:11:24;13
その編集内容はもう
機能していません 

*TC 00:11:26;29
一番下の青字の文字列も
バージョン ID も 

*TC 00:11:28;24 
今のものとは異なります

*TC 00:11:30;12
でもこれは正しい編集 URL
ですので 200 OK.が返されます

*TC 00:11:33;28
もし以前の URL を
使用したのであれば 

*TC 00:11:35;14
200 OK. ではなく 

*TC 00:11:38;01
409 Conflict エラーが
返されますこれは、削除しようとしたもの
よりも新しいバージョンの

*TC 00:11:40;15
イベントがサーバー上に 

*TC 00:11:43;03
存在することを意味します

*TC 00:11:44;18
特定の技術を通じた
Google Data の使用方法を 

*TC 00:11:48;15
15 分間の動画で
大急ぎでご説明しました 

*TC 00:11:51;13
Google Data の基本概念は
ご理解いただけましたか

 

*TC 00:11:54;12
HTTP を使用して XML で
動作させる方法はどうでしょう
 

*TC 00:11:58;09
ほとんどの人にとって
そうであるように  

*TC 00:12:01;07
この XML のすべてを自分で
構築する必要はありません
各言語に対応した高度な 

*TC 00:12:03;25
クライアントライブラリを是非
活用してください

*TC 00:12:07;22
http://code.google.com/intl/ja/apis/gdata/ では 

*TC 00:12:13;10
必要なクライアント ライブラリを
今すぐダウンロードできます 