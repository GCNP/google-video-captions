1
00:00:04,634 --> 00:00:06,067
Chris Pruett:
Okay, hello, everybody.

2
00:00:06,067 --> 00:00:08,434
Thank you for coming.
I'd like to get started.

3
00:00:08,434 --> 00:00:10,767
I'm supposed to reiterate
the point

4
00:00:10,767 --> 00:00:12,534
about not sitting
in this room.

5
00:00:12,534 --> 00:00:13,834
We have a Fire Marshal issue,

6
00:00:13,834 --> 00:00:15,367
so if you can please
find a seat.

7
00:00:15,367 --> 00:00:18,267
If there aren't any seats,
please stand.

8
00:00:18,267 --> 00:00:20,100
We don't want to get
shut down.

9
00:00:20,100 --> 00:00:21,801
The other point
that I wanted to make

10
00:00:21,801 --> 00:00:23,334
before we get started here

11
00:00:23,334 --> 00:00:24,868
is we're really looking
for feedback.

12
00:00:24,868 --> 00:00:27,300
There is a site that I've now
just hidden with my slides,

13
00:00:27,300 --> 00:00:29,400
but I'll put it up
at the very end.

14
00:00:29,400 --> 00:00:31,501
It's haveasec.com/io

15
00:00:31,501 --> 00:00:33,701
and it...we're, you know,
accumulating feedback

16
00:00:33,701 --> 00:00:35,434
about the talks here today.

17
00:00:35,434 --> 00:00:37,601
Please take a moment
to fill out your feedback

18
00:00:37,601 --> 00:00:39,434
about this talk and about all
the other talks you see here.

19
00:00:39,434 --> 00:00:41,033
Thank you.

20
00:00:41,033 --> 00:00:43,834
Okay, so this is Writing
Real-Time Games for Android.

21
00:00:43,834 --> 00:00:46,634
This is the opposite of
the Saving Battery Life talk.

22
00:00:46,634 --> 00:00:50,167
[laughter]
and the...

23
00:00:50,167 --> 00:00:54,000
I've a lot of stuff
to talk about today,

24
00:00:54,000 --> 00:00:56,467
and it's kind of a lot of
like random, unrelated--

25
00:00:56,467 --> 00:00:58,033
seemingly unrelated topics,

26
00:00:58,033 --> 00:01:00,434
so I'm gonna try to go through
them as logically as I can.

27
00:01:00,434 --> 00:01:02,400
Hopefully, it'll make sense.

28
00:01:02,400 --> 00:01:05,868
Did you see that awesome fade?
That slide totally faded in.

29
00:01:05,868 --> 00:01:07,501
I don't think I've ever
had like a...

30
00:01:07,501 --> 00:01:10,300
a thing that has like
a slide presentation

31
00:01:10,300 --> 00:01:12,100
that has fades
and moving stuff before,

32
00:01:12,100 --> 00:01:13,901
so this is like
a new experience for me.

33
00:01:13,901 --> 00:01:15,501
Right, so my name's Chris.

34
00:01:15,501 --> 00:01:17,701
I'm a Developer Advocate
for Android.

35
00:01:17,701 --> 00:01:19,501
I work in Japan.

36
00:01:19,501 --> 00:01:22,501
My job is to advocate
Android development,

37
00:01:22,501 --> 00:01:24,334
so please make something.

38
00:01:24,334 --> 00:01:26,300
I can help, maybe.

39
00:01:26,300 --> 00:01:28,701
If you're in Japan...
[speaking Japanese]

40
00:01:28,701 --> 00:01:31,300
Before that,
I was an engineer on Lively.

41
00:01:31,300 --> 00:01:33,701
I worked on animation code,
collision detection,

42
00:01:33,701 --> 00:01:35,467
service stuff,
all kinds of stuff.

43
00:01:35,467 --> 00:01:37,501
Lively was
our rather short-lived

44
00:01:37,501 --> 00:01:40,467
but very cool 3D online world.

45
00:01:40,467 --> 00:01:42,801
And before I started at Google
in 2007,

46
00:01:42,801 --> 00:01:44,801
I worked for about six years
in the game industry.

47
00:01:44,801 --> 00:01:48,033
Shipped about ten titles
for GBA, PlayStation Portable,

48
00:01:48,033 --> 00:01:50,100
PlayStation 2, Wii.

49
00:01:50,100 --> 00:01:52,434
So I have some experience
making games

50
00:01:52,434 --> 00:01:54,100
that are on other platforms.

51
00:01:54,100 --> 00:01:55,634
And today I want to talk about

52
00:01:55,634 --> 00:01:58,267
my experience making games
for Android.

53
00:01:58,267 --> 00:02:01,267
So, I mean, obviously
Android's a cool platform,

54
00:02:01,267 --> 00:02:02,834
and making games is awesome,

55
00:02:02,834 --> 00:02:05,934
so the two together have just
gotta be awesome squared, right?

56
00:02:05,934 --> 00:02:08,033
But it's really easy
to say that,

57
00:02:08,033 --> 00:02:10,267
and especially from,
you know,

58
00:02:10,267 --> 00:02:12,334
my perspective,
as like an employee of Google,

59
00:02:12,334 --> 00:02:14,400
it's really easy to say, hey,
make games for Android.

60
00:02:14,400 --> 00:02:15,934
It'll be great!

61
00:02:15,934 --> 00:02:18,601
Without ever knowing if it's,
really, you know, feasible.

62
00:02:18,601 --> 00:02:20,868
And I don't know how many
people in the audience

63
00:02:20,868 --> 00:02:22,601
are game developers here,

64
00:02:22,601 --> 00:02:24,934
but game developers will tell
you that games are weird, right?

65
00:02:24,934 --> 00:02:26,367
They don't really fit into

66
00:02:26,367 --> 00:02:28,434
regular application
development models very easily.

67
00:02:28,434 --> 00:02:30,400
They push your hardware in ways

68
00:02:30,400 --> 00:02:32,501
that your other applications
will not.

69
00:02:32,501 --> 00:02:35,601
So I wanted to...
in my position as an advocate,

70
00:02:35,601 --> 00:02:37,601
I wanted to be able
to advocate, you know,

71
00:02:37,601 --> 00:02:39,501
development of video games.

72
00:02:39,501 --> 00:02:41,133
But to do that with confidence,

73
00:02:41,133 --> 00:02:42,968
I need to be able to know that,
you know,

74
00:02:42,968 --> 00:02:44,701
the platform's actually
capable.

75
00:02:44,701 --> 00:02:46,200
So I made a game,

76
00:02:46,200 --> 00:02:49,234
and I'll talk a little bit about
the game today that I made.

77
00:02:49,234 --> 00:02:51,367
It's basically
a learning exercise,

78
00:02:51,367 --> 00:02:53,300
but I was also able
to make a fun game.

79
00:02:53,300 --> 00:02:55,200
I'll release it
when it's done,

80
00:02:55,200 --> 00:02:56,767
hopefully in a month or two.

81
00:02:56,767 --> 00:02:58,334
And I'll release all the source,

82
00:02:58,334 --> 00:03:00,367
and hopefully, people
can use that to, you know,

83
00:03:00,367 --> 00:03:02,234
build their own games
for Android.

84
00:03:02,234 --> 00:03:04,234
So what I'm gonna talk
to you about today

85
00:03:04,234 --> 00:03:05,834
is, you know,
who cares about games?

86
00:03:05,834 --> 00:03:07,701
Who cares about games
on Android?

87
00:03:07,701 --> 00:03:09,701
Why don't we just write like

88
00:03:09,701 --> 00:03:13,033
Awesome Friend Feed Connect
Facebook Apps

89
00:03:13,033 --> 00:03:14,400
or something, right?

90
00:03:14,400 --> 00:03:16,033
Like isn't that where
we're all going?

91
00:03:16,033 --> 00:03:17,834
But we'll talk about games
in a little bit.

92
00:03:17,834 --> 00:03:19,834
I'll talk a little bit about
game engine architecture.

93
00:03:19,834 --> 00:03:21,200
This isn't really
Android-specific,

94
00:03:21,200 --> 00:03:24,033
but I figure that
a lot of people in this room,

95
00:03:24,033 --> 00:03:25,634
and there's quite
a lot of you today,

96
00:03:25,634 --> 00:03:27,300
are interested in writing games

97
00:03:27,300 --> 00:03:28,834
but don't have a lot of
experience doing so.

98
00:03:28,834 --> 00:03:30,234
And like I said,

99
00:03:30,234 --> 00:03:32,033
game architecture
from a code point of view

100
00:03:32,033 --> 00:03:33,400
is very strange,

101
00:03:33,400 --> 00:03:35,834
so I just want to...
a couple of slides

102
00:03:35,834 --> 00:03:37,667
about how I go about,
you know,

103
00:03:37,667 --> 00:03:40,834
architecting games that I build
and how I, very specifically,

104
00:03:40,834 --> 00:03:42,601
which sort of architecture

105
00:03:42,601 --> 00:03:45,033
that I found
worked well on Android.

106
00:03:45,033 --> 00:03:47,334
And then talk a little bit
about writing Java code

107
00:03:47,334 --> 00:03:50,434
that's fast,
like really, actually fast...

108
00:03:50,434 --> 00:03:53,834
on Android, using
the Dalvik virtual machine.

109
00:03:53,834 --> 00:03:55,734
And then some rendering stuff,

110
00:03:55,734 --> 00:03:57,434
drawing efficiently
and then some tips and tricks.

111
00:03:57,434 --> 00:03:59,601
We'll get to that.

112
00:03:59,601 --> 00:04:01,934
So who cares about games
on mobile devices?

113
00:04:01,934 --> 00:04:03,801
Well, everybody,
apparently, right?

114
00:04:03,801 --> 00:04:06,767
iPhone where--App Store,

115
00:04:06,767 --> 00:04:09,300
like number one category of
download applications is games,

116
00:04:09,300 --> 00:04:12,100
and 79% of people
have downloaded a game once.

117
00:04:12,100 --> 00:04:14,133
You know, 100 million
Nintendo DSes in the world.

118
00:04:14,133 --> 00:04:18,133
200 million Game Boy Advances
and original Game Boys, right?

119
00:04:18,133 --> 00:04:20,267
And these are sold
to an audience

120
00:04:20,267 --> 00:04:23,300
that is not necessarily
just traditional gamers, right?

121
00:04:23,300 --> 00:04:25,100
I mean, you can find
a lot of people

122
00:04:25,100 --> 00:04:27,701
who have a Game Boy Advance or
a Nintendo DS in their pocket

123
00:04:27,701 --> 00:04:30,100
that, you know, would never
consider buying an Xbox 360

124
00:04:30,100 --> 00:04:32,100
or a PlayStation 3
or something like that.

125
00:04:32,100 --> 00:04:35,067
So there's a huge interest
in mobile games.

126
00:04:35,067 --> 00:04:37,267
And up until now,

127
00:04:37,267 --> 00:04:39,901
games on cell phones
have not been, you know,

128
00:04:39,901 --> 00:04:43,467
a really valuable proposition.

129
00:04:43,467 --> 00:04:45,901
And that's because before,
you know, say, the iPhone,

130
00:04:45,901 --> 00:04:48,868
cell phones were really not
very well designed for games,

131
00:04:48,868 --> 00:04:50,501
like the aspect ratio
was wrong,

132
00:04:50,501 --> 00:04:52,901
maybe headphones that,
for the longest time,

133
00:04:52,901 --> 00:04:54,701
couldn't read more than one,
you know, button input

134
00:04:54,701 --> 00:04:58,133
or only had like a 92-color
palette or some crap like that.

135
00:04:58,133 --> 00:05:01,100
So right now we're getting into
systems that are portable,

136
00:05:01,100 --> 00:05:04,734
they're high-powered,
they're able to host real games,

137
00:05:04,734 --> 00:05:07,968
and by real I mean like
modern game design kind of games

138
00:05:07,968 --> 00:05:10,133
that people want to make
and play today,

139
00:05:10,133 --> 00:05:12,934
not, you know, games
that were popular 30 years ago.

140
00:05:12,934 --> 00:05:16,968
And we also, I think,
are seeing a convergence

141
00:05:16,968 --> 00:05:18,567
of people who are interested
in, you know,

142
00:05:18,567 --> 00:05:20,968
having a cool phone
and also playing games,

143
00:05:20,968 --> 00:05:22,968
even if they're not
what we would consider

144
00:05:22,968 --> 00:05:25,968
the, you know, traditional
hardcore gamer market.

145
00:05:25,968 --> 00:05:28,767
I'm not gonna use the word
casual in this talk.

146
00:05:28,767 --> 00:05:33,133
So as I said before,
game tech is really specific.

147
00:05:33,133 --> 00:05:35,534
Another reason to do games
on Android

148
00:05:35,534 --> 00:05:38,567
and on any platform, I think,
is a stress test.

149
00:05:38,567 --> 00:05:40,334
If you can support games

150
00:05:40,334 --> 00:05:43,167
and you can support a lot of
different types of games,

151
00:05:43,167 --> 00:05:45,133
then I think that your API
is probably gonna be able

152
00:05:45,133 --> 00:05:47,934
to support all kinds of
other media applications.

153
00:05:50,133 --> 00:05:53,000
So why games on Android,
right?

154
00:05:53,000 --> 00:05:56,167
This is the one slide
I'm gonna spend on this.

155
00:05:56,167 --> 00:05:58,934
I have this really long,
involved rant,

156
00:05:58,934 --> 00:06:03,000
like invective-filled spew
that I would like to give to you

157
00:06:03,000 --> 00:06:05,000
about what's wrong
with the current game industry.

158
00:06:05,000 --> 00:06:06,501
But I'm not gonna do that.

159
00:06:06,501 --> 00:06:08,234
I'm just gonna give the little
30-second one slide version,

160
00:06:08,234 --> 00:06:09,901
and that's that basically

161
00:06:09,901 --> 00:06:12,501
the traditional game industry
has been built,

162
00:06:12,501 --> 00:06:14,601
especially in the last, say,
ten years,

163
00:06:14,601 --> 00:06:17,200
around marketing games towards
a very specific audience,

164
00:06:17,200 --> 00:06:18,667
and that audience
is an audience

165
00:06:18,667 --> 00:06:21,501
that really appreciates
advances in technology.

166
00:06:21,501 --> 00:06:24,567
It's also an audience that has
a lot of disposable income.

167
00:06:24,567 --> 00:06:27,968
So we've seen games
that sell well

168
00:06:27,968 --> 00:06:29,934
also being correlated
with games

169
00:06:29,934 --> 00:06:31,801
that have really nice
graphics tech

170
00:06:31,801 --> 00:06:34,634
or have really impressive
technical features.

171
00:06:34,634 --> 00:06:36,968
But what has happened,
because of that,

172
00:06:36,968 --> 00:06:38,567
is that that audience
has become

173
00:06:38,567 --> 00:06:40,000
the only viable audience

174
00:06:40,000 --> 00:06:42,400
in the minds
of a lot of game developers.

175
00:06:42,400 --> 00:06:44,667
And so we have, you know,
consoles now

176
00:06:44,667 --> 00:06:46,801
that are extremely
powerful computers

177
00:06:46,801 --> 00:06:49,634
and cost, you know,
200, 300, $400 when they launch,

178
00:06:49,634 --> 00:06:51,167
or more.

179
00:06:51,167 --> 00:06:53,968
And, you know, they do produce
fantastic games.

180
00:06:53,968 --> 00:06:55,934
I don't have anything bad
to say about those games.

181
00:06:55,934 --> 00:06:57,367
I love them myself too.

182
00:06:57,367 --> 00:06:59,234
But, you know, you could make
a PlayStation game

183
00:06:59,234 --> 00:07:01,100
for $5 million,
a PlayStation 2 game,

184
00:07:01,100 --> 00:07:02,267
$5 million.

185
00:07:02,267 --> 00:07:03,734
And, you know, you make
a PlayStation 3 game

186
00:07:03,734 --> 00:07:05,467
or an Xbox 360 game nowadays,

187
00:07:05,467 --> 00:07:08,100
and you're talking about, what,
20, 30, $40 million, right?

188
00:07:08,100 --> 00:07:10,100
I mean, we're very carefully--

189
00:07:10,100 --> 00:07:12,868
or very quickly
moving into a space

190
00:07:12,868 --> 00:07:17,501
where the platform
is becoming less and less able

191
00:07:17,501 --> 00:07:20,000
to support itself
on its one market base,

192
00:07:20,000 --> 00:07:22,000
which is sort of
the hardcore gamer, right?

193
00:07:22,000 --> 00:07:23,501
And we do have
alternatives, right?

194
00:07:23,501 --> 00:07:24,834
We've got
like Xbox Live Arcade

195
00:07:24,834 --> 00:07:27,868
and we have Nintendo Wii
and the DS and the iPhone

196
00:07:27,868 --> 00:07:30,467
showing that there are--
there is a market for games

197
00:07:30,467 --> 00:07:34,267
that are not about, you know,
muscle-bound like space marines

198
00:07:34,267 --> 00:07:36,667
who have amnesia
or a mysterious past, right?

199
00:07:36,667 --> 00:07:39,033
[laughter]
Like, um...

200
00:07:39,033 --> 00:07:40,767
if you are into muscle-bound
space marines

201
00:07:40,767 --> 00:07:42,334
with a mysterious past

202
00:07:42,334 --> 00:07:44,067
and you really like, you know,
guns that are also chainsaws,

203
00:07:44,067 --> 00:07:46,033
there's tons of games
for you, right?

204
00:07:46,033 --> 00:07:47,601
That's great.
You're the target audience.

205
00:07:47,601 --> 00:07:49,267
But there's a lot of other
people out there

206
00:07:49,267 --> 00:07:50,968
who, you know, might like
a game about something else.

207
00:07:50,968 --> 00:07:52,267
And the gaming industry

208
00:07:52,267 --> 00:07:53,901
doesn't really make games
for them anymore.

209
00:07:53,901 --> 00:07:55,634
They used to,
but now it's too expensive.

210
00:07:55,634 --> 00:07:57,667
I mean,
$50 million on a video game,

211
00:07:57,667 --> 00:07:59,334
you're gonna
not do anything new, right?

212
00:07:59,334 --> 00:08:00,834
You're gonna do whatever
sold last time

213
00:08:00,834 --> 00:08:02,367
because you spent $50 million

214
00:08:02,367 --> 00:08:04,501
and there's no way
you're gonna take any risk.

215
00:08:04,501 --> 00:08:07,067
So what we see is
a contraption of viable genres.

216
00:08:07,067 --> 00:08:08,701
And that's not good, right?

217
00:08:08,701 --> 00:08:10,033
I mean, games are awesome.

218
00:08:10,033 --> 00:08:11,501
They should be enjoyed
by everybody,

219
00:08:11,501 --> 00:08:13,000
and we should be able
to make whatever we want.

220
00:08:13,000 --> 00:08:14,434
Right now, the current
marketing conditions

221
00:08:14,434 --> 00:08:16,634
mean that 10% of, you know,
professional game developers

222
00:08:16,634 --> 00:08:19,367
make a profit and everybody
else goes out of business.

223
00:08:19,367 --> 00:08:21,601
So I think that--
and this is, like I said,

224
00:08:21,601 --> 00:08:25,000
the end of my little
side rant here about this.

225
00:08:25,000 --> 00:08:28,334
Mobile games in particular,
games that are being distributed

226
00:08:28,334 --> 00:08:30,033
over digital
distribution services

227
00:08:30,033 --> 00:08:32,467
like Android and like iPhone
and Xbox Live Arcade

228
00:08:32,467 --> 00:08:34,234
and those types of systems

229
00:08:34,234 --> 00:08:36,634
can solve this problem,
right?

230
00:08:36,634 --> 00:08:38,868
Because we can give developers

231
00:08:38,868 --> 00:08:42,467
a means to develop games
that are much, much lower risk

232
00:08:42,467 --> 00:08:43,901
to developers.

233
00:08:43,901 --> 00:08:46,167
And lower risk means more
interesting and diverse content

234
00:08:46,167 --> 00:08:48,467
because you can, you know,
you can take a risk.

235
00:08:48,467 --> 00:08:51,267
You can, you know, do something
that's experimental,

236
00:08:51,267 --> 00:08:53,100
do something that
you'd never be able to do

237
00:08:53,100 --> 00:08:54,868
in a $15 million game.

238
00:08:54,868 --> 00:08:57,033
So I think that Android's
particularly well-positioned

239
00:08:57,033 --> 00:08:58,367
from this point of view

240
00:08:58,367 --> 00:09:00,200
because we have
an audience of people

241
00:09:00,200 --> 00:09:01,701
who want a cool phone

242
00:09:01,701 --> 00:09:04,467
and also want to be able to play
games that do things on it,

243
00:09:04,467 --> 00:09:06,000
as we saw
in the previous slide.

244
00:09:06,000 --> 00:09:07,467
You know, portable games
are a big deal,

245
00:09:07,467 --> 00:09:08,801
and all of you are here,

246
00:09:08,801 --> 00:09:10,234
and they put me
in the really big room

247
00:09:10,234 --> 00:09:11,667
because clearly people
care about games, right?

248
00:09:11,667 --> 00:09:12,901
But on the other hand,

249
00:09:12,901 --> 00:09:14,634
we also have always-on
internet connection,

250
00:09:14,634 --> 00:09:16,267
and we have an internet-savvy
audience,

251
00:09:16,267 --> 00:09:17,767
and that's a combination
of things

252
00:09:17,767 --> 00:09:20,234
that we haven't actually seen
very much of in the past.

253
00:09:20,234 --> 00:09:21,834
iPhone's certainly
doing it too.

254
00:09:21,834 --> 00:09:24,601
I think that Android
can be right up there

255
00:09:24,601 --> 00:09:28,868
in this sort of sea change
of allowing you...

256
00:09:28,868 --> 00:09:35,000
or maybe...previously retired
gamers to come back.

257
00:09:35,000 --> 00:09:39,834
So, um...advance.

258
00:09:39,834 --> 00:09:43,634
So what kind of game
did I make,

259
00:09:43,634 --> 00:09:45,734
and why did I choose
to make that game?

260
00:09:45,734 --> 00:09:47,767
I had three goals
when I started out,

261
00:09:47,767 --> 00:09:49,067
and I have to tell you,

262
00:09:49,067 --> 00:09:51,234
I worked on Lively until
about October of last year.

263
00:09:51,234 --> 00:09:52,868
I moved to Japan
in October of last year,

264
00:09:52,868 --> 00:09:55,234
and I started working on this
in like very late in November.

265
00:09:55,234 --> 00:09:58,000
And this is a 20% project
for me.

266
00:09:58,000 --> 00:10:00,033
I work on it one day a week.

267
00:10:00,033 --> 00:10:02,200
So this is not
my full-time job.

268
00:10:02,200 --> 00:10:04,801
So I needed a game
that I could actually complete

269
00:10:04,801 --> 00:10:07,400
in a good amount of time
that I think I could make fun.

270
00:10:07,400 --> 00:10:09,234
I don't see any reason
to make a game

271
00:10:09,234 --> 00:10:11,000
if you're not gonna
make it fun, right?

272
00:10:11,000 --> 00:10:12,434
So my first,
my number one goal

273
00:10:12,434 --> 00:10:14,200
is to make a fun game

274
00:10:14,200 --> 00:10:15,801
in the sort of time
that I had

275
00:10:15,801 --> 00:10:17,801
and with the constraints
that I had.

276
00:10:17,801 --> 00:10:19,434
My number two goal,
as I mentioned,

277
00:10:19,434 --> 00:10:20,801
was to produce open source.

278
00:10:20,801 --> 00:10:23,801
I think that a lot of people
would make more games

279
00:10:23,801 --> 00:10:25,200
if they knew where to start,

280
00:10:25,200 --> 00:10:27,234
and if I can provide
some code or some framework

281
00:10:27,234 --> 00:10:29,234
or some documents
or some blog posts or something

282
00:10:29,234 --> 00:10:30,601
saying, like,
here's how I did it,

283
00:10:30,601 --> 00:10:32,801
you know, maybe that's
a jumping-off point.

284
00:10:32,801 --> 00:10:34,200
And even better,
down the road,

285
00:10:34,200 --> 00:10:36,000
if other people
could take that code

286
00:10:36,000 --> 00:10:37,400
and make new games
out of it

287
00:10:37,400 --> 00:10:39,000
and release their source
as well,

288
00:10:39,000 --> 00:10:40,334
then I think we could have

289
00:10:40,334 --> 00:10:42,234
a really pretty awesome
community.

290
00:10:42,234 --> 00:10:43,400
And then like,
as I said before,

291
00:10:43,400 --> 00:10:44,834
I want to stress
this platform.

292
00:10:44,834 --> 00:10:46,434
So I went for an orthodox
2D side-scroller.

293
00:10:46,434 --> 00:10:48,601
I'm assuming everybody
knows what that is,

294
00:10:48,601 --> 00:10:50,000
but just in case that's,
you know,

295
00:10:50,000 --> 00:10:52,000
Super Mario Brothers,
Sonic the Hedgehog,

296
00:10:52,000 --> 00:10:53,400
games like that.

297
00:10:53,400 --> 00:10:55,801
We have, basically,
multiple layers of images

298
00:10:55,801 --> 00:10:58,200
that are scrolling
at different speeds.

299
00:10:58,200 --> 00:11:00,200
It's called parallax scrolling.

300
00:11:00,200 --> 00:11:01,667
They're built out of tiles.

301
00:11:01,667 --> 00:11:04,300
We have little small images
that get put next to each other

302
00:11:04,300 --> 00:11:05,467
to build the world,

303
00:11:05,467 --> 00:11:07,267
so it's pretty traditional,

304
00:11:07,267 --> 00:11:10,467
very, very popular
in the mid, early '90s genre.

305
00:11:10,467 --> 00:11:12,501
Recently under-served,
I think.

306
00:11:12,501 --> 00:11:14,300
Nice thing about
this particular genre

307
00:11:14,300 --> 00:11:16,300
is I felt I could do it
in six months.

308
00:11:16,300 --> 00:11:17,667
I made a bunch of side-scrollers

309
00:11:17,667 --> 00:11:19,100
when I was working
on Game Boy Advance games.

310
00:11:19,100 --> 00:11:20,667
I have some experience
with them,

311
00:11:20,667 --> 00:11:22,267
and I quite enjoy
the genre myself.

312
00:11:22,267 --> 00:11:24,300
So it felt like something
that'd be fun to make,

313
00:11:24,300 --> 00:11:26,000
something that I thought
the people would enjoy

314
00:11:26,000 --> 00:11:27,367
and also the correct skill.

315
00:11:27,367 --> 00:11:28,868
It also pushed the right buttons
technically.

316
00:11:28,868 --> 00:11:31,868
I need to know how to do input
systems correctly and sound,

317
00:11:31,868 --> 00:11:33,234
and I need to be able to draw
with OpenGL or Canvas

318
00:11:33,234 --> 00:11:35,300
or whatever it is I'm gonna do

319
00:11:35,300 --> 00:11:38,100
that any game is gonna know--
have to know how to do,

320
00:11:38,100 --> 00:11:39,667
whether or not it's 2D or 3D.

321
00:11:39,667 --> 00:11:41,868
So then the stuff
I'm gonna talk about today

322
00:11:41,868 --> 00:11:43,300
is a little bit focused on 2D,

323
00:11:43,300 --> 00:11:44,868
'cause that's the kind of
game that I made.

324
00:11:44,868 --> 00:11:46,501
I suspect
that a lot of it will be

325
00:11:46,501 --> 00:11:48,667
completely applicable
to 3D games as well,

326
00:11:48,667 --> 00:11:51,467
especially the stuff about
using OpenGL quickly.

327
00:11:51,467 --> 00:11:54,667
So please don't
take this as being

328
00:11:54,667 --> 00:11:56,667
absolutely
just for 2D games.

329
00:11:56,667 --> 00:11:59,267
I want to talk about games
in a general purpose case,

330
00:11:59,267 --> 00:12:01,934
but I'm gonna use
the 2D game that I built.

331
00:12:01,934 --> 00:12:04,934
Okay, so let's talk about
some game engine architecture.

332
00:12:04,934 --> 00:12:06,567
Before that, I had a picture

333
00:12:06,567 --> 00:12:09,801
of a guy holding
a chainsaw gun here, but...

334
00:12:09,801 --> 00:12:11,300
legal made me take it out.

335
00:12:11,300 --> 00:12:12,767
[laughter]
Sorry.

336
00:12:12,767 --> 00:12:14,534
I just put the little text in
instead.

337
00:12:14,534 --> 00:12:16,968
I didn't really, you know,
own the license, I guess,

338
00:12:16,968 --> 00:12:18,267
so they were right.

339
00:12:18,267 --> 00:12:20,534
So I just wanna have
a really quick demo here.

340
00:12:20,534 --> 00:12:22,467
This is the game
that I'm working on.

341
00:12:22,467 --> 00:12:24,033
It's called Replica Island.

342
00:12:24,033 --> 00:12:26,033
It's getting close
to being done,

343
00:12:26,033 --> 00:12:27,701
and it's probably
about an Alpha.

344
00:12:27,701 --> 00:12:32,033
I have a very low-quality
video to show you.

345
00:12:32,033 --> 00:12:34,200
It's really hard
to shoot video

346
00:12:34,200 --> 00:12:36,300
on the Android device
that I have.

347
00:12:36,300 --> 00:12:37,901
So I apologize.

348
00:12:37,901 --> 00:12:39,634
And it's also quite difficult
to play a video game

349
00:12:39,634 --> 00:12:41,133
while shooting video
on an Android device

350
00:12:41,133 --> 00:12:43,834
and keep the screen
from getting screwed up.

351
00:12:43,834 --> 00:12:45,501
So I just have
a very short clip,

352
00:12:45,501 --> 00:12:46,934
and it's not really
representative

353
00:12:46,934 --> 00:12:48,501
of the entire game,

354
00:12:48,501 --> 00:12:51,434
but it'll give you an idea
of what I'm talking about,

355
00:12:51,434 --> 00:12:53,534
an idea of what the scope is
that I'm working on,

356
00:12:53,534 --> 00:12:55,234
and hopefully,
you'll think it looks cool too.

357
00:12:55,234 --> 00:12:57,701
Let's see if I can
make that play here.

358
00:12:57,701 --> 00:13:01,067
I think I have to click again.

359
00:13:01,067 --> 00:13:03,000
There we go.

360
00:13:03,000 --> 00:13:05,033
[laughter]

361
00:13:05,033 --> 00:13:06,634
So we got, you know...

362
00:13:06,634 --> 00:13:09,634
the Android robot,
and he's blowing some guys up

363
00:13:09,634 --> 00:13:11,200
and crushing some robots.

364
00:13:11,200 --> 00:13:13,167
And he's gonna take
this robot over here

365
00:13:13,167 --> 00:13:14,601
with this little red ball.

366
00:13:14,601 --> 00:13:16,334
Now he's possessed him.

367
00:13:18,567 --> 00:13:19,968
Now I can walk over here.

368
00:13:19,968 --> 00:13:21,567
This is a test level,

369
00:13:21,567 --> 00:13:23,801
so there's not really
anything to do in this level,

370
00:13:23,801 --> 00:13:26,734
but the robot can walk
over here and then self-destruct

371
00:13:26,734 --> 00:13:28,701
to go back to Android.

372
00:13:28,701 --> 00:13:31,667
So the goal is to collect
the three gems in each level.

373
00:13:31,667 --> 00:13:33,868
You can get coins
and things like that.

374
00:13:33,868 --> 00:13:35,601
There's some power-ups
to acquire

375
00:13:35,601 --> 00:13:37,000
and a lot of robots to crush,

376
00:13:37,000 --> 00:13:38,534
people to talk to,
things like that.

377
00:13:38,534 --> 00:13:41,334
And it's pretty traditional
side-scroll.

378
00:13:51,601 --> 00:13:54,534
[laughter]

379
00:13:56,400 --> 00:13:58,234
Oh, and here's a character
we can talk to.

380
00:13:58,234 --> 00:14:01,033
But I think we're just gonna
run by her instead.

381
00:14:01,033 --> 00:14:02,767
And you can kind of see,
you know,

382
00:14:02,767 --> 00:14:04,467
that there's a couple
of layers of background

383
00:14:04,467 --> 00:14:05,868
that are scrolling
at different speeds.

384
00:14:05,868 --> 00:14:07,267
That's the parallax
we talked about.

385
00:14:07,267 --> 00:14:08,667
We'll talk about that in a bit.

386
00:14:08,667 --> 00:14:10,167
Okay,
so there's the third gem.

387
00:14:10,167 --> 00:14:13,200
Hooray,
we completed the level.

388
00:14:13,200 --> 00:14:15,400
So that's Replica Island.

389
00:14:15,400 --> 00:14:22,100
[applause]

390
00:14:22,100 --> 00:14:24,067
Thanks. I hope you guys
enjoy it when it comes out.

391
00:14:24,067 --> 00:14:25,801
I'd like to hear
your feedback.

392
00:14:25,801 --> 00:14:29,567
So I want to talk a little bit
about how I build games

393
00:14:29,567 --> 00:14:30,868
just generally.

394
00:14:30,868 --> 00:14:33,267
And this sort of general
architecture

395
00:14:33,267 --> 00:14:37,467
is the architecture
I used to build Replica Island.

396
00:14:37,467 --> 00:14:39,467
It's also very similar
to the architecture

397
00:14:39,467 --> 00:14:41,467
that I used to build
a Spider-Man game

398
00:14:41,467 --> 00:14:43,067
on PlayStation 2.

399
00:14:43,067 --> 00:14:45,501
So I believe that it scales
pretty well.

400
00:14:45,501 --> 00:14:46,968
My approach is to--

401
00:14:46,968 --> 00:14:48,868
you know, we have like
the same kind of problems

402
00:14:48,868 --> 00:14:50,667
that we have to solve
in all games,

403
00:14:50,667 --> 00:14:52,067
and that's that you have
this sort of world

404
00:14:52,067 --> 00:14:53,634
full of objects
that need to be simulated

405
00:14:53,634 --> 00:14:54,868
with time, right?

406
00:14:54,868 --> 00:14:57,067
We got, you know,
the character moving around

407
00:14:57,067 --> 00:14:58,868
and there's other things,
and they're gonna collide,

408
00:14:58,868 --> 00:15:00,868
and they're gonna pick up stuff
and hit the ground and bounce.

409
00:15:00,868 --> 00:15:02,934
And then they're gonna have
velocities

410
00:15:02,934 --> 00:15:04,734
that need to be calculated

411
00:15:04,734 --> 00:15:06,734
and also animations
that need to be updated.

412
00:15:06,734 --> 00:15:09,534
These are all sort of
taking a time step,

413
00:15:09,534 --> 00:15:11,000
a simulation step,
and then updating

414
00:15:11,000 --> 00:15:12,734
and then figuring out
the results.

415
00:15:12,734 --> 00:15:14,934
That's sort of the basic
problem that most games face.

416
00:15:14,934 --> 00:15:16,734
So what I do is
I have a game graph.

417
00:15:16,734 --> 00:15:19,868
Basically we have a--
you can think of it as a tree.

418
00:15:19,868 --> 00:15:21,334
It's technically a graph,

419
00:15:21,334 --> 00:15:23,734
but you can think of it
as a tree for most cases,

420
00:15:23,734 --> 00:15:26,734
where the root node
is the main loop.

421
00:15:26,734 --> 00:15:29,534
And all the child nodes
under that root

422
00:15:29,534 --> 00:15:32,334
are things that get updated
every frame by the main loop.

423
00:15:32,334 --> 00:15:33,934
And those things
can have their children,

424
00:15:33,934 --> 00:15:35,734
and those things can be
updated every frame as well.

425
00:15:35,734 --> 00:15:37,133
And, you know, halfway
through the tree

426
00:15:37,133 --> 00:15:40,734
it's okay if we start adjusting
the way the things below

427
00:15:40,734 --> 00:15:42,734
in that particular sub-graph
get updated.

428
00:15:42,734 --> 00:15:44,734
For example,

429
00:15:44,734 --> 00:15:48,534
we could have a main loop
that has a game object child

430
00:15:48,534 --> 00:15:50,534
and a game object--
I'm sorry, manager as a child.

431
00:15:50,534 --> 00:15:52,334
And that manager
is gonna be the thing

432
00:15:52,334 --> 00:15:53,934
that manages all, say, like

433
00:15:53,934 --> 00:15:56,534
the sprites for bad guys
on the screen.

434
00:15:56,534 --> 00:15:58,334
And the thing about
bad guys on the screen

435
00:15:58,334 --> 00:16:00,334
is you don't really care
about what they're doing

436
00:16:00,334 --> 00:16:02,601
when they get far enough
away from the camera, right?

437
00:16:02,601 --> 00:16:04,601
In fact, you'd like to stop
processing them completely

438
00:16:04,601 --> 00:16:06,000
when they get far enough
away from the camera

439
00:16:06,000 --> 00:16:08,400
because, you know,
they're gonna slow stuff down.

440
00:16:08,400 --> 00:16:09,801
You got a huge level

441
00:16:09,801 --> 00:16:12,000
and there's like 500 guys
in there,

442
00:16:12,000 --> 00:16:13,801
but there's only three
that are actually close

443
00:16:13,801 --> 00:16:15,601
to actually being able
to interact with the player,

444
00:16:15,601 --> 00:16:17,801
and you only want to update
those three, right?

445
00:16:17,801 --> 00:16:20,601
So...in the game-graph context,

446
00:16:20,601 --> 00:16:25,234
the game manager node can sort
its children by visibility

447
00:16:25,234 --> 00:16:26,601
and only visit the children

448
00:16:26,601 --> 00:16:28,200
that it thinks are close
to being visible.

449
00:16:28,200 --> 00:16:31,400
That's kind of how that
concept fits into the graph.

450
00:16:31,400 --> 00:16:33,400
The game objects themselves

451
00:16:33,400 --> 00:16:36,200
which are, you know,
"an enemy" or "an explosion,"

452
00:16:36,200 --> 00:16:37,601
or "the player",

453
00:16:37,601 --> 00:16:39,601
those things are sub-graphs
of the game graph as well.

454
00:16:39,601 --> 00:16:42,200
You know, the sort of
initial implementation

455
00:16:42,200 --> 00:16:44,400
that I started out,
sort of the naive implementation

456
00:16:44,400 --> 00:16:47,000
when I first, you know,
joined the game industry

457
00:16:47,000 --> 00:16:50,734
was to take...you know,
make a game object class

458
00:16:50,734 --> 00:16:53,400
and then derive that to make
visible game object class

459
00:16:53,400 --> 00:16:55,000
and implement
the rendering part.

460
00:16:55,000 --> 00:16:57,334
And then derive that and make
a moving game object class

461
00:16:57,334 --> 00:16:59,200
and implement, you know,
velocity calculations.

462
00:16:59,200 --> 00:17:00,634
And then derive that
and make, you know,

463
00:17:00,634 --> 00:17:02,467
the rendering--
or, I'm sorry--

464
00:17:02,467 --> 00:17:04,467
the collision detection
game object

465
00:17:04,467 --> 00:17:06,567
and then derive that
and make the player out of that.

466
00:17:06,567 --> 00:17:08,267
And that actually works
for a while,

467
00:17:08,267 --> 00:17:10,267
and then eventually
you'll get into a case

468
00:17:10,267 --> 00:17:12,567
where you need, you know,
functionality from step A

469
00:17:12,567 --> 00:17:14,033
and functionality from step C,

470
00:17:14,033 --> 00:17:16,067
but you don't want
the class in the middle.

471
00:17:16,067 --> 00:17:17,501
And then you're sort of
screwed, right?

472
00:17:17,501 --> 00:17:20,701
So what I've been doing
for the last couple of years

473
00:17:20,701 --> 00:17:22,467
is sort of an aggregate
object model

474
00:17:22,467 --> 00:17:24,868
where I have a game object

475
00:17:24,868 --> 00:17:28,701
that is just
a list of other components.

476
00:17:28,701 --> 00:17:32,100
And each component is a single
piece of functionality.

477
00:17:32,100 --> 00:17:34,467
It updates
like a single update loop

478
00:17:34,467 --> 00:17:36,667
that says
I'm gonna do something

479
00:17:36,667 --> 00:17:39,200
like move the player
or render the player

480
00:17:39,200 --> 00:17:40,701
or take the input
from the device

481
00:17:40,701 --> 00:17:42,868
and then decide
how to adjust velocities.

482
00:17:42,868 --> 00:17:44,467
And it only does one thing.

483
00:17:44,467 --> 00:17:46,267
And the nice thing
about that approach is

484
00:17:46,267 --> 00:17:48,400
you only insert the components
into the object

485
00:17:48,400 --> 00:17:49,801
as they need it.

486
00:17:49,801 --> 00:17:51,467
So the player happens
to need to know

487
00:17:51,467 --> 00:17:52,868
how to read the input,

488
00:17:52,868 --> 00:17:54,467
but the enemies,
until they get possessed,

489
00:17:54,467 --> 00:17:56,200
don't need to actually
read the input ever,

490
00:17:56,200 --> 00:17:58,467
so they don't have to have
the input component.

491
00:17:58,467 --> 00:17:59,934
And if I decide
to possess an enemy

492
00:17:59,934 --> 00:18:01,667
and then suddenly
I want him to respond

493
00:18:01,667 --> 00:18:02,934
to the input component,

494
00:18:02,934 --> 00:18:04,534
I can just stick
a new component

495
00:18:04,534 --> 00:18:06,334
into his game object
at runtime,

496
00:18:06,334 --> 00:18:07,934
and it suddenly
starts working.

497
00:18:07,934 --> 00:18:10,300
So this is actually
an important point,

498
00:18:10,300 --> 00:18:12,367
and the reason
I'm sort of belaboring it

499
00:18:12,367 --> 00:18:15,100
is that also
it's very helpful

500
00:18:15,100 --> 00:18:17,534
because it helps you not
execute code

501
00:18:17,534 --> 00:18:19,534
that you don't need to do.

502
00:18:19,534 --> 00:18:21,000
And not doing extra work

503
00:18:21,000 --> 00:18:22,734
is gonna be a recurring
theme in this talk.

504
00:18:22,734 --> 00:18:24,501
Because optimization
is gonna become

505
00:18:24,501 --> 00:18:26,534
a big problem for us
when we start to write games.

506
00:18:26,534 --> 00:18:30,000
So, um...
let's go to the graph and see...

507
00:18:30,000 --> 00:18:32,634
This would be like
the top level view

508
00:18:32,634 --> 00:18:35,000
of like a very simple game graph
where we have a main loop

509
00:18:35,000 --> 00:18:36,434
and then we have some other
systems as children

510
00:18:36,434 --> 00:18:37,801
that get updated every frame.

511
00:18:37,801 --> 00:18:39,834
I just wanna give you an idea
of how I do this.

512
00:18:39,834 --> 00:18:41,267
This isn't the only way
to do this.

513
00:18:41,267 --> 00:18:42,934
This is just the way
I do it.

514
00:18:42,934 --> 00:18:44,767
So here's an example
with two objects

515
00:18:44,767 --> 00:18:46,701
and the game object's
just in there.

516
00:18:46,701 --> 00:18:48,067
Background object
was the thing

517
00:18:48,067 --> 00:18:49,467
that's drawing the backgrounds
and the layers,

518
00:18:49,467 --> 00:18:51,968
and then the player object
would be like the player itself.

519
00:18:51,968 --> 00:18:53,868
And you can kind of see how
they're made up of components

520
00:18:53,868 --> 00:18:56,000
where they sort of--they look
like children in the graph

521
00:18:56,000 --> 00:18:57,634
'cause that's what they are.

522
00:18:57,634 --> 00:19:00,601
So for the background,
there's like three layers.

523
00:19:00,601 --> 00:19:04,300
There's the, I think--
you saw it in the demo just now.

524
00:19:04,300 --> 00:19:06,000
There's like
the blue static background

525
00:19:06,000 --> 00:19:07,834
and then there was
a mid-ground layer

526
00:19:07,834 --> 00:19:09,434
and there's a foreground layer
as well.

527
00:19:09,434 --> 00:19:10,901
So for each of those layers,

528
00:19:10,901 --> 00:19:12,734
there's a scroller component
and a render component.

529
00:19:12,734 --> 00:19:13,901
Scroller component figures out

530
00:19:13,901 --> 00:19:15,367
how much it's supposed
to be scrolled,

531
00:19:15,367 --> 00:19:17,100
based on the current
camera position.

532
00:19:17,100 --> 00:19:18,734
And then the render
component says

533
00:19:18,734 --> 00:19:20,667
okay, now go render this
as frame.

534
00:19:20,667 --> 00:19:22,834
And then the player's made
of a bunch of stuff

535
00:19:22,834 --> 00:19:26,767
like physics and animation
and rendering and gravity,

536
00:19:26,767 --> 00:19:28,334
movement,
things like that.

537
00:19:28,334 --> 00:19:30,601
So this is actually
pretty close

538
00:19:30,601 --> 00:19:33,000
to the way that
Replica Island works right now.

539
00:19:33,000 --> 00:19:35,200
It's a little bit
of a simplification.

540
00:19:35,200 --> 00:19:39,501
But...you can see
that every frame,

541
00:19:39,501 --> 00:19:42,267
if we wanna update this game
and produce a new frame

542
00:19:42,267 --> 00:19:45,033
showing one more
simulation step of the game,

543
00:19:45,033 --> 00:19:47,000
all we have to do
is traverse this graph.

544
00:19:47,000 --> 00:19:49,167
And the order in which
we traverse these things,

545
00:19:49,167 --> 00:19:50,601
you know,
is sort of important,

546
00:19:50,601 --> 00:19:53,133
so just sort of say
breadth-first, left to right.

547
00:19:55,434 --> 00:19:57,501
Anyway, that's how I do it.
You can do it however you want.

548
00:19:57,501 --> 00:20:00,501
But I wanted to sort of...
just sort of say, you know,

549
00:20:00,501 --> 00:20:01,801
think about this kind of stuff

550
00:20:01,801 --> 00:20:03,367
when you start
writing video games

551
00:20:03,367 --> 00:20:04,667
because if you don't,

552
00:20:04,667 --> 00:20:06,167
it will come back
and bite you later.

553
00:20:06,167 --> 00:20:08,234
It bit me on production games

554
00:20:08,234 --> 00:20:10,667
that I did in my previous job
several times

555
00:20:10,667 --> 00:20:12,467
until I stopped doing it
that way

556
00:20:12,467 --> 00:20:14,267
and started doing it
this way.

557
00:20:14,267 --> 00:20:16,834
An important point about this
is that the graph takes time,

558
00:20:16,834 --> 00:20:20,901
like the delta from the previous
frame, as its input.

559
00:20:20,901 --> 00:20:23,334
Its output is a bunch of things
to draw for the render system,

560
00:20:23,334 --> 00:20:24,567
but its input is time.

561
00:20:24,567 --> 00:20:26,267
And the reason
that that's important

562
00:20:26,267 --> 00:20:28,267
is that any sort of
temporal logic

563
00:20:28,267 --> 00:20:30,167
that you're gonna do
in a game

564
00:20:30,167 --> 00:20:32,400
for a system like Android
needs to be scaled by time.

565
00:20:32,400 --> 00:20:34,601
So that means velocity
calculations,

566
00:20:34,601 --> 00:20:36,133
animation duration
calculations.

567
00:20:36,133 --> 00:20:39,100
Anything that's related to time
has to be scaled by real time

568
00:20:39,100 --> 00:20:40,767
and not like, say,
frame counts.

569
00:20:40,767 --> 00:20:42,267
It's really easy to say,

570
00:20:42,267 --> 00:20:44,167
"Oh, I'm gonna add five
to my velocity,

571
00:20:44,167 --> 00:20:46,467
or I'm gonna, you know,
wait for three frames

572
00:20:46,467 --> 00:20:48,000
and then play
this other animation."

573
00:20:48,000 --> 00:20:49,601
And the reason you don't
ever wanna do that

574
00:20:49,601 --> 00:20:51,667
is you don't know what
the duration of each frame is.

575
00:20:51,667 --> 00:20:53,734
You might think, well,
I'm running at 60 hertz,

576
00:20:53,734 --> 00:20:56,033
but Android
is a multiprocessing OS.

577
00:20:56,033 --> 00:20:58,033
You have no idea
what's going on in the CPU.

578
00:20:58,033 --> 00:20:59,767
You have to plan
for a variable framerate.

579
00:20:59,767 --> 00:21:02,734
And what happens when you don't
plan for a variable framerate

580
00:21:02,734 --> 00:21:04,300
is when your framerate's
really low,

581
00:21:04,300 --> 00:21:06,234
your game kind of falls apart
and slows way down.

582
00:21:06,234 --> 00:21:10,734
And you also start to experience
sort of temporal anomalies

583
00:21:10,734 --> 00:21:12,567
as the framerate fluctuate.

584
00:21:12,567 --> 00:21:14,400
Like your collision detection
will cease to work

585
00:21:14,400 --> 00:21:16,067
and things like that.

586
00:21:16,067 --> 00:21:18,234
So very important point
is that--

587
00:21:18,234 --> 00:21:20,968
and that a lot of people
would not maybe think about

588
00:21:20,968 --> 00:21:22,868
if they've not written
a game before--

589
00:21:22,868 --> 00:21:26,400
is to take time and do all
the calculations you need to do

590
00:21:26,400 --> 00:21:28,067
related to time with real-time.

591
00:21:28,067 --> 00:21:29,934
It's okay if you buy us
some time.

592
00:21:29,934 --> 00:21:31,701
You want to have
a slowed down <i>Matrix</i> effect?

593
00:21:31,701 --> 00:21:33,000
Sure. Go for it.

594
00:21:33,000 --> 00:21:34,934
Just don't use frame counts
as your...

595
00:21:34,934 --> 00:21:37,467
The other important point
is that

596
00:21:37,467 --> 00:21:39,167
the traversal
of the game graph

597
00:21:39,167 --> 00:21:40,868
doesn't actually draw anything
on the screen.

598
00:21:40,868 --> 00:21:42,400
It just produces
a list of things

599
00:21:42,400 --> 00:21:44,701
that we might draw
sometime in the future.

600
00:21:44,701 --> 00:21:46,534
And that's important
because of the way that--

601
00:21:46,534 --> 00:21:49,267
it's particularly important
in kind of all kinds of games,

602
00:21:49,267 --> 00:21:50,968
but for Android it's important

603
00:21:50,968 --> 00:21:53,133
because of the way
that rendering works.

604
00:21:53,133 --> 00:21:55,667
And this is true
whether or not

605
00:21:55,667 --> 00:21:58,501
you use OpenGL
or you use the Canvas system

606
00:21:58,501 --> 00:21:59,868
to be doing your drawing.

607
00:21:59,868 --> 00:22:02,734
You're gonna hit a point
at which the rendering threat

608
00:22:02,734 --> 00:22:04,734
is gonna block on hardware.

609
00:22:04,734 --> 00:22:06,334
And the reason
that that happens is that

610
00:22:06,334 --> 00:22:08,601
the hardware may not be done
drawing the previous frame.

611
00:22:08,601 --> 00:22:10,334
If the hardware's not done
drawing the previous frame,

612
00:22:10,334 --> 00:22:12,334
it's not gonna let you do
anything until it's finished.

613
00:22:12,334 --> 00:22:15,133
So if you're using OpenGL ES
and you call EGLSwapBuffers,

614
00:22:15,133 --> 00:22:16,734
that's gonna block,

615
00:22:16,734 --> 00:22:19,100
and it can block for like
16 milliseconds, right?

616
00:22:19,100 --> 00:22:20,534
And the CPU's not really
doing anything

617
00:22:20,534 --> 00:22:22,334
when that thread is blocked.

618
00:22:22,334 --> 00:22:26,467
But it means that your game
is not proceeding, right?

619
00:22:26,467 --> 00:22:29,567
So it's important to split
the game logic

620
00:22:29,567 --> 00:22:30,901
from the rendering layer.

621
00:22:30,901 --> 00:22:33,901
And the way that I did it
for Replica Island

622
00:22:33,901 --> 00:22:35,734
is I have three main threads.

623
00:22:35,734 --> 00:22:39,000
The main activity
is what I call the UI thread.

624
00:22:39,000 --> 00:22:40,734
It's just that when you make
an Android application,

625
00:22:40,734 --> 00:22:41,901
you make an activity

626
00:22:41,901 --> 00:22:43,667
and it comes up
and it produces your views,

627
00:22:43,667 --> 00:22:45,167
and then it can receive
input events.

628
00:22:45,167 --> 00:22:46,634
That's pretty much
all it does.

629
00:22:46,634 --> 00:22:48,534
That thread's mostly dormant.

630
00:22:48,534 --> 00:22:52,000
It bootstraps the game,
then it's pretty much done.

631
00:22:52,000 --> 00:22:54,167
Excuse me.

632
00:22:54,167 --> 00:22:56,701
I have a game thread which
is where the game graph lives.

633
00:22:56,701 --> 00:22:59,234
It gets updated, you know,
as often as I plan,

634
00:22:59,234 --> 00:23:02,100
and it produces
a list of drawable things

635
00:23:02,100 --> 00:23:03,968
to hand off
to the rendering thread.

636
00:23:03,968 --> 00:23:06,734
The rendering thread
is basically a SurfaceHolder.

637
00:23:06,734 --> 00:23:10,801
If you look at any of
the OpenGL examples

638
00:23:10,801 --> 00:23:12,801
that are shipped
with API demos--

639
00:23:12,801 --> 00:23:14,367
0r in a few minutes,

640
00:23:14,367 --> 00:23:16,067
I'll talk about
a sample that I wrote

641
00:23:16,067 --> 00:23:17,601
that you can look at as well--

642
00:23:17,601 --> 00:23:20,834
you'll see classes
like GL SurfaceView,

643
00:23:20,834 --> 00:23:24,567
which was part of API demos
in previous versions south,

644
00:23:24,567 --> 00:23:26,667
part of the API in Android 1.5,

645
00:23:26,667 --> 00:23:29,501
but it implements
a separate rendering thread

646
00:23:29,501 --> 00:23:31,000
separate from the main thread

647
00:23:31,000 --> 00:23:34,501
that just sits there and talks
to OpenGL as quickly as it can.

648
00:23:34,501 --> 00:23:36,334
So basically we have
this game thread

649
00:23:36,334 --> 00:23:38,968
producing a list of things
to draw, every frame,

650
00:23:38,968 --> 00:23:41,067
and then the rendering thread
consuming this every frame.

651
00:23:41,067 --> 00:23:42,968
And the nice thing
about this is that means

652
00:23:42,968 --> 00:23:45,000
that the framerates of these
two threads are decoupled.

653
00:23:45,000 --> 00:23:46,534
If the rendering thread
slows way down

654
00:23:46,534 --> 00:23:48,667
because I just threw
a hundred sprites at it,

655
00:23:48,667 --> 00:23:51,467
then as it's chugging on drawing
those hundred sprites,

656
00:23:51,467 --> 00:23:54,400
the game thread can continue
to run at 30 hertz

657
00:23:54,400 --> 00:23:56,701
or 60 hertz or whatever.

658
00:23:56,701 --> 00:24:00,234
If there's a...backlog
of the other direction,

659
00:24:00,234 --> 00:24:02,734
like the rendering thread
is starved,

660
00:24:02,734 --> 00:24:04,934
it'll just re-render the frame
that it had previously.

661
00:24:04,934 --> 00:24:06,534
Which is not ideal.

662
00:24:06,534 --> 00:24:08,067
you don't want to drop a frame
if you can ever avoid it.

663
00:24:08,067 --> 00:24:09,667
But, you know,
the screen doesn't go black.

664
00:24:09,667 --> 00:24:11,067
Nothing blows up.

665
00:24:11,067 --> 00:24:12,534
You can pause the game

666
00:24:12,534 --> 00:24:13,934
just by turning off
the game thread,

667
00:24:13,934 --> 00:24:15,400
and the rendering pedals
still continue

668
00:24:15,400 --> 00:24:18,067
to draw stuff on the screen,
whatever it had last.

669
00:24:18,067 --> 00:24:20,067
So I'm sure there are
other ways to do this.

670
00:24:20,067 --> 00:24:21,634
This is how I did it
on Replica Island,

671
00:24:21,634 --> 00:24:25,534
and it worked out pretty well.

672
00:24:25,534 --> 00:24:27,434
Okay. So let's talk
a little bit about

673
00:24:27,434 --> 00:24:29,167
writing Java code that's fast.

674
00:24:29,167 --> 00:24:32,000
Before I start talking
about this,

675
00:24:32,000 --> 00:24:34,701
I'm gonna offend all of the Java
engineers in the room,

676
00:24:34,701 --> 00:24:37,033
and I apologize for that.

677
00:24:37,033 --> 00:24:39,934
Also when I say Java,
I mean Java on Android

678
00:24:39,934 --> 00:24:41,467
running
the Dalvik virtual machine,

679
00:24:41,467 --> 00:24:43,400
not any other kind of Java.

680
00:24:43,400 --> 00:24:47,167
So please don't kill me.

681
00:24:47,167 --> 00:24:48,467
Basically,
I'm a C++ engineer.

682
00:24:48,467 --> 00:24:50,267
In fact, I never wrote
a line of Java

683
00:24:50,267 --> 00:24:51,667
in my entire life
before I started this game.

684
00:24:51,667 --> 00:24:52,868
So you should probably take

685
00:24:52,868 --> 00:24:54,467
everything I have to say
about Java applications

686
00:24:54,467 --> 00:24:56,133
with a kind of gigantic
grain of salt.

687
00:24:56,133 --> 00:24:58,667
But, you know, I also think
that most Java applications

688
00:24:58,667 --> 00:25:00,200
don't really need to do--

689
00:25:00,200 --> 00:25:02,968
be optimized to the sort of
level that I've been working.

690
00:25:02,968 --> 00:25:04,133
Because, you know,
for the most part,

691
00:25:04,133 --> 00:25:05,734
you have this language

692
00:25:05,734 --> 00:25:07,834
that provides a bunch of awesome
services for you.

693
00:25:07,834 --> 00:25:09,534
It provides an awesome
standard library,

694
00:25:09,534 --> 00:25:11,167
you've got memory referencing
and all this other stuff

695
00:25:11,167 --> 00:25:13,767
that you don't get in languages
like C++.

696
00:25:13,767 --> 00:25:15,534
and that's why writing
Java applications

697
00:25:15,534 --> 00:25:17,334
is easy and cool, right?

698
00:25:17,334 --> 00:25:19,767
And then maybe, you know,
I'm sure that everybody does

699
00:25:19,767 --> 00:25:21,534
sort of macro level
optimization of their algorithms

700
00:25:21,534 --> 00:25:25,934
and not doing an order
N-squared, you know, search

701
00:25:25,934 --> 00:25:29,133
when you can do a...and log N
search and stuff like that.

702
00:25:29,133 --> 00:25:30,767
But I'm gonna talk about
optimizations

703
00:25:30,767 --> 00:25:32,934
that are a little bit
more low level than that,

704
00:25:32,934 --> 00:25:35,334
and I think that might be
something that Java engineers

705
00:25:35,334 --> 00:25:37,601
don't generally
have to worry about.

706
00:25:37,601 --> 00:25:39,033
So hopefully this will be
some useful information

707
00:25:39,033 --> 00:25:40,534
here for you.

708
00:25:40,534 --> 00:25:42,200
There's one bullet point

709
00:25:42,200 --> 00:25:43,901
that says writing
real-time games

710
00:25:43,901 --> 00:25:45,300
in an exercise in finding
the perfect balance

711
00:25:45,300 --> 00:25:46,734
between flexibility
and performance.

712
00:25:46,734 --> 00:25:48,934
That's like a whole talk
in itself, that topic.

713
00:25:48,934 --> 00:25:51,133
But basically, what I want
to say real briefly is

714
00:25:51,133 --> 00:25:53,133
that at some point
you're going to have to choose

715
00:25:53,133 --> 00:25:54,534
between absolute performance

716
00:25:54,534 --> 00:25:56,334
and the ability
to make the game.

717
00:25:56,334 --> 00:25:58,300
And making games is about
duration, right?

718
00:25:58,300 --> 00:26:00,133
What you're gonna do,
if you sit down and make a game,

719
00:26:00,133 --> 00:26:01,868
is you're gonna have an idea,
and you're gonna make it,

720
00:26:01,868 --> 00:26:03,334
and you'll write it
and it'll be great,

721
00:26:03,334 --> 00:26:04,734
and then you'll give it
to somebody else,

722
00:26:04,734 --> 00:26:06,000
and they'll have no idea
how to do it

723
00:26:06,000 --> 00:26:07,400
or they will not find it
fun at all,

724
00:26:07,400 --> 00:26:08,901
and you realize
that there'll be

725
00:26:08,901 --> 00:26:10,801
all these usability problems
with it, so you'll iterate.

726
00:26:10,801 --> 00:26:11,868
And that's how games are made.

727
00:26:11,868 --> 00:26:13,167
And the games
that are really good

728
00:26:13,167 --> 00:26:14,467
are the ones that iterated
for a really long time.

729
00:26:14,467 --> 00:26:15,901
That's for the general rule.

730
00:26:15,901 --> 00:26:18,200
In order to iterate, you need
to have your code flexible.

731
00:26:18,200 --> 00:26:20,000
You need to be able to go in
and make changes

732
00:26:20,000 --> 00:26:21,601
without injecting bugs.

733
00:26:21,601 --> 00:26:23,601
You need to be able to swap out
one piece for another.

734
00:26:23,601 --> 00:26:25,434
You need to be able to write
tools that can generate data

735
00:26:25,434 --> 00:26:27,200
that the game will use.

736
00:26:27,200 --> 00:26:28,534
You need to have a bunch
of infrastructure.

737
00:26:28,534 --> 00:26:29,734
But infrastructure often comes

738
00:26:29,734 --> 00:26:31,200
with a cost of performance,
right?

739
00:26:31,200 --> 00:26:34,701
As soon as you have all your
games serialized in XML,

740
00:26:34,701 --> 00:26:36,200
then you have to actually
load the XML

741
00:26:36,200 --> 00:26:37,400
and walk through
all those objects,

742
00:26:37,400 --> 00:26:39,033
and that's not
really fast, right?

743
00:26:39,033 --> 00:26:42,234
So at some point,
you're gonna have to choose

744
00:26:42,234 --> 00:26:43,801
between flexibility
and performance.

745
00:26:43,801 --> 00:26:46,801
And basically, I always err
on the side of flexibility

746
00:26:46,801 --> 00:26:49,000
until the game
starts to slow down

747
00:26:49,000 --> 00:26:52,200
and then I have to go back
into performance tuning.

748
00:26:52,200 --> 00:26:55,601
And the reason is that...

749
00:26:55,601 --> 00:26:57,601
if you can't tune the game,
it's not gonna be fun.

750
00:26:57,601 --> 00:26:59,634
And there's no point in making
a game that's not fun.

751
00:26:59,634 --> 00:27:02,267
The corollary to that
is if you make a fun game

752
00:27:02,267 --> 00:27:03,868
that runs at one frame
per second,

753
00:27:03,868 --> 00:27:05,267
nobody's gonna play it.

754
00:27:05,267 --> 00:27:07,467
So it's not all one
or the other.

755
00:27:07,467 --> 00:27:08,868
But if you have to choose,

756
00:27:08,868 --> 00:27:11,267
my general advice
is to stay on the side

757
00:27:11,267 --> 00:27:13,868
of flexibility
and then, you know,

758
00:27:13,868 --> 00:27:15,467
go back to performance
when you need it.

759
00:27:15,467 --> 00:27:16,868
And to enable that,

760
00:27:16,868 --> 00:27:18,667
my approach here,
which has served me very well,

761
00:27:18,667 --> 00:27:21,467
it to just implement everything
as simple as possible

762
00:27:21,467 --> 00:27:22,868
for the first iteration

763
00:27:22,868 --> 00:27:25,467
but keep all the hooks there
for swapping things out.

764
00:27:25,467 --> 00:27:28,267
So it's okay to do that
order N-search the first time

765
00:27:28,267 --> 00:27:30,267
and when that order N-search
shows up on your profiler,

766
00:27:30,267 --> 00:27:31,667
then it might be
a pretty good time

767
00:27:31,667 --> 00:27:33,467
to go back and replace it
with something smarter.

768
00:27:33,467 --> 00:27:35,467
And when you wrote that
order N-search, hopefully

769
00:27:35,467 --> 00:27:37,467
you wrote it in such a way
that it's very easy to replace

770
00:27:37,467 --> 00:27:39,067
without the calling code
knowing anything about it.

771
00:27:39,067 --> 00:27:41,467
So then that leads me to
the last point about this topic,

772
00:27:41,467 --> 00:27:43,667
and that's profile early
and constantly.

773
00:27:43,667 --> 00:27:46,400
And we have a bunch of profiling
tools I'll touch on

774
00:27:46,400 --> 00:27:47,868
in a little bit later,

775
00:27:47,868 --> 00:27:49,467
but if you make like a thing

776
00:27:49,467 --> 00:27:51,367
that accumulates
the amount of time

777
00:27:51,367 --> 00:27:52,934
that you're spending per frame

778
00:27:52,934 --> 00:27:54,868
and spits it out
every three seconds to log,

779
00:27:54,868 --> 00:27:56,434
that's fantastic,
that's all you need.

780
00:27:56,434 --> 00:27:58,501
I mean, you can write that
in about an hour.

781
00:27:58,501 --> 00:27:59,868
And you can hook it up

782
00:27:59,868 --> 00:28:01,300
into all your game systems
really early,

783
00:28:01,300 --> 00:28:02,767
and you should do that,

784
00:28:02,767 --> 00:28:04,200
and you should have
a constant understanding

785
00:28:04,200 --> 00:28:05,834
of where you are
in your game framerate.

786
00:28:05,834 --> 00:28:08,267
Because if you want until
the last minute

787
00:28:08,267 --> 00:28:11,934
to go look at why your game's
not fast enough,

788
00:28:11,934 --> 00:28:13,334
then you're gonna be screwed.

789
00:28:13,334 --> 00:28:16,334
It may be the case that you
have just one, you know,

790
00:28:16,334 --> 00:28:19,534
system that's like, oh, a repeat
from 1 to 1,000.

791
00:28:19,534 --> 00:28:21,133
But it may also be the case

792
00:28:21,133 --> 00:28:23,133
that it's a death
from a thousand cuts, right,

793
00:28:23,133 --> 00:28:25,801
and that you don't have any one
system that you can optimize.

794
00:28:25,801 --> 00:28:27,234
And that's a really difficult
position to be in.

795
00:28:27,234 --> 00:28:30,934
So I said, you know, print
your profile out really early

796
00:28:30,934 --> 00:28:33,534
and keep looking at it
and keep understanding,

797
00:28:33,534 --> 00:28:35,100
you know, what you're doing.

798
00:28:35,100 --> 00:28:37,534
One comment that I would
like to make about this point

799
00:28:37,534 --> 00:28:39,100
before I go on is that

800
00:28:39,100 --> 00:28:40,534
don't print your profile
to the screen.

801
00:28:40,534 --> 00:28:43,400
I see a lot of developers
make this mistake.

802
00:28:43,400 --> 00:28:46,934
Because it's really easy,
especially in Java, I think,

803
00:28:46,934 --> 00:28:48,868
to mess up
printing to the screen

804
00:28:48,868 --> 00:28:51,667
in a way that will
actually affect the output.

805
00:28:51,667 --> 00:28:53,534
Like you can very easily hurt
your framerate

806
00:28:53,534 --> 00:28:55,067
by printing it on the screen.

807
00:28:55,067 --> 00:28:56,934
And also,
it's not information

808
00:28:56,934 --> 00:28:58,501
that you really need to see
all the time.

809
00:28:58,501 --> 00:29:01,601
A heartbeat every three seconds
is sufficient.

810
00:29:01,601 --> 00:29:05,133
I had one guy that
I worked with who, you know,

811
00:29:05,133 --> 00:29:07,601
had been working on improving
his framerate for his game

812
00:29:07,601 --> 00:29:10,000
and it had gotten progressively
faster and faster and faster.

813
00:29:10,000 --> 00:29:12,033
Then he hit a wall, and he
couldn't figure out what it was.

814
00:29:12,033 --> 00:29:13,634
And when he went
and looked at it,

815
00:29:13,634 --> 00:29:15,334
it turned out that
all the string calculations

816
00:29:15,334 --> 00:29:17,100
he was doing to print the frames
per second counter

817
00:29:17,100 --> 00:29:18,400
out on the screen were causing

818
00:29:18,400 --> 00:29:19,801
all these allocations
to be created

819
00:29:19,801 --> 00:29:21,601
which was causing the GC to fire
all the time,

820
00:29:21,601 --> 00:29:23,400
which was slowing him down.

821
00:29:23,400 --> 00:29:25,467
So just a point of caution.

822
00:29:25,467 --> 00:29:28,734
Okay, so let's talk about

823
00:29:28,734 --> 00:29:32,567
ways to use Java that are not
very flexible but are very fast.

824
00:29:32,567 --> 00:29:35,868
Given that I gave you
the flexibility talk.

825
00:29:35,868 --> 00:29:37,567
Don't every allocate memory.

826
00:29:37,567 --> 00:29:39,801
Okay, you can allocate memory,
but don't release it.

827
00:29:39,801 --> 00:29:41,601
That's a little extreme,
right,

828
00:29:41,601 --> 00:29:44,200
but what's gonna happen is
when you allocate memory,

829
00:29:44,200 --> 00:29:46,234
every time you allocate memory,
the GC gets a chance to run.

830
00:29:46,234 --> 00:29:49,601
And the GC right now,
under Android 1.5,

831
00:29:49,601 --> 00:29:51,801
can take 100 to 300
milliseconds,

832
00:29:51,801 --> 00:29:53,400
even if there's nothing
to actually do.

833
00:29:53,400 --> 00:29:55,200
And it has to walk
the whole object map, right?

834
00:29:55,200 --> 00:29:58,400
So 300 milliseconds
at a 60 hertz game--

835
00:29:58,400 --> 00:30:00,000
I mean, the user's
gonna feel that.

836
00:30:00,000 --> 00:30:01,501
That's 1/3 of a second,
right?

837
00:30:01,501 --> 00:30:05,000
The user's gonna know
that the game just stopped,

838
00:30:05,000 --> 00:30:07,434
and that's absolute death
for real-time games.

839
00:30:07,434 --> 00:30:10,334
If you remember the video
I just showed you,

840
00:30:10,334 --> 00:30:12,267
if the robot's
jumping over a pit,

841
00:30:12,267 --> 00:30:14,200
and the game stops,
and then he falls into the pit,

842
00:30:14,200 --> 00:30:15,601
you know,
that's a bad game, right?

843
00:30:15,601 --> 00:30:18,267
The player's gonna stop
at that point.

844
00:30:18,267 --> 00:30:20,767
So you don't ever
really want the GC to fire.

845
00:30:20,767 --> 00:30:23,501
So, okay, go a little bit
less extreme.

846
00:30:23,501 --> 00:30:24,901
Allocate all your memory
up front.

847
00:30:24,901 --> 00:30:26,100
Allocate all your memory

848
00:30:26,100 --> 00:30:27,634
at a time when gameplay
is not going on.

849
00:30:27,634 --> 00:30:29,501
And don't allocate
and don't release

850
00:30:29,501 --> 00:30:31,834
while gameplay
is actually running.

851
00:30:31,834 --> 00:30:33,601
And memory pools
are your friend.

852
00:30:33,601 --> 00:30:35,467
This is not actually
a very hard problem to solve,

853
00:30:35,467 --> 00:30:36,634
and non-Java languages,

854
00:30:36,634 --> 00:30:38,234
we have to solve this
all the time anyway,

855
00:30:38,234 --> 00:30:40,667
so just, you know,

856
00:30:40,667 --> 00:30:41,667
make your memory pools.

857
00:30:41,667 --> 00:30:42,968
Pre-allocate all your objects.

858
00:30:42,968 --> 00:30:45,000
Reuse them. Don't actually
release the references.

859
00:30:45,000 --> 00:30:48,000
And when you are at a point
that you know you can pause,

860
00:30:48,000 --> 00:30:49,734
like in between level load

861
00:30:49,734 --> 00:30:51,701
or at a pause screen

862
00:30:51,701 --> 00:30:52,901
or sometime when the game

863
00:30:52,901 --> 00:30:55,000
is not running a simulation
at full tilt,

864
00:30:55,000 --> 00:30:57,434
that's when you should
manually invoke the GC.

865
00:30:57,434 --> 00:30:58,534
There's a command.

866
00:30:58,534 --> 00:31:00,534
I think
it's System.getRunTime,

867
00:31:00,534 --> 00:31:02,133
invokeGC,
or something like that.

868
00:31:02,133 --> 00:31:03,234
And it will just--

869
00:31:03,234 --> 00:31:04,834
You can cause it to run
whenever you want.

870
00:31:04,834 --> 00:31:07,767
Otherwise you don't know
when the GCs gonna run, right?

871
00:31:07,767 --> 00:31:10,901
You can't really predict

872
00:31:10,901 --> 00:31:13,400
if it's based on whatever
parameters it uses

873
00:31:13,400 --> 00:31:14,801
and how often
you allocate memory.

874
00:31:14,801 --> 00:31:16,834
So beware of memory allocation.

875
00:31:16,834 --> 00:31:19,601
Also, we have this
pretty fantastic tool

876
00:31:19,601 --> 00:31:21,067
that ships
with the Android SDK

877
00:31:21,067 --> 00:31:22,267
called DDMS.

878
00:31:22,267 --> 00:31:24,267
And it'll allow you
to track allocations

879
00:31:24,267 --> 00:31:26,334
pretty much in real-time
as your application runs.

880
00:31:26,334 --> 00:31:28,200
So you can run your game

881
00:31:28,200 --> 00:31:29,801
on your device
and have it plugged in,

882
00:31:29,801 --> 00:31:31,000
and you can boot up DDMS.

883
00:31:31,000 --> 00:31:33,400
Actually,
there's a tab in Eclipse

884
00:31:33,400 --> 00:31:34,601
for it now even.

885
00:31:34,601 --> 00:31:36,734
And you can hit
"start tracking allocations,"

886
00:31:36,734 --> 00:31:37,934
and when you hit stop,

887
00:31:37,934 --> 00:31:39,501
you'll get a list
of all the allocations

888
00:31:39,501 --> 00:31:41,300
that occurred, you know,

889
00:31:41,300 --> 00:31:43,634
in between those two
buttons clicks, right?

890
00:31:43,634 --> 00:31:44,801
And what you're gonna find out

891
00:31:44,801 --> 00:31:46,868
is that Java
allocates memory all the time

892
00:31:46,868 --> 00:31:48,200
in places
you would never expect.

893
00:31:48,200 --> 00:31:49,300
At least I never expected.

894
00:31:49,300 --> 00:31:51,501
Like you ask for the array
for an enum,

895
00:31:51,501 --> 00:31:52,501
like enum.values(),

896
00:31:52,501 --> 00:31:53,734
yeah, that allocates memory.

897
00:31:53,734 --> 00:31:55,934
And you're gonna use
a HashMap or an Iterator

898
00:31:55,934 --> 00:31:57,133
or anything from collections,

899
00:31:57,133 --> 00:31:58,133
that allocates memory.

900
00:31:58,133 --> 00:32:00,601
Arrays.sort(), really fast,

901
00:32:00,601 --> 00:32:03,067
but duplicates
the data it works on.

902
00:32:03,067 --> 00:32:05,901
Any kind of, like,
system library function

903
00:32:05,901 --> 00:32:08,033
where they want to give you back
an immutable reference,

904
00:32:08,033 --> 00:32:10,300
but there's no such thing as
an immutable reference in Java,

905
00:32:10,300 --> 00:32:11,300
so they have to copy it.

906
00:32:11,300 --> 00:32:14,334
You can really easily find out

907
00:32:14,334 --> 00:32:15,834
that you made a lot of mistakes.

908
00:32:15,834 --> 00:32:18,100
I had to go back and rewrite
a bunch of my code

909
00:32:18,100 --> 00:32:19,634
after I started using DDMS,

910
00:32:19,634 --> 00:32:20,667
so DDMS is fantastic.

911
00:32:20,667 --> 00:32:21,801
What you can do,

912
00:32:21,801 --> 00:32:23,701
is you can reduce
all the allocations

913
00:32:23,701 --> 00:32:25,167
that you do yourself
in your own code.

914
00:32:25,167 --> 00:32:26,567
Some of the stuff
that Java is doing

915
00:32:26,567 --> 00:32:30,400
is not gonna be avoidable,
and that's okay.

916
00:32:30,400 --> 00:32:32,601
We don't actually need to
get rid of 100% of allocations.

917
00:32:32,601 --> 00:32:34,234
We just want to get rid of,
like, 90% of them.

918
00:32:34,234 --> 00:32:37,467
So having a little bit
of, like, say, StringCchCat,

919
00:32:37,467 --> 00:32:40,667
or, you know,
a little bit of stuff

920
00:32:40,667 --> 00:32:43,133
that you can't stop anyway,
is fine.

921
00:32:43,133 --> 00:32:45,901
It's fine. You don't have
to worry about it.

922
00:32:45,901 --> 00:32:48,534
What you want to do
is keep the GC

923
00:32:48,534 --> 00:32:49,767
from running frequently.

924
00:32:49,767 --> 00:32:51,501
You know, if it runs once
every five minutes,

925
00:32:51,501 --> 00:32:52,767
that's still much better

926
00:32:52,767 --> 00:32:54,334
than running randomly
every 30 seconds

927
00:32:54,334 --> 00:32:55,934
or something like that.

928
00:32:55,934 --> 00:32:58,868
So my approach is basically
to treat Java like C++.

929
00:32:58,868 --> 00:32:59,968
And this is the point

930
00:32:59,968 --> 00:33:01,667
where I said I was gonna
offend everybody.

931
00:33:01,667 --> 00:33:04,734
This is--completely flies in
the face of the language design,

932
00:33:04,734 --> 00:33:05,934
which I completely understand

933
00:33:05,934 --> 00:33:07,334
and I sympathize with.

934
00:33:07,334 --> 00:33:09,234
But if you want
to make a fun game,

935
00:33:09,234 --> 00:33:12,000
making a fun game and having it
actually be fun to play

936
00:33:12,000 --> 00:33:14,067
is more important, I think,
than language security.

937
00:33:14,067 --> 00:33:16,968
So you can't really
use collections.

938
00:33:16,968 --> 00:33:19,167
You can't really use enums.

939
00:33:19,167 --> 00:33:21,667
They're a really bad idea anyway
for a lot of different reasons.

940
00:33:21,667 --> 00:33:24,934
Like I said, Arrays.sort()
allocates memory.

941
00:33:24,934 --> 00:33:28,400
Stuff like
Reflection.getClassNames,

942
00:33:28,400 --> 00:33:29,400
things like that.

943
00:33:29,400 --> 00:33:30,701
You can use these functions,

944
00:33:30,701 --> 00:33:32,534
but not as the game
is running, and not--

945
00:33:32,534 --> 00:33:34,467
And it's not like you have
to completely ban them,

946
00:33:34,467 --> 00:33:36,000
but what you have
to understand is that

947
00:33:36,000 --> 00:33:37,234
every time you allocate memory

948
00:33:37,234 --> 00:33:39,267
or any time one of these
functions allocate memory,

949
00:33:39,267 --> 00:33:40,534
the GCs getting a chance,
right?

950
00:33:40,534 --> 00:33:42,834
So I just avoid them completely.

951
00:33:42,834 --> 00:33:45,300
And actually,
once you're cognizant

952
00:33:45,300 --> 00:33:47,234
of this particular problem,

953
00:33:47,234 --> 00:33:48,234
it's pretty easy to avoid.

954
00:33:48,234 --> 00:33:50,367
As far as I know,

955
00:33:50,367 --> 00:33:54,167
I've not gotten the GC to run
during <i>Replica Island</i> gameplay

956
00:33:54,167 --> 00:33:56,067
in about five months.

957
00:33:56,067 --> 00:33:59,067
So...I kind of have
these slides here

958
00:33:59,067 --> 00:34:03,133
just to let you know sort of
the extent of the problems

959
00:34:03,133 --> 00:34:04,567
that when you go
to write your games,

960
00:34:04,567 --> 00:34:06,133
you can, you know,
code appropriately.

961
00:34:06,133 --> 00:34:08,367
But absolutely use DDMS

962
00:34:08,367 --> 00:34:10,801
as your tool to find out where
allocations are coming from,

963
00:34:10,801 --> 00:34:12,601
'cause it's fantastic for that.

964
00:34:12,601 --> 00:34:15,834
Also, like I said,
I'm not really a Java engineer.

965
00:34:15,834 --> 00:34:17,367
I just sort of play one on TV,

966
00:34:17,367 --> 00:34:18,968
so I'm sure the rest of you

967
00:34:18,968 --> 00:34:20,934
could come up with much better
solutions than I did,

968
00:34:20,934 --> 00:34:22,601
you know,
like replacing implementations

969
00:34:22,601 --> 00:34:23,934
from the standard libraries

970
00:34:23,934 --> 00:34:25,767
with ones that don't
do allocations at runtime

971
00:34:25,767 --> 00:34:26,767
or come out of a pool,

972
00:34:26,767 --> 00:34:27,968
and those might, you know,

973
00:34:27,968 --> 00:34:29,534
allow you to go back
and use some of those

974
00:34:29,534 --> 00:34:30,801
standard library things

975
00:34:30,801 --> 00:34:32,801
without, you know,
having to rewrite everything.

976
00:34:32,801 --> 00:34:34,234
I don't actually
know how to do that.

977
00:34:34,234 --> 00:34:36,334
Okay, so step two,
don't call functions.

978
00:34:36,334 --> 00:34:39,167
Well, okay,
you can call functions,

979
00:34:39,167 --> 00:34:41,868
but you have to understand
that functions are not free.

980
00:34:41,868 --> 00:34:43,834
They kind of
don't teach you in school,

981
00:34:43,834 --> 00:34:45,434
at least when I went to school,

982
00:34:45,434 --> 00:34:47,501
they didn't really ever
touch on the fact

983
00:34:47,501 --> 00:34:49,300
that, you know,
functions might be expensive.

984
00:34:49,300 --> 00:34:51,200
And, in fact, in Java,
they're pretty expensive

985
00:34:51,200 --> 00:34:54,434
depending on what kind of
function you're calling, right?

986
00:34:54,434 --> 00:34:56,033
Don't ever call
interface functions.

987
00:34:56,033 --> 00:34:57,300
Those are really slow.

988
00:34:57,300 --> 00:34:59,100
Like, you call a function
through an interface,

989
00:34:59,100 --> 00:35:00,968
it has to go through an extra
lookup or something.

990
00:35:00,968 --> 00:35:02,167
It's 30% overhead.

991
00:35:02,167 --> 00:35:04,467
At least that's about
what I calculated.

992
00:35:04,467 --> 00:35:05,934
Your mileage may vary.

993
00:35:05,934 --> 00:35:08,968
But, like,
Accessors and Mutators,

994
00:35:08,968 --> 00:35:11,033
my "bestest" friends in C++,

995
00:35:11,033 --> 00:35:13,467
don't really belong
in your inner loop in Java,

996
00:35:13,467 --> 00:35:15,300
because you want to avoid--

997
00:35:15,300 --> 00:35:17,767
Any time you're in
a time-critical piece of code,

998
00:35:17,767 --> 00:35:19,033
you want to cut down

999
00:35:19,033 --> 00:35:20,801
the number of functions
that you're calling.

1000
00:35:20,801 --> 00:35:22,567
So if that means
calling something once

1001
00:35:22,567 --> 00:35:23,934
and assigning it
to a local variable

1002
00:35:23,934 --> 00:35:26,033
and then using that for
the remainder of the function,

1003
00:35:26,033 --> 00:35:27,334
that's great.

1004
00:35:27,334 --> 00:35:29,167
If you can assign that local
variable at Bootstrap

1005
00:35:29,167 --> 00:35:30,734
and then never
call that function again,

1006
00:35:30,734 --> 00:35:32,367
that's even better, right?

1007
00:35:32,367 --> 00:35:33,968
This is what I was talking about
when I said

1008
00:35:33,968 --> 00:35:35,033
"death by a thousand cuts."

1009
00:35:35,033 --> 00:35:37,601
If you architect your game
in a way

1010
00:35:37,601 --> 00:35:39,167
that you would architect
any other sort

1011
00:35:39,167 --> 00:35:41,000
of regular application,

1012
00:35:41,000 --> 00:35:42,767
you'd probably end up
with a lot of, you know,

1013
00:35:42,767 --> 00:35:44,033
general function calls.

1014
00:35:44,033 --> 00:35:45,934
"Get this, set this,
put this over here," right?

1015
00:35:45,934 --> 00:35:48,300
Yeah, you call those things a
couple 100,000 times per frame,

1016
00:35:48,300 --> 00:35:49,734
and that's the end
of your frame rate.

1017
00:35:49,734 --> 00:35:51,133
And then what
are you gonna do, right?

1018
00:35:51,133 --> 00:35:52,200
It's not very easy to go back

1019
00:35:52,200 --> 00:35:53,734
and change
all your functions, right?

1020
00:35:53,734 --> 00:35:55,534
So beware.

1021
00:35:55,534 --> 00:35:57,300
You also have to be
a little bit wary

1022
00:35:57,300 --> 00:35:58,834
of JNI functions.

1023
00:35:58,834 --> 00:36:01,968
JNI is the Java mechanism
for calling in to native code.

1024
00:36:01,968 --> 00:36:03,634
And, actually,
the nice thing about it is,

1025
00:36:03,634 --> 00:36:05,234
you know,
you're executing native code.

1026
00:36:05,234 --> 00:36:06,367
Native code's really fast.

1027
00:36:06,367 --> 00:36:08,267
So the contents of the function
are really fast,

1028
00:36:08,267 --> 00:36:10,200
but actually calling it
is actually kind of slow.

1029
00:36:10,200 --> 00:36:12,334
There's some pretty significant
overhead that occurs

1030
00:36:12,334 --> 00:36:14,934
when you actually need
to invoke a native function.

1031
00:36:14,934 --> 00:36:17,400
So in particular, like,
if you're calling

1032
00:36:17,400 --> 00:36:24,400
OpenGL stuff
from inside of Java,

1033
00:36:24,400 --> 00:36:26,234
you know,
all those gl.glXX() functions,

1034
00:36:26,234 --> 00:36:28,234
all of those
are JNI functions, right?

1035
00:36:28,234 --> 00:36:31,634
And it's really easy to get up
to several hundred OpenGL calls

1036
00:36:31,634 --> 00:36:33,534
a frame
for a pretty simple scene,

1037
00:36:33,534 --> 00:36:36,267
so this is something
you should be cognizant of.

1038
00:36:36,267 --> 00:36:39,434
And one thing that
you may end up having to do

1039
00:36:39,434 --> 00:36:41,000
that I've had to do
in a couple of cases,

1040
00:36:41,000 --> 00:36:43,834
which,
as a sort of programmer,

1041
00:36:43,834 --> 00:36:44,834
it really offends me,

1042
00:36:44,834 --> 00:36:47,367
is just make fields public.

1043
00:36:47,367 --> 00:36:51,033
And, like, that goes against
every, you know,

1044
00:36:51,033 --> 00:36:52,868
kind of grain in my body,

1045
00:36:52,868 --> 00:36:54,501
because I want to be
a defensive programmer,

1046
00:36:54,501 --> 00:36:56,267
and I don't want to,
you know, write code

1047
00:36:56,267 --> 00:36:58,934
that is susceptible
to easily ejectable bugs,

1048
00:36:58,934 --> 00:36:59,934
but on the other hand,

1049
00:36:59,934 --> 00:37:01,334
gameplay's king, right?

1050
00:37:01,334 --> 00:37:03,501
I mean, there's no point
in making a game

1051
00:37:03,501 --> 00:37:04,901
if it's not gonna be fun.

1052
00:37:04,901 --> 00:37:06,334
And if you find, you know,

1053
00:37:06,334 --> 00:37:07,868
you run your profiler
like I told you to

1054
00:37:07,868 --> 00:37:11,634
and you find out
that accessing this one field,

1055
00:37:11,634 --> 00:37:13,467
like, the position
of the player, for example,

1056
00:37:13,467 --> 00:37:16,033
is happening, you know,
100,000 times a frame,

1057
00:37:16,033 --> 00:37:17,400
then you could, you know,

1058
00:37:17,400 --> 00:37:19,467
you might be able to get
some pretty serious time back

1059
00:37:19,467 --> 00:37:22,767
by just making
that field public.

1060
00:37:22,767 --> 00:37:24,868
Here's a graph.

1061
00:37:24,868 --> 00:37:26,801
It's not a very scientific test,

1062
00:37:26,801 --> 00:37:28,367
so I didn't put any numbers
on the graph,

1063
00:37:28,367 --> 00:37:34,467
but I think that the sort of
relative costs

1064
00:37:34,467 --> 00:37:36,701
of these types of functions
is correct.

1065
00:37:36,701 --> 00:37:38,834
Basically, what this means
is you call a local function

1066
00:37:38,834 --> 00:37:40,501
or you call a function
from a derived class

1067
00:37:40,501 --> 00:37:42,033
or you call
a virtual function of Java,

1068
00:37:42,033 --> 00:37:43,200
it's all kind of the same cost.

1069
00:37:43,200 --> 00:37:44,534
You can an interface class,

1070
00:37:44,534 --> 00:37:48,801
you all of a sudden incur
this sort of 30% overhead.

1071
00:37:48,801 --> 00:37:52,200
And then you call through JNI
that overhead's even higher.

1072
00:37:52,200 --> 00:37:55,601
Just to illustrate
what I already said.

1073
00:37:55,601 --> 00:37:58,767
Okay, so a couple
of other tips about Java,

1074
00:37:58,767 --> 00:37:59,968
and then
I'll shut up about it.

1075
00:37:59,968 --> 00:38:02,601
Local variables
are your friend.

1076
00:38:02,601 --> 00:38:05,901
Even better than member
variables are local variables.

1077
00:38:05,901 --> 00:38:08,434
Use the final keyword
anywhere you can.

1078
00:38:08,434 --> 00:38:12,033
That's, like, you know,
I think CS 101,

1079
00:38:12,033 --> 00:38:13,567
but I thought
I'd reiterate it anyway.

1080
00:38:13,567 --> 00:38:16,968
You know, the G1 and other
Android hardware devices

1081
00:38:16,968 --> 00:38:18,701
at the moment don't have an FPU,

1082
00:38:18,701 --> 00:38:20,434
so if you do any kind
of float math,

1083
00:38:20,434 --> 00:38:22,167
that's gonna be done in software

1084
00:38:22,167 --> 00:38:23,534
by an FPU emulator.

1085
00:38:23,534 --> 00:38:25,901
So if you're really interested
in absolute performance,

1086
00:38:25,901 --> 00:38:28,033
you could consider
using fixed-point math.

1087
00:38:28,033 --> 00:38:29,501
I actually
don't care this much.

1088
00:38:29,501 --> 00:38:31,267
This is a point
where I chose flexibility

1089
00:38:31,267 --> 00:38:32,367
over absolute performance.

1090
00:38:32,367 --> 00:38:33,801
I just go ahead
and do the float math,

1091
00:38:33,801 --> 00:38:37,934
and it's really hard to gauge
how much that costs me

1092
00:38:37,934 --> 00:38:39,267
in terms of my frame rate,

1093
00:38:39,267 --> 00:38:42,701
but I don't believe it
to be very high.

1094
00:38:42,701 --> 00:38:48,734
Another point that's just
sort of unique to Android,

1095
00:38:48,734 --> 00:38:52,400
is that the regular
Java print mechanism,

1096
00:38:52,400 --> 00:38:53,934
System.out.print(), I guess,

1097
00:38:53,934 --> 00:38:55,033
is actually fairly slow,

1098
00:38:55,033 --> 00:38:57,033
and you should use Log.d()
or Log.e()

1099
00:38:57,033 --> 00:38:58,467
or one of these
other log equivalents

1100
00:38:58,467 --> 00:39:00,000
that we give you
to print out the log caps,

1101
00:39:00,000 --> 00:39:01,067
'cause it's way faster.

1102
00:39:01,067 --> 00:39:02,133
And that's another example

1103
00:39:02,133 --> 00:39:03,834
of where you could
unintentionally

1104
00:39:03,834 --> 00:39:05,000
sort of screw your frame rate,

1105
00:39:05,000 --> 00:39:06,501
but you're just trying
to produce logs.

1106
00:39:06,501 --> 00:39:07,601
And then use Traceview.

1107
00:39:07,601 --> 00:39:08,767
I mean,
this is the best part.

1108
00:39:08,767 --> 00:39:13,801
We ship a pretty
full-fledged profiler

1109
00:39:13,801 --> 00:39:15,234
with the Android SDK,

1110
00:39:15,234 --> 00:39:16,234
and, even better,

1111
00:39:16,234 --> 00:39:17,934
you can turn profiling
on and off

1112
00:39:17,934 --> 00:39:19,400
with just this little
function call,

1113
00:39:19,400 --> 00:39:21,100
so you can make,
like, a menu item

1114
00:39:21,100 --> 00:39:22,767
in your little menu
that pops up

1115
00:39:22,767 --> 00:39:25,100
that says, you know,
"toggle method profiling,"

1116
00:39:25,100 --> 00:39:27,234
and that will let you go
to some little spot in your game

1117
00:39:27,234 --> 00:39:28,667
that you notice
appears to be slow,

1118
00:39:28,667 --> 00:39:29,767
and turn on, you know,

1119
00:39:29,767 --> 00:39:31,133
method tracing
right at that spot,

1120
00:39:31,133 --> 00:39:32,701
and as soon as you
turn on method tracing,

1121
00:39:32,701 --> 00:39:34,400
your frame rate's
gonna fall through the floor

1122
00:39:34,400 --> 00:39:35,701
'cause that's really expensive.

1123
00:39:35,701 --> 00:39:37,968
But you can, you know,
generate this trace file

1124
00:39:37,968 --> 00:39:40,300
just in the area
that you're interested in,

1125
00:39:40,300 --> 00:39:42,000
and then go back
and look at it in Traceview.

1126
00:39:42,000 --> 00:39:44,033
And the numbers for, like,
how long it actually took

1127
00:39:44,033 --> 00:39:45,133
to call a function,

1128
00:39:45,133 --> 00:39:46,734
you should probably
just ignore those,

1129
00:39:46,734 --> 00:39:48,033
because method tracing goes on,

1130
00:39:48,033 --> 00:39:49,634
and the actual,
you know, seconds value

1131
00:39:49,634 --> 00:39:51,067
is probably not very useful,

1132
00:39:51,067 --> 00:39:53,801
but the number of times that
a particular function was called

1133
00:39:53,801 --> 00:39:55,767
and who its parents were
and who its children were,

1134
00:39:55,767 --> 00:39:57,601
and what percentage
of the total time they were,

1135
00:39:57,601 --> 00:39:58,767
that's super valuable.

1136
00:39:58,767 --> 00:40:00,367
And you get
these cool graphs too, right?

1137
00:40:00,367 --> 00:40:01,534
So absolutely use this tool.

1138
00:40:01,534 --> 00:40:04,601
The fact that we
actually have this tool

1139
00:40:04,601 --> 00:40:05,834
is really great.

1140
00:40:05,834 --> 00:40:07,634
Usually we write this stuff
ourselves, right?

1141
00:40:07,634 --> 00:40:09,734
Okay, so let's talk
about rendering.

1142
00:40:09,734 --> 00:40:13,767
This is a screenshot
from the sample that I wrote.

1143
00:40:13,767 --> 00:40:14,767
I alluded to it earlier.

1144
00:40:14,767 --> 00:40:15,834
Called SpriteMethodTest,

1145
00:40:15,834 --> 00:40:17,300
and what it does is,

1146
00:40:17,300 --> 00:40:19,334
it just tries to draw sprites 
on the screen really fast,

1147
00:40:19,334 --> 00:40:21,400
and it sort of animates them
and bounces them around.

1148
00:40:21,400 --> 00:40:23,968
And what it does is,

1149
00:40:23,968 --> 00:40:25,300
it lets you choose--

1150
00:40:25,300 --> 00:40:27,133
There's a bunch of different
rendering mechanisms

1151
00:40:27,133 --> 00:40:28,667
in Android that I'm
gonna cover in a minute,

1152
00:40:28,667 --> 00:40:30,067
and it lets you choose
each of them,

1153
00:40:30,067 --> 00:40:31,067
or a subset of them,

1154
00:40:31,067 --> 00:40:32,968
and run the same test

1155
00:40:32,968 --> 00:40:34,601
with pretty much
the same output,

1156
00:40:34,601 --> 00:40:39,901
and then compare the results
to see, you know, what's faster.

1157
00:40:39,901 --> 00:40:41,267
So this is what it looks like

1158
00:40:41,267 --> 00:40:43,734
if you run with a thousand
sprites on the screen

1159
00:40:43,734 --> 00:40:46,834
and you use the
draw_texture OpenGL extension,

1160
00:40:46,834 --> 00:40:48,234
which is available on the G1.

1161
00:40:48,234 --> 00:40:50,634
And with a thousand sprites
on the screen and a background,

1162
00:40:50,634 --> 00:40:54,133
it runs about
ten frames a second on the G1.

1163
00:40:54,133 --> 00:40:56,033
So, and, you know,

1164
00:40:56,033 --> 00:40:57,968
I'll put the URL up for that,

1165
00:40:57,968 --> 00:40:59,133
so you can test it yourself

1166
00:40:59,133 --> 00:41:01,934
on your new devices
at the end of this part.

1167
00:41:01,934 --> 00:41:06,267
So, basically, you have two
methods for drawing on Android.

1168
00:41:06,267 --> 00:41:07,334
The first is Canvas,

1169
00:41:07,334 --> 00:41:11,100
which is a very slick,
very easy to use

1170
00:41:11,100 --> 00:41:14,501
software-based
drawing mechanism,

1171
00:41:14,501 --> 00:41:16,601
which is how most
of the Android UI is drawn.

1172
00:41:16,601 --> 00:41:19,100
It's pretty easy
to get into Canvas

1173
00:41:19,100 --> 00:41:20,767
and start drawing lines
and making things

1174
00:41:20,767 --> 00:41:22,434
and, you know,
copying images in there

1175
00:41:22,434 --> 00:41:23,901
and rotating them.

1176
00:41:23,901 --> 00:41:26,234
And, actually, considering
that it's all done on the CPU,

1177
00:41:26,234 --> 00:41:27,367
it's pretty fast.

1178
00:41:27,367 --> 00:41:28,968
If you don't have a lot
of drawing to do,

1179
00:41:28,968 --> 00:41:31,501
like, for example,
in the SpriteMethodTest case,

1180
00:41:31,501 --> 00:41:33,033
under about ten sprites,

1181
00:41:33,033 --> 00:41:34,033
easily hit 60 hertz,

1182
00:41:34,033 --> 00:41:35,634
just using the software
implementation.

1183
00:41:35,634 --> 00:41:37,501
Don't have to worry
about OpenGL stuff.

1184
00:41:37,501 --> 00:41:40,968
And Canvas is by far the easier
of the two mechanisms to use.

1185
00:41:40,968 --> 00:41:42,634
It's easy to set up.
It's easy to tear down.

1186
00:41:42,634 --> 00:41:44,901
There's already, you know,
hooks for it in the main thread

1187
00:41:44,901 --> 00:41:46,634
if you don't want to make
a rendering thread,

1188
00:41:46,634 --> 00:41:48,167
although I recommend you do.

1189
00:41:48,167 --> 00:41:50,467
So, you know, if you're making
a <i>Bejeweled</i> clone...

1190
00:41:50,467 --> 00:41:51,667
I mean,
you can make something

1191
00:41:51,667 --> 00:41:53,334
more interesting
than <i>Bejeweled,</i> right?

1192
00:41:53,334 --> 00:41:54,834
But if you're making
a <i>Bejeweled</i> clone,

1193
00:41:54,834 --> 00:41:57,434
you know, Canvas will probably
meet all of your needs.

1194
00:41:57,434 --> 00:41:59,767
Then the other option
is OpenGL ES.

1195
00:41:59,767 --> 00:42:03,501
So, obviously, you can use
OpenGL for 3D drawing.

1196
00:42:03,501 --> 00:42:05,067
You can also use it
for 2D drawing.

1197
00:42:05,067 --> 00:42:07,968
It's accelerated on platforms
that have hardware acceleration,

1198
00:42:07,968 --> 00:42:09,934
like the G1.

1199
00:42:09,934 --> 00:42:11,767
And other platforms
in the future,

1200
00:42:11,767 --> 00:42:13,467
if they don't have
hardware acceleration,

1201
00:42:13,467 --> 00:42:15,133
like for example,
you run in the emulator,

1202
00:42:15,133 --> 00:42:16,968
then there's a software renderer

1203
00:42:16,968 --> 00:42:18,667
that is supplied.

1204
00:42:18,667 --> 00:42:22,367
It does scale to much more
complicated scenes than Canvas.

1205
00:42:22,367 --> 00:42:25,067
Because the actual
composition of the frame

1206
00:42:25,067 --> 00:42:26,400
is done in hardware,

1207
00:42:26,400 --> 00:42:28,334
and the hardware's pretty good
at doing that.

1208
00:42:28,334 --> 00:42:31,734
So you can get 1,000, you know,
sprites on the screen

1209
00:42:31,734 --> 00:42:33,534
at ten frames per second.

1210
00:42:33,534 --> 00:42:35,501
In OpenGL, there's no way
you could get

1211
00:42:35,501 --> 00:42:37,601
anywhere close to that speed
in Canvas.

1212
00:42:37,601 --> 00:42:40,033
It's considerably
more complicated to use.

1213
00:42:40,033 --> 00:42:42,167
There's some setup
and tear-down.

1214
00:42:42,167 --> 00:42:44,701
You've got to copy your textures
into video memory,

1215
00:42:44,701 --> 00:42:46,634
and you have to watch out
for the case

1216
00:42:46,634 --> 00:42:48,033
where your video memory
got trashed

1217
00:42:48,033 --> 00:42:50,000
because another application
came up in front of yours,

1218
00:42:50,000 --> 00:42:51,601
and then you have
to reload your textures.

1219
00:42:51,601 --> 00:42:52,934
Things like that.

1220
00:42:52,934 --> 00:42:54,601
There's a little bit
of work to do for the setup,

1221
00:42:54,601 --> 00:42:55,934
but then once
it's up and running,

1222
00:42:55,934 --> 00:42:57,934
the actual API to draw things

1223
00:42:57,934 --> 00:42:59,701
is not
that much more complicated.

1224
00:42:59,701 --> 00:43:02,300
So with OpenGL, we get actually
a lot of different ways

1225
00:43:02,300 --> 00:43:03,734
we can draw things in 2D.

1226
00:43:03,734 --> 00:43:06,634
The easy, most,
you know, basic case,

1227
00:43:06,634 --> 00:43:08,968
is just to make,
like, a 2D quad,

1228
00:43:08,968 --> 00:43:10,734
just a square of verts,

1229
00:43:10,734 --> 00:43:12,634
and, you know,
put a texture on it,

1230
00:43:12,634 --> 00:43:15,400
and just draw that using
an orthographic projection.

1231
00:43:15,400 --> 00:43:18,801
And that's like the OpenGL 1.0,

1232
00:43:18,801 --> 00:43:22,434
or, like, 101 type of approach
to drawing sprites.

1233
00:43:22,434 --> 00:43:23,968
And that works, you know.

1234
00:43:23,968 --> 00:43:27,100
The other way is we could
use vertex buffer objects,

1235
00:43:27,100 --> 00:43:29,100
which are basically
exactly the same thing,

1236
00:43:29,100 --> 00:43:30,501
except you take
that vertex buffer

1237
00:43:30,501 --> 00:43:32,267
that describes
your little square,

1238
00:43:32,267 --> 00:43:34,000
and you throw it
in video memory.

1239
00:43:34,000 --> 00:43:36,400
And then it doesn't have to get
sent down the bus every frame,

1240
00:43:36,400 --> 00:43:37,701
and the card
just has it in memory,

1241
00:43:37,701 --> 00:43:39,067
and it's already
in a native format,

1242
00:43:39,067 --> 00:43:40,501
and they can draw it faster.

1243
00:43:40,501 --> 00:43:43,834
Thing about VBOs is that
they're not actually supported

1244
00:43:43,834 --> 00:43:46,167
as part of OpenGL ES 1.0,

1245
00:43:46,167 --> 00:43:49,033
and Android guarantees
OpenGL ES 1.0,

1246
00:43:49,033 --> 00:43:50,534
but not anything above that.

1247
00:43:50,534 --> 00:43:53,234
So if you want to use
that type of extension,

1248
00:43:53,234 --> 00:43:54,501
it's available on the G1.

1249
00:43:54,501 --> 00:43:58,067
You need to check to see
if that extension exists,

1250
00:43:58,067 --> 00:43:59,968
because you could be running
on some future device

1251
00:43:59,968 --> 00:44:01,300
that we don't know about yet

1252
00:44:01,300 --> 00:44:03,767
that doesn't actually support
that extension.

1253
00:44:03,767 --> 00:44:06,267
And how do we choose
which extensions are supported?

1254
00:44:06,267 --> 00:44:07,701
Well, we don't.

1255
00:44:07,701 --> 00:44:10,167
The people who write the OpenGL
driver for the specific device

1256
00:44:10,167 --> 00:44:11,534
get to choose, right?

1257
00:44:11,534 --> 00:44:14,000
So the G1's, you know,
extensions that it supports,

1258
00:44:14,000 --> 00:44:16,000
it actually supports
quite a number of extensions,

1259
00:44:16,000 --> 00:44:19,300
are all based on what the driver
that Qualcomm supplied us--

1260
00:44:19,300 --> 00:44:20,834
supports, right?

1261
00:44:20,834 --> 00:44:23,133
So whenever you use
any kind of extension,

1262
00:44:23,133 --> 00:44:24,334
with VBOs--
I'm gonna talk about

1263
00:44:24,334 --> 00:44:26,300
draw_texture
in a minute as well--

1264
00:44:26,300 --> 00:44:28,067
you need to test the...

1265
00:44:28,067 --> 00:44:30,934
I think it's
glGetString(GL_EXTENSIONS).

1266
00:44:30,934 --> 00:44:32,467
I have that in the next slide,
I think.

1267
00:44:32,467 --> 00:44:34,200
That will just be a string

1268
00:44:34,200 --> 00:44:35,734
of the extensions
that are supported,

1269
00:44:35,734 --> 00:44:37,033
and you need to,
like, grep that,

1270
00:44:37,033 --> 00:44:38,467
to make sure
that the functionality

1271
00:44:38,467 --> 00:44:40,300
you want to use
is actually available

1272
00:44:40,300 --> 00:44:41,534
in the device you're running on.

1273
00:44:41,534 --> 00:44:43,200
If you don't do that,
and you run on a device

1274
00:44:43,200 --> 00:44:44,367
that doesn't have that thing,

1275
00:44:44,367 --> 00:44:46,267
your game's gonna crash, right?

1276
00:44:46,267 --> 00:44:49,467
Fortunately, for something
like VBOs and quads,

1277
00:44:49,467 --> 00:44:51,534
the actual interface
is so similar

1278
00:44:51,534 --> 00:44:53,200
that it's pretty easy
to write your code

1279
00:44:53,200 --> 00:44:55,567
such that you can fall back
on the 1.0 implementation,

1280
00:44:55,567 --> 00:44:57,367
if the, you know,
1.1 one doesn't exist.

1281
00:44:57,367 --> 00:44:59,167
And then there's
the draw_texture extension,

1282
00:44:59,167 --> 00:45:01,734
which is another extension that
you have to check existence for.

1283
00:45:01,734 --> 00:45:02,934
And what it does is,

1284
00:45:02,934 --> 00:45:04,767
it sort of just blits textures
to the screen.

1285
00:45:04,767 --> 00:45:06,000
It's very fast.

1286
00:45:06,000 --> 00:45:07,968
The disadvantage
to the draw_texture extension

1287
00:45:07,968 --> 00:45:09,868
is it can't do rotation,
I think.

1288
00:45:09,868 --> 00:45:12,234
So here's a graph
of the relative speeds

1289
00:45:12,234 --> 00:45:13,767
of these drawing mechanisms.

1290
00:45:13,767 --> 00:45:15,567
This is basically
straight output

1291
00:45:15,567 --> 00:45:17,534
from that SpriteMethodTest.

1292
00:45:17,534 --> 00:45:20,467
At ten, what we have
on the left side

1293
00:45:20,467 --> 00:45:22,334
is the number of Sprites
that it's drawing,

1294
00:45:22,334 --> 00:45:23,767
and on the bottom axis

1295
00:45:23,767 --> 00:45:25,701
is the number
of milliseconds it took.

1296
00:45:25,701 --> 00:45:26,934
And keep in mind

1297
00:45:26,934 --> 00:45:29,701
that 16 milliseconds
is where you have to be

1298
00:45:29,701 --> 00:45:31,300
in order to get 60 hertz.

1299
00:45:31,300 --> 00:45:33,634
32 milliseconds is where you
need to be to give you 30 hertz.

1300
00:45:33,634 --> 00:45:35,767
So anything slower
than 32 milliseconds

1301
00:45:35,767 --> 00:45:37,767
is probably gonna be an
unplayable real-time game,

1302
00:45:37,767 --> 00:45:41,634
unless you're making a game that
isn't really that real-time.

1303
00:45:41,634 --> 00:45:43,834
So, you know,
faster is better, right?

1304
00:45:43,834 --> 00:45:44,968
So if we look at ten sprites,

1305
00:45:44,968 --> 00:45:46,400
all of them
are pretty much the same.

1306
00:45:46,400 --> 00:45:47,834
And the reason
they're all the same

1307
00:45:47,834 --> 00:45:49,200
is that,
like I said before,

1308
00:45:49,200 --> 00:45:52,300
the hardware's gonna block
on the page flip, right?

1309
00:45:52,300 --> 00:45:54,434
On the previous frame
completing drawing.

1310
00:45:54,434 --> 00:45:56,000
So with ten sprites,

1311
00:45:56,000 --> 00:45:57,434
all of these methods,

1312
00:45:57,434 --> 00:46:00,801
draw_texture and VBOs
and the Basic Quads and Canvas,

1313
00:46:00,801 --> 00:46:02,501
can actually generate the frame

1314
00:46:02,501 --> 00:46:04,133
in probably less than
60 milliseconds,

1315
00:46:04,133 --> 00:46:05,501
and then the remainder
of the time

1316
00:46:05,501 --> 00:46:07,534
it comes from
the hardware blocking.

1317
00:46:07,534 --> 00:46:10,601
When we get up to 50 sprites,

1318
00:46:10,601 --> 00:46:13,000
you can already see that Canvas
is starting to take off, right?

1319
00:46:13,000 --> 00:46:15,100
It's already starting
to slow down.

1320
00:46:15,100 --> 00:46:17,801
And you can see,
real dramatically,

1321
00:46:17,801 --> 00:46:19,601
as we get up to, like,
you know, 1,000 sprites,

1322
00:46:19,601 --> 00:46:22,067
that Canvas is totally host.

1323
00:46:22,067 --> 00:46:25,067
Actually,
the Basic Quads approach

1324
00:46:25,067 --> 00:46:26,067
is totally host too.

1325
00:46:26,067 --> 00:46:27,267
This is on the G1.

1326
00:46:27,267 --> 00:46:28,901
It might be different
on other platforms.

1327
00:46:28,901 --> 00:46:30,000
But for the G1, you know,

1328
00:46:30,000 --> 00:46:31,801
that's almost
as slow as Canvas,

1329
00:46:31,801 --> 00:46:33,400
even though it's
hardware-accelerated.

1330
00:46:33,400 --> 00:46:35,133
VBOs actually hang in there
pretty good.

1331
00:46:35,133 --> 00:46:37,400
They're, you know,
easily twice as fast

1332
00:46:37,400 --> 00:46:39,901
as the non-VBO version
of the same quads.

1333
00:46:39,901 --> 00:46:42,334
And the draw_texture
just totally kicks ass.

1334
00:46:42,334 --> 00:46:44,067
It does, you know,
slow down.

1335
00:46:44,067 --> 00:46:45,901
"Oh, you've dropped down
to ten frames a second

1336
00:46:45,901 --> 00:46:47,801
when they have a thousand
sprites on the screen."

1337
00:46:47,801 --> 00:46:49,667
But ten frames a second
is only 90 milliseconds.

1338
00:46:49,667 --> 00:46:55,634
Way better than
362 milliseconds for Canvas.

1339
00:46:55,634 --> 00:46:58,200
So, short answer is
you should use draw_texture,

1340
00:46:58,200 --> 00:46:59,601
right?

1341
00:46:59,601 --> 00:47:03,200
Especially if you're making
a game that's 2D.

1342
00:47:03,200 --> 00:47:06,133
For <i>Replica Island,</i>

1343
00:47:06,133 --> 00:47:08,767
I used draw_texture for all
of the sprites on the screen,

1344
00:47:08,767 --> 00:47:11,067
and, actually, I talk about
how I rendered the background.

1345
00:47:11,067 --> 00:47:13,300
I experimented with draw_texture
for that as well.

1346
00:47:13,300 --> 00:47:16,367
And here's that thing
I already said.

1347
00:47:16,367 --> 00:47:19,334
You must check this
glGetString(GL10.GL_EXTENSIONS)

1348
00:47:19,334 --> 00:47:21,000
before you start
using these extensions,

1349
00:47:21,000 --> 00:47:23,067
otherwise you won't
be future-proof.

1350
00:47:23,067 --> 00:47:25,367
However, like I said,
Canvas is really easy to use,

1351
00:47:25,367 --> 00:47:26,834
and it might be
a total win for you

1352
00:47:26,834 --> 00:47:28,801
if you don't have
to update things every frame,

1353
00:47:28,801 --> 00:47:30,200
or you have a type of game

1354
00:47:30,200 --> 00:47:32,267
where you have very few things
to draw every frame.

1355
00:47:32,267 --> 00:47:34,133
Because for small data sets,

1356
00:47:34,133 --> 00:47:36,367
it's more than capable.

1357
00:47:36,367 --> 00:47:38,834
So this is the URL
for the SpriteMethodTests

1358
00:47:38,834 --> 00:47:40,300
that I made.

1359
00:47:40,300 --> 00:47:43,033
If you got a version of it
before about yesterday,

1360
00:47:43,033 --> 00:47:45,801
it actually contained a bug
that I'm gonna talk about

1361
00:47:45,801 --> 00:47:47,100
at the end of this talk,

1362
00:47:47,100 --> 00:47:48,534
so you should grab
the source again.

1363
00:47:48,534 --> 00:47:50,434
But it's up on
code.google.com,

1364
00:47:50,434 --> 00:47:53,467
and you can download it,
and you can look at it.

1365
00:47:53,467 --> 00:47:55,167
It kind of provides
a framework, also,

1366
00:47:55,167 --> 00:47:56,834
for how you might build
a 2D game.

1367
00:47:56,834 --> 00:47:58,734
It's very similar to what
I ended up writing

1368
00:47:58,734 --> 00:47:59,734
for <i>Replica Island.</i>

1369
00:47:59,734 --> 00:48:01,200
But it let's you, you know,

1370
00:48:01,200 --> 00:48:03,400
sort of generate an activity,

1371
00:48:03,400 --> 00:48:06,133
then just swap out the rendering
mechanism pretty easily

1372
00:48:06,133 --> 00:48:10,334
using the same
sort of simulation code.

1373
00:48:10,334 --> 00:48:12,267
Okay, so I want to talk
a little bit about

1374
00:48:12,267 --> 00:48:15,267
how I drew the backgrounds
for <i>Replica Island.</i>

1375
00:48:15,267 --> 00:48:16,968
And the reason that I want
to talk about this

1376
00:48:16,968 --> 00:48:18,667
is that background drawing
ends up being

1377
00:48:18,667 --> 00:48:19,834
the most expensive operation

1378
00:48:19,834 --> 00:48:21,200
in drawing by frame.

1379
00:48:21,200 --> 00:48:23,067
It's more expensive
than drawing with sprites.

1380
00:48:23,067 --> 00:48:25,434
It's more expensive than
calculating collision detection.

1381
00:48:25,434 --> 00:48:26,434
It's costly.

1382
00:48:26,434 --> 00:48:28,601
So the way <i>Replica Island</i> works

1383
00:48:28,601 --> 00:48:30,367
is there's actually
three parallax layers.

1384
00:48:30,367 --> 00:48:32,100
One of them's just
a static bitmap.

1385
00:48:32,100 --> 00:48:33,968
It's actually slightly larger
than the screen,

1386
00:48:33,968 --> 00:48:35,167
so it scrolls, but very slowly.

1387
00:48:35,167 --> 00:48:37,033
The second is a mid-ground layer

1388
00:48:37,033 --> 00:48:39,434
that scrolls at some speed
slower than the main camera

1389
00:48:39,434 --> 00:48:40,934
to sort of give
the illusion of depth,

1390
00:48:40,934 --> 00:48:43,200
and then the foreground layer
is kind of what the character

1391
00:48:43,200 --> 00:48:44,334
is standing on.

1392
00:48:44,334 --> 00:48:47,067
It would be nice to have
more layers, right?

1393
00:48:47,067 --> 00:48:48,367
Because then
I could have, like,

1394
00:48:48,367 --> 00:48:49,734
a layer in front
of the character,

1395
00:48:49,734 --> 00:48:50,801
like, a shadow layer,

1396
00:48:50,801 --> 00:48:52,234
or some trees
that go in front of you,

1397
00:48:52,234 --> 00:48:53,234
or something like that.

1398
00:48:53,234 --> 00:48:54,834
But at this point,

1399
00:48:54,834 --> 00:48:56,968
the game is not
quite fast enough for me

1400
00:48:56,968 --> 00:48:58,400
to increase
the number of layers

1401
00:48:58,400 --> 00:49:00,567
without having to decrease
something else.

1402
00:49:00,567 --> 00:49:02,801
So if I decided to trade
the number of enemies

1403
00:49:02,801 --> 00:49:04,601
I'm gonna put on the screen
for another layer,

1404
00:49:04,601 --> 00:49:05,901
I could do that.

1405
00:49:05,901 --> 00:49:10,067
But given the sort of
game fidelity that I want,

1406
00:49:10,067 --> 00:49:12,267
I decided to cap it
at three layers.

1407
00:49:12,267 --> 00:49:15,400
So each layer besides
the very background one,

1408
00:49:15,400 --> 00:49:17,033
is drawn out of tiles,

1409
00:49:17,033 --> 00:49:20,968
these little, small,
32x32 pixel squares, right?

1410
00:49:20,968 --> 00:49:22,000
And those are reusable,

1411
00:49:22,000 --> 00:49:23,234
and the reason
to do it that way

1412
00:49:23,234 --> 00:49:25,167
is that then you can have
levels of any size.

1413
00:49:25,167 --> 00:49:28,000
Your level just ends up
being this big array

1414
00:49:28,000 --> 00:49:29,200
of tile and indexes,

1415
00:49:29,200 --> 00:49:30,567
and all you have to do to draw

1416
00:49:30,567 --> 00:49:32,667
is figure out which part
of that array you're looking at

1417
00:49:32,667 --> 00:49:34,067
given the camera,

1418
00:49:34,067 --> 00:49:36,033
and then just go draw those
textures in the right spot,

1419
00:49:36,033 --> 00:49:37,667
so you're not limited
by the size of VRAM,

1420
00:49:37,667 --> 00:49:39,467
you're not limited
by the size of main memory.

1421
00:49:39,467 --> 00:49:41,801
I guess you are,
but the actual tile map

1422
00:49:41,801 --> 00:49:43,067
is very small.

1423
00:49:43,067 --> 00:49:45,000
And the actual level maps
end up being very small,

1424
00:49:45,000 --> 00:49:47,400
like 4k.

1425
00:49:47,400 --> 00:49:50,033
So you can make levels
of pretty much any size.

1426
00:49:50,033 --> 00:49:51,868
The bad part about this

1427
00:49:51,868 --> 00:49:53,400
is that if you're gonna
draw a layer

1428
00:49:53,400 --> 00:49:55,367
that is completely full
of tiles,

1429
00:49:55,367 --> 00:49:58,000
that means you're gonna make,
like, 150 calls

1430
00:49:58,000 --> 00:50:01,000
to this, like,
draw_texture extension,

1431
00:50:01,000 --> 00:50:03,100
or whatever method
you choose to use,

1432
00:50:03,100 --> 00:50:05,801
because each one of those tiles

1433
00:50:05,801 --> 00:50:07,400
has to get drawn.

1434
00:50:07,400 --> 00:50:08,968
And 150 calls to OpenGL,

1435
00:50:08,968 --> 00:50:10,901
just right there,
based on the previous side,

1436
00:50:10,901 --> 00:50:13,133
you should know that those
are all JNI calls,

1437
00:50:13,133 --> 00:50:15,534
and no matter what
they actually do under the hood,

1438
00:50:15,534 --> 00:50:17,467
I'm incurring some costs
to call those functions

1439
00:50:17,467 --> 00:50:18,667
150 times per layer,

1440
00:50:18,667 --> 00:50:20,267
and I have two layers
that are like this,

1441
00:50:20,267 --> 00:50:23,868
so you know, that's 300 calls
per frame, right?

1442
00:50:23,868 --> 00:50:25,167
That might be pretty costly.

1443
00:50:25,167 --> 00:50:27,000
The other thing that I
actually did not run into

1444
00:50:27,000 --> 00:50:29,234
but you could run into
on this sort of thing

1445
00:50:29,234 --> 00:50:30,934
is that, you know,
some GL implementations

1446
00:50:30,934 --> 00:50:33,200
have a fixed amount
of command buffer size,

1447
00:50:33,200 --> 00:50:34,667
and if you overflow that,

1448
00:50:34,667 --> 00:50:37,834
then it's gonna start drawing
before you're finished.

1449
00:50:37,834 --> 00:50:39,367
Actually, I never hit that,

1450
00:50:39,367 --> 00:50:41,834
but having that many GL calls

1451
00:50:41,834 --> 00:50:43,934
for my sort of
rather simple frame

1452
00:50:43,934 --> 00:50:46,067
seemed kind of wrong.

1453
00:50:46,067 --> 00:50:48,267
So I tried a bunch
of different ways.

1454
00:50:48,267 --> 00:50:49,834
Here's what
those layers look like.

1455
00:50:49,834 --> 00:50:51,033
There's the background image,

1456
00:50:51,033 --> 00:50:52,267
and then there's the mid-ground,

1457
00:50:52,267 --> 00:50:53,667
and there's the foreground,
right?

1458
00:50:53,667 --> 00:50:55,400
I tried to render this
a bunch of different ways,

1459
00:50:55,400 --> 00:50:57,601
because it's pretty slow,
and I wanted to make it better.

1460
00:50:57,601 --> 00:51:00,801
And this is what they look like
when they get composited right.

1461
00:51:00,801 --> 00:51:04,467
So I started out with
a really simple approach,

1462
00:51:04,467 --> 00:51:08,167
and that was just to take this
thing called an atlas texture,

1463
00:51:08,167 --> 00:51:09,367
which is just a texture

1464
00:51:09,367 --> 00:51:11,000
that contains
all of the possible tiles

1465
00:51:11,000 --> 00:51:12,234
in this particular level,

1466
00:51:12,234 --> 00:51:14,000
and then use this
draw_texture extension

1467
00:51:14,000 --> 00:51:15,434
to draw all the tiles
individually.

1468
00:51:15,434 --> 00:51:16,567
And what I was gonna do

1469
00:51:16,567 --> 00:51:18,200
is I was gonna select tiles

1470
00:51:18,200 --> 00:51:19,901
out of this texture map

1471
00:51:19,901 --> 00:51:22,467
by using
the glParameter() function,

1472
00:51:22,467 --> 00:51:23,734
which allows you to set cropping

1473
00:51:23,734 --> 00:51:24,934
on the texture, right?

1474
00:51:24,934 --> 00:51:27,067
So I just, you know,
bind the texture once,

1475
00:51:27,067 --> 00:51:28,200
and then set the crop and draw,

1476
00:51:28,200 --> 00:51:29,367
and then
set the crop and draw,

1477
00:51:29,367 --> 00:51:30,467
set the crop and draw, right?

1478
00:51:30,467 --> 00:51:31,601
This is a terrible idea.

1479
00:51:31,601 --> 00:51:33,167
It totally worked.
I mean, like, you know,

1480
00:51:33,167 --> 00:51:34,734
it produced the output
that I expected,

1481
00:51:34,734 --> 00:51:35,968
but it was really,
really slow.

1482
00:51:35,968 --> 00:51:37,100
And I should have guessed

1483
00:51:37,100 --> 00:51:38,667
that it was gonna be
really, really slow,

1484
00:51:38,667 --> 00:51:40,434
because it turns out
that glTextureParameter()

1485
00:51:40,434 --> 00:51:41,701
is a pretty slow function
to call,

1486
00:51:41,701 --> 00:51:43,467
and that this produces
a lot of state change,

1487
00:51:43,467 --> 00:51:45,467
and if you ever worked
on fixed-function hardware

1488
00:51:45,467 --> 00:51:47,534
like this is, state change
is expensive.

1489
00:51:47,534 --> 00:51:49,601
Any kind of state change
that you're gonna apply.

1490
00:51:49,601 --> 00:51:51,534
I mean, binding texture
can be expensive, right?

1491
00:51:51,534 --> 00:51:52,934
So you want to, you know,

1492
00:51:52,934 --> 00:51:54,501
avoid as much state change
as possible,

1493
00:51:54,501 --> 00:51:56,400
and this is a huge amount
of state change, right?

1494
00:51:56,400 --> 00:51:57,834
So, boy, this did not work.

1495
00:51:57,834 --> 00:51:58,901
I mean, it looked all right,

1496
00:51:58,901 --> 00:51:59,968
but it was really slow.

1497
00:51:59,968 --> 00:52:01,367
So then I decided,

1498
00:52:01,367 --> 00:52:03,300
well, instead of using
this atlas texture thing,

1499
00:52:03,300 --> 00:52:05,601
I'll cut it up
into individual, 32x32 textures,

1500
00:52:05,601 --> 00:52:07,767
and then I'll just call
draw_texture for those things,

1501
00:52:07,767 --> 00:52:11,234
and I won't ever have to change
the state of the texture itself

1502
00:52:11,234 --> 00:52:12,267
once I've loaded it.

1503
00:52:12,267 --> 00:52:13,701
Actually,
this works pretty well.

1504
00:52:13,701 --> 00:52:14,834
You know, I have to make

1505
00:52:14,834 --> 00:52:16,501
some adjustments
to the way that you draw,

1506
00:52:16,501 --> 00:52:18,200
because if you're gonna,
you know--

1507
00:52:18,200 --> 00:52:20,200
If you have a loop
that's walking over, like,

1508
00:52:20,200 --> 00:52:22,968
a 2D array, in order to find all
the tiles that you need to draw,

1509
00:52:22,968 --> 00:52:24,634
and you're gonna iterate
over that array,

1510
00:52:24,634 --> 00:52:25,968
like, 400 times per frame,

1511
00:52:25,968 --> 00:52:27,667
that's actually kind of slow
just right there.

1512
00:52:27,667 --> 00:52:29,334
So I like sort of RLEing
the tile map

1513
00:52:29,334 --> 00:52:30,767
and things like that,

1514
00:52:30,767 --> 00:52:33,133
so that I can get through that
particular operation faster.

1515
00:52:33,133 --> 00:52:34,934
But once those sort of
easy optimizations

1516
00:52:34,934 --> 00:52:35,934
are out of the way,

1517
00:52:35,934 --> 00:52:37,634
this actually works
pretty well.

1518
00:52:37,634 --> 00:52:39,767
You still are calling,
you know,

1519
00:52:39,767 --> 00:52:41,334
in the worst case especially,

1520
00:52:41,334 --> 00:52:43,067
a lot of OpenGL calls.

1521
00:52:43,067 --> 00:52:45,267
But it does draw,
and it does draw pretty fast

1522
00:52:45,267 --> 00:52:46,801
in this sparse case.

1523
00:52:46,801 --> 00:52:48,234
The nice thing
about this approach

1524
00:52:48,234 --> 00:52:50,334
is that if
your tile map is sparse

1525
00:52:50,334 --> 00:52:52,133
like those layers
that I just showed you were,

1526
00:52:52,133 --> 00:52:54,167
you know, it doesn't actually
have to do a lot of work.

1527
00:52:54,167 --> 00:52:55,234
It kind of has to do some work

1528
00:52:55,234 --> 00:52:56,567
to figure out
which tiles to draw,

1529
00:52:56,567 --> 00:52:58,501
but the actual
number of draw calls

1530
00:52:58,501 --> 00:52:59,801
is fairly small.

1531
00:52:59,801 --> 00:53:01,801
So that was good.

1532
00:53:01,801 --> 00:53:04,334
The problem is the worst case
from this is really bad.

1533
00:53:04,334 --> 00:53:06,868
You know, you go up to, like,
9 to 13 milliseconds

1534
00:53:06,868 --> 00:53:08,100
just to make the calls,

1535
00:53:08,100 --> 00:53:10,100
and then, like, 19 to 23
milliseconds to draw,

1536
00:53:10,100 --> 00:53:12,767
which is completely unacceptable
for a game like this.

1537
00:53:12,767 --> 00:53:15,033
When both layers
are totally full of tiles,

1538
00:53:15,033 --> 00:53:17,067
then you make, you know,
a huge number of draw calls,

1539
00:53:17,067 --> 00:53:18,701
and it gets, like, really slow.

1540
00:53:18,701 --> 00:53:23,467
So then I went back
to the meta-tile approach,

1541
00:53:23,467 --> 00:53:25,167
but instead of drawing
with draw_texture,

1542
00:53:25,167 --> 00:53:26,300
I decided to use VBOs,

1543
00:53:26,300 --> 00:53:28,234
which I know are technically
slightly slower

1544
00:53:28,234 --> 00:53:29,267
than draw_texture,

1545
00:53:29,267 --> 00:53:30,534
but I figured
maybe in this case

1546
00:53:30,534 --> 00:53:32,334
I could, you know, come up
with a way to use them

1547
00:53:32,334 --> 00:53:33,400
that is a little bit faster.

1548
00:53:33,400 --> 00:53:34,467
And what I ended up doing

1549
00:53:34,467 --> 00:53:35,767
is I ended up
splitting the level

1550
00:53:35,767 --> 00:53:37,200
into what I call
these meta tiles,

1551
00:53:37,200 --> 00:53:39,467
which are basically just these,
like, regular grid of tiles

1552
00:53:39,467 --> 00:53:41,200
that I defined with verts.

1553
00:53:41,200 --> 00:53:44,634
And then I just UV
the atlas texture to them,

1554
00:53:44,634 --> 00:53:46,200
so that they look correct

1555
00:53:46,200 --> 00:53:48,400
for whatever the level says
they're supposed to be there,

1556
00:53:48,400 --> 00:53:50,067
and I split them such
that they're about--

1557
00:53:50,067 --> 00:53:51,868
I mean, in that level,
they're probably about

1558
00:53:51,868 --> 00:53:54,200
five tiles wide
by five tiles tall.

1559
00:53:54,200 --> 00:53:56,133
I just want to get about
four of them on the screen.

1560
00:53:56,133 --> 00:53:57,367
So there's a pretty simple
algorithm

1561
00:53:57,367 --> 00:53:58,634
for taking
the size of the screen

1562
00:53:58,634 --> 00:54:00,400
and taking the size of the level
and cutting it up

1563
00:54:00,400 --> 00:54:01,467
into these meta tiles.

1564
00:54:01,467 --> 00:54:02,834
And then the nice thing
about that

1565
00:54:02,834 --> 00:54:05,400
is that you only make, like,
four draw calls per frame,

1566
00:54:05,400 --> 00:54:06,501
right?

1567
00:54:06,501 --> 00:54:07,868
You're only drawing
four meta tiles.

1568
00:54:07,868 --> 00:54:11,267
And it just happens
that they're larger

1569
00:54:11,267 --> 00:54:12,400
than the regular tiles.

1570
00:54:12,400 --> 00:54:14,334
The other good thing is that

1571
00:54:14,334 --> 00:54:15,868
you only have to call
BindTexture() once

1572
00:54:15,868 --> 00:54:18,734
for each of your layers,

1573
00:54:18,734 --> 00:54:20,100
because,
like I said before,

1574
00:54:20,100 --> 00:54:21,400
state change is slow,

1575
00:54:21,400 --> 00:54:22,467
but you're just gonna bind
those [indistinct].

1576
00:54:22,467 --> 00:54:23,634
It does take up more VRAM,

1577
00:54:23,634 --> 00:54:25,033
but actually, you have
quite a lot of VRAM

1578
00:54:25,033 --> 00:54:26,400
to work with on the G1,

1579
00:54:26,400 --> 00:54:28,234
so it hasn't been
a problem at all.

1580
00:54:28,234 --> 00:54:29,834
The issue with this is,

1581
00:54:29,834 --> 00:54:31,234
it's actually not quite as fast

1582
00:54:31,234 --> 00:54:35,000
as the draw_texture solution
in the previous slide

1583
00:54:35,000 --> 00:54:36,434
in the average case,

1584
00:54:36,434 --> 00:54:37,868
because being a sparse map

1585
00:54:37,868 --> 00:54:39,467
doesn't give it any advantage.

1586
00:54:39,467 --> 00:54:41,501
In a case where there's
no tiles at all

1587
00:54:41,501 --> 00:54:42,634
in an entire meta tile,

1588
00:54:42,634 --> 00:54:44,300
I could throw that
entire meta tile away,

1589
00:54:44,300 --> 00:54:45,534
but in most of the cases,

1590
00:54:45,534 --> 00:54:48,267
there's, you know,
it's pretty common

1591
00:54:48,267 --> 00:54:49,634
that you'd be in a situation

1592
00:54:49,634 --> 00:54:52,334
where there are, you know,
one or two tiles in there,

1593
00:54:52,334 --> 00:54:54,067
and then you have to draw
the entire meta tile.

1594
00:54:54,067 --> 00:54:55,234
So the worst case

1595
00:54:55,234 --> 00:54:56,934
and the average case
are actually the same,

1596
00:54:56,934 --> 00:54:58,868
which means it's a huge
improvement for the worst case,

1597
00:54:58,868 --> 00:55:00,767
but it means the average case
is a little bit slower.

1598
00:55:00,767 --> 00:55:02,100
Still, it's fast enough

1599
00:55:02,100 --> 00:55:04,133
that I could probably get
to 60 hertz from here.

1600
00:55:04,133 --> 00:55:06,367
I'm only about five milliseconds
away, at this point,

1601
00:55:06,367 --> 00:55:09,367
so this is what
I ended up going with.

1602
00:55:09,367 --> 00:55:11,234
Another way to do this
would have been

1603
00:55:11,234 --> 00:55:12,400
to maybe pre-render the level

1604
00:55:12,400 --> 00:55:14,033
into, like, a Canvas bitmap,

1605
00:55:14,033 --> 00:55:15,968
and then cut that up
into different textures,

1606
00:55:15,968 --> 00:55:18,367
and then assign those
to just very Basic Quads,

1607
00:55:18,367 --> 00:55:19,834
and use that.

1608
00:55:19,834 --> 00:55:23,167
The problem with that is that
it takes a lot of main memory.

1609
00:55:23,167 --> 00:55:24,601
It takes a lot of VRAM,

1610
00:55:24,601 --> 00:55:26,234
and the OpenGL
startup and shutdown

1611
00:55:26,234 --> 00:55:27,234
that I talked about before

1612
00:55:27,234 --> 00:55:28,567
would become really problematic,

1613
00:55:28,567 --> 00:55:29,868
so I haven't even
tried that yet.

1614
00:55:29,868 --> 00:55:31,734
It would probably render
real fast, though.

1615
00:55:31,734 --> 00:55:32,734
So I'm running out of time,

1616
00:55:32,734 --> 00:55:34,033
but real quick, tips and tricks.

1617
00:55:34,033 --> 00:55:35,968
You're making a game,
you might have noticed

1618
00:55:35,968 --> 00:55:37,968
that if you touch the screen
your frame rate drops.

1619
00:55:37,968 --> 00:55:40,801
That's because when you
touch the screen on Android,

1620
00:55:40,801 --> 00:55:43,701
your application gets flooded
with MotionEvents.

1621
00:55:43,701 --> 00:55:45,701
And the real easy solution to--

1622
00:55:45,701 --> 00:55:47,400
We should probably solve this
in the API,

1623
00:55:47,400 --> 00:55:48,567
but for now, the real solution

1624
00:55:48,567 --> 00:55:50,234
is to sleep in the callback,

1625
00:55:50,234 --> 00:55:51,901
because that will pause

1626
00:55:51,901 --> 00:55:53,467
the thing
that's generating the events

1627
00:55:53,467 --> 00:55:54,501
and sending them to you

1628
00:55:54,501 --> 00:55:55,567
long enough that your thread

1629
00:55:55,567 --> 00:55:56,734
won't context switch so much,

1630
00:55:56,734 --> 00:55:58,067
and you won't
get totally killed.

1631
00:55:58,067 --> 00:56:00,367
There's a balance
here too, right?

1632
00:56:00,367 --> 00:56:01,567
Because if you sleep

1633
00:56:01,567 --> 00:56:03,000
for too long
on your input callback,

1634
00:56:03,000 --> 00:56:04,734
then you're gonna start
dropping input events,

1635
00:56:04,734 --> 00:56:06,334
and your control's
not gonna feel as tight.

1636
00:56:06,334 --> 00:56:08,300
But I think you'd probably
get away with 60 milliseconds,

1637
00:56:08,300 --> 00:56:09,567
32 milliseconds no problem,

1638
00:56:09,567 --> 00:56:11,267
and that will pretty much
solve that problem.

1639
00:56:11,267 --> 00:56:13,234
You will no longer see
a frame rate effect

1640
00:56:13,234 --> 00:56:14,834
of just touching the screen.

1641
00:56:14,834 --> 00:56:16,968
If you're making a painting
application or something,

1642
00:56:16,968 --> 00:56:18,868
you might not be able to sleep
for that long of time.

1643
00:56:18,868 --> 00:56:20,734
The mechanics,
like I said before,

1644
00:56:20,734 --> 00:56:22,534
of loading OpenGL memory up

1645
00:56:22,534 --> 00:56:24,267
and reloading it up
when the contents are lost

1646
00:56:24,267 --> 00:56:25,634
are fairly complicated,

1647
00:56:25,634 --> 00:56:27,634
but fortunately there's this
GLSurfaceView class

1648
00:56:27,634 --> 00:56:28,968
that's in the API right now

1649
00:56:28,968 --> 00:56:29,968
that does all this for you.

1650
00:56:29,968 --> 00:56:30,968
So use that as a reference,

1651
00:56:30,968 --> 00:56:32,434
or just build your game
on top of that.

1652
00:56:32,434 --> 00:56:34,901
I built my game
on a modified version of that.

1653
00:56:34,901 --> 00:56:36,534
This is just a real quick point,

1654
00:56:36,534 --> 00:56:37,734
but ATITC texture compression

1655
00:56:37,734 --> 00:56:38,734
is available on the G1,

1656
00:56:38,734 --> 00:56:40,100
but you wouldn't know that

1657
00:56:40,100 --> 00:56:41,801
unless you checked
the GL extension string.

1658
00:56:41,801 --> 00:56:43,000
That's why you should check it.

1659
00:56:43,000 --> 00:56:44,167
And you have to sort of find

1660
00:56:44,167 --> 00:56:46,701
what the GL enum
parameter numbers are

1661
00:56:46,701 --> 00:56:48,234
and insert them yourself,

1662
00:56:48,234 --> 00:56:50,234
but I've heard that because
we're sort of bus-limited

1663
00:56:50,234 --> 00:56:51,234
in a lot of cases,

1664
00:56:51,234 --> 00:56:52,467
this can be
a huge improvement.

1665
00:56:52,467 --> 00:56:54,167
So if you're doing stuff
with a lot of texture,

1666
00:56:54,167 --> 00:56:56,367
and you want to, you know,
increase the amount of texture

1667
00:56:56,367 --> 00:56:57,767
you can push
over the bus every frame,

1668
00:56:57,767 --> 00:56:59,167
you can look
at ATITC compression.

1669
00:56:59,167 --> 00:57:00,934
And then this is the bug
that I talked about

1670
00:57:00,934 --> 00:57:02,534
that SpriteMethodTest
suffered from

1671
00:57:02,534 --> 00:57:04,200
before I fixed it yesterday.

1672
00:57:04,200 --> 00:57:07,033
And that's that up unt--
including Cupcake,

1673
00:57:07,033 --> 00:57:08,968
we failed to throw an exception

1674
00:57:08,968 --> 00:57:11,601
when you use indirect buffers
with OpenGL,

1675
00:57:11,601 --> 00:57:13,300
which is actually against
the OpenGL spec,

1676
00:57:13,300 --> 00:57:15,067
and what can happen
if you use indirect buffers

1677
00:57:15,067 --> 00:57:16,667
is that the GC can move
your memory around

1678
00:57:16,667 --> 00:57:19,234
and the OpenGL won't know it.

1679
00:57:19,234 --> 00:57:21,200
So just use direct buffers.

1680
00:57:21,200 --> 00:57:23,000
The API's
almost exactly the same.

1681
00:57:23,000 --> 00:57:24,834
It's pretty easy,
and it will fix the problem.

1682
00:57:24,834 --> 00:57:27,000
But in Cupcake even right now,

1683
00:57:27,000 --> 00:57:28,167
if you use indirect buffers,

1684
00:57:28,167 --> 00:57:29,634
there's no particular
error thrown.

1685
00:57:29,634 --> 00:57:31,300
You might just get,
like, a random crash.

1686
00:57:31,300 --> 00:57:34,834
In doughnuts,
it will throw an exception.

1687
00:57:34,834 --> 00:57:37,133
Okay,
so game design tips.

1688
00:57:37,133 --> 00:57:39,634
This is just
Android-specific advice

1689
00:57:39,634 --> 00:57:40,634
for making a popular game.

1690
00:57:40,634 --> 00:57:42,033
Keep it small, right?

1691
00:57:42,033 --> 00:57:45,133
When people go to, you know,
delete stuff off their phone

1692
00:57:45,133 --> 00:57:46,634
because they're
running out of space,

1693
00:57:46,634 --> 00:57:48,701
the applications get listed
in order of size.

1694
00:57:48,701 --> 00:57:52,167
That game that I just
showed you, <i>Replica Island,</i>

1695
00:57:52,167 --> 00:57:53,767
has, like,
a bunch of different enemies.

1696
00:57:53,767 --> 00:57:55,467
It's got five different,
like, world maps,

1697
00:57:55,467 --> 00:57:56,934
and it's gonna have,
like, 40 levels,

1698
00:57:56,934 --> 00:57:58,400
and it clocks in at,
like, three megs.

1699
00:57:58,400 --> 00:58:00,367
So you can very easily,
you know,

1700
00:58:00,367 --> 00:58:02,033
if you choose the right
kind of art style,

1701
00:58:02,033 --> 00:58:03,634
you choose data
that's easy to compress,

1702
00:58:03,634 --> 00:58:05,667
you can make a game
that is very small.

1703
00:58:05,667 --> 00:58:08,033
You know, <i>Super Mario World</i>
runs on 512k.

1704
00:58:08,033 --> 00:58:13,400
So you should try to optimize
the size of your application,

1705
00:58:13,400 --> 00:58:16,067
because it'll increase
your longevity.

1706
00:58:16,067 --> 00:58:17,634
Make good games, right?

1707
00:58:17,634 --> 00:58:18,701
The key to Android right now

1708
00:58:18,701 --> 00:58:20,133
on the market is quality.

1709
00:58:20,133 --> 00:58:22,334
You know, if you want to get
in that Featured Apps section,

1710
00:58:22,334 --> 00:58:23,667
there's no way to do it

1711
00:58:23,667 --> 00:58:25,567
other than making something
that's really cool,

1712
00:58:25,567 --> 00:58:27,667
that we at Google like, but also
that all the users like.

1713
00:58:27,667 --> 00:58:29,133
There's no way
to pay your way in,

1714
00:58:29,133 --> 00:58:31,167
or have a certain number of
downloads and then you get in,

1715
00:58:31,167 --> 00:58:32,300
something like that.

1716
00:58:32,300 --> 00:58:34,067
Just make something that
all the users like.

1717
00:58:34,067 --> 00:58:36,868
I highly recommend that you
put some time in to polish,

1718
00:58:36,868 --> 00:58:37,868
and to making something

1719
00:58:37,868 --> 00:58:39,200
that's really highly competent.

1720
00:58:39,200 --> 00:58:41,033
And if you do that,
you'll be ahead of the pack.

1721
00:58:41,033 --> 00:58:42,300
Because there's a lot of people

1722
00:58:42,300 --> 00:58:44,300
who just like to, you know,
throw something up there

1723
00:58:44,300 --> 00:58:45,767
that they wrote
in an evening, right?

1724
00:58:45,767 --> 00:58:47,334
And the users
are really, really picky.

1725
00:58:47,334 --> 00:58:49,067
They'll really prefer something

1726
00:58:49,067 --> 00:58:50,801
that looks like it has
a level of polish on it,

1727
00:58:50,801 --> 00:58:52,634
or has nice art style,
or something like that,

1728
00:58:52,634 --> 00:58:53,834
so I highly recommend

1729
00:58:53,834 --> 00:58:55,501
that you focus
even a little bit on quality.

1730
00:58:55,501 --> 00:58:56,667
It'll set you apart.

1731
00:58:56,667 --> 00:58:58,567
And then the last thing
I just wanted to say,

1732
00:58:58,567 --> 00:59:00,467
although I'm doing this
out of order,

1733
00:59:00,467 --> 00:59:02,267
is that not all devices
are gonna have

1734
00:59:02,267 --> 00:59:03,734
the same input systems,

1735
00:59:03,734 --> 00:59:05,267
and you should just be
cognizant of that.

1736
00:59:05,267 --> 00:59:06,601
I'm using a trackball
for my game.

1737
00:59:06,601 --> 00:59:08,267
I don't know exactly how
it's going to work

1738
00:59:08,267 --> 00:59:11,100
when the Samsung,
you know, i7500 comes out,

1739
00:59:11,100 --> 00:59:12,501
'cause that has a D-pad.

1740
00:59:12,501 --> 00:59:15,834
Probably you should just support
all of the input systems,

1741
00:59:15,834 --> 00:59:19,267
because they're already in the
framework for getting events,

1742
00:59:19,267 --> 00:59:20,501
but if you don't do that,

1743
00:59:20,501 --> 00:59:21,934
you may have a game--

1744
00:59:21,934 --> 00:59:24,200
Like, say you relied on the
hardware keyboard for your game,

1745
00:59:24,200 --> 00:59:26,200
it's not gonna be playable
on the Sapphire, right?

1746
00:59:26,200 --> 00:59:27,767
So that's something else
to be aware of.

1747
00:59:27,767 --> 00:59:30,667
And that is pretty much my talk.

1748
00:59:30,667 --> 00:59:32,601
Thank you very much
for coming today.

1749
00:59:32,601 --> 00:59:34,067
[applause]
Thank you for listening,

1750
00:59:34,067 --> 00:59:40,400
and I'm happy to answer
any questions.

1751
00:59:40,400 --> 00:59:42,434
Please use the microphone.

1752
00:59:42,434 --> 00:59:44,501
Oh, I'm sorry.

1753
00:59:44,501 --> 00:59:45,968
Okay, I'm gonna answer
one question,

1754
00:59:45,968 --> 00:59:48,834
and then I'm out of time,
because I ran long.

1755
00:59:48,834 --> 00:59:50,667
So I think you're up.
What's up?

1756
00:59:50,667 --> 00:59:52,567
man:
My question was about C++,

1757
00:59:52,567 --> 00:59:56,033
whether game development
on Android

1758
00:59:56,033 --> 00:59:57,200
can be done in C++...

1759
00:59:57,200 --> 00:59:58,200
Pruett: Yes.

1760
00:59:58,200 --> 00:59:59,634
man:
And how easy is that to do,

1761
00:59:59,634 --> 01:00:01,234
and whether there will be
any sample apps

1762
01:00:01,234 --> 01:00:02,868
for that platform.

1763
01:00:02,868 --> 01:00:04,067
Pruett: Yes.

1764
01:00:04,067 --> 01:00:05,734
Can you use C++
for your game development?

1765
01:00:05,734 --> 01:00:06,901
Right now it's really hard.

1766
01:00:06,901 --> 01:00:09,567
Very soon we will ship something
called the NDK,

1767
01:00:09,567 --> 01:00:12,834
which will allow you
to build C++ native components

1768
01:00:12,834 --> 01:00:14,901
to your applications and then
call into them from Java,

1769
01:00:14,901 --> 01:00:17,067
and then you can absolutely
use C++ to build your games.

1770
01:00:17,067 --> 01:00:18,601
If you do that, though,

1771
01:00:18,601 --> 01:00:21,234
you're gonna tie your games to
whatever particular architecture

1772
01:00:21,234 --> 01:00:22,501
you compiled that code for,

1773
01:00:22,501 --> 01:00:24,100
which means
that you're gonna lose

1774
01:00:24,100 --> 01:00:25,200
a lot of the interoperability

1775
01:00:25,200 --> 01:00:26,400
that Android sort of promises.

1776
01:00:26,400 --> 01:00:27,934
So if you're willing
to make that change

1777
01:00:27,934 --> 01:00:30,133
or you're willing to compile
from multiple architectures,

1778
01:00:30,133 --> 01:00:31,434
then absolutely.

1779
01:00:31,434 --> 01:00:33,334
And, in fact, we have games
up on market right now

1780
01:00:33,334 --> 01:00:34,701
that are built that way,

1781
01:00:34,701 --> 01:00:37,634
but as of right now,
it's kind of a pain in the butt.

1782
01:00:37,634 --> 01:00:40,300
Couple--Give us a little bit
of time to build it in.

1783
01:00:40,300 --> 01:00:42,567
Okay, thank you very much.

1784
01:00:42,567 --> 01:00:44,734
[no audio]

1785
01:00:49,801 --> 01:00:50,801
Sorry.

1786
01:00:50,801 --> 01:00:51,801
Sorry, just as you leave,

1787
01:00:51,801 --> 01:00:54,067
if we can switch
to this machine...

1788
01:00:54,067 --> 01:00:55,501
Oh, I have it here, don't I?

1789
01:00:55,501 --> 01:00:58,467
Here's the feedback link.

1790
01:00:58,467 --> 01:01:00,167
Please go give your feedback
about this talk

1791
01:01:00,167 --> 01:01:01,400
and every other talk,

1792
01:01:01,400 --> 01:01:02,801
'cause we'd really
appreciate it.

1793
01:01:02,801 --> 01:01:04,567
Thank you very much.

