1
00:00:01,267 --> 00:00:03,067
Bourrillion: The Multiset API
adds only five methods

2
00:00:03,067 --> 00:00:06,067
on top of what's already
in the collection interface.

3
00:00:06,067 --> 00:00:09,067
And it, you know--

4
00:00:09,067 --> 00:00:12,567
These are methods
that are designed to do

5
00:00:12,567 --> 00:00:14,234
the sorts of things that you
typically do

6
00:00:14,234 --> 00:00:15,567
when you use a Multiset.

7
00:00:15,567 --> 00:00:17,100
So very common thing,

8
00:00:17,100 --> 00:00:18,901
you want to know
how many occurrences

9
00:00:18,901 --> 00:00:20,567
of a particular element
are in there.

10
00:00:20,567 --> 00:00:22,400
So that method's
called "count."

11
00:00:22,400 --> 00:00:25,167
You may want to add--
oops.

12
00:00:25,167 --> 00:00:26,400
You may want to add

13
00:00:26,400 --> 00:00:28,234
a whole bunch of occurrences
at the same time

14
00:00:28,234 --> 00:00:31,901
or remove a bunch of occurrences
at the same time.

15
00:00:31,901 --> 00:00:34,501
And you may also want
to directly, you know, say,

16
00:00:34,501 --> 00:00:36,400
okay, I don't know how many
I'm adding or removing.

17
00:00:36,400 --> 00:00:40,067
I just want you to make
the count this value.

18
00:00:40,067 --> 00:00:43,567
So in Multiset terminology,

19
00:00:43,567 --> 00:00:47,400
if you add the letter A
to your Multiset three times,

20
00:00:47,400 --> 00:00:50,234
we call that
"three occurrences of A."

21
00:00:50,234 --> 00:00:53,033
And the total number
of occurrences of A

22
00:00:53,033 --> 00:00:54,567
is called "the count of A."

23
00:00:54,567 --> 00:00:56,067
Those are the terms
we adopted.

24
00:00:56,067 --> 00:00:57,868
We could also say frequency
and multiplicity,

25
00:00:57,868 --> 00:01:01,501
but we just don't use those
in our--in this doc.

26
00:01:01,501 --> 00:01:03,400
So you could directly set
the count to a new value

27
00:01:03,400 --> 00:01:06,567
or you could say conditionally
set the count to a new value

28
00:01:06,567 --> 00:01:09,367
only if its current count
is the old value.

29
00:01:09,367 --> 00:01:11,667
Once you have these methods,
then these are actually suitable

30
00:01:11,667 --> 00:01:14,067
for use
in concurrent applications.

31
00:01:14,067 --> 00:01:15,968
You're able--
these provide you the ability

32
00:01:15,968 --> 00:01:18,067
to do atomic operations

33
00:01:18,067 --> 00:01:22,234
without needing a special
concurrent Multiset interface

34
00:01:22,234 --> 00:01:24,100
because in this case,
the base interface

35
00:01:24,100 --> 00:01:26,067
simply has all the methods
that you need.

36
00:01:26,067 --> 00:01:27,901
In retrospect, java.util.map

37
00:01:27,901 --> 00:01:30,400
might have also had
all of those methods,

38
00:01:30,400 --> 00:01:32,901
but that was
a long time ago.

39
00:01:32,901 --> 00:01:35,100
We learned things
since then.

40
00:01:36,901 --> 00:01:39,467
Uh...that's--

41
00:01:39,467 --> 00:01:40,734
Okay, and then we have--

42
00:01:40,734 --> 00:01:44,067
Oh, my god, we have six
implementations of Multiset

43
00:01:44,067 --> 00:01:46,033
in our library,

44
00:01:46,033 --> 00:01:49,400
although, you know, most of them
share a lot of code.

45
00:01:49,400 --> 00:01:51,400
First and foremost
is ImmutableMultiset.

46
00:01:51,400 --> 00:01:54,567
We also have Immutables for all
of our own collection types.

47
00:01:54,567 --> 00:01:57,601
And then, you know,
if you want--

48
00:01:57,601 --> 00:02:00,334
The main question is,

49
00:02:00,334 --> 00:02:02,534
since Multiset tracks duplicate,
you know,

50
00:02:02,534 --> 00:02:05,400
the count of occurrences
of a particular element,

51
00:02:05,400 --> 00:02:07,734
you have to think about
how do you want it to decide

52
00:02:07,734 --> 00:02:09,901
whether element A and element B
are really the same?

53
00:02:09,901 --> 00:02:11,667
If you want it to use
hashCode and equals,

54
00:02:11,667 --> 00:02:13,400
that's a HashMultiset.

55
00:02:13,400 --> 00:02:15,000
If you want it
to use a comparator,

56
00:02:15,000 --> 00:02:16,901
that's TreeMultiset,

57
00:02:16,901 --> 00:02:20,901
and that also has the effect
of sorting all the values.

58
00:02:20,901 --> 00:02:22,400
And if your elements are Enums,

59
00:02:22,400 --> 00:02:24,567
you may as well
use EnumMultiset

60
00:02:24,567 --> 00:02:26,234
because that'll be faster
and simpler.

61
00:02:26,234 --> 00:02:27,734
And there's
the ConcurrentMultiset

62
00:02:27,734 --> 00:02:30,567
I told you about.

63
00:02:30,567 --> 00:02:33,567
Any questions about Multisets?

64
00:02:33,567 --> 00:02:35,567
Okay. Yes.

65
00:02:35,567 --> 00:02:39,234
man: You couldn't transform
an immutable to a mutable?

66
00:02:39,234 --> 00:02:40,567
Bourrillion:
You can always--

67
00:02:40,567 --> 00:02:43,501
The question is can you
transform a immutable...

68
00:02:43,501 --> 00:02:44,734
man: Or make a copy
thereof?

69
00:02:44,734 --> 00:02:45,901
Bourrillion:
into a mutable?

70
00:02:45,901 --> 00:02:47,234
And that's simply
a copy operation.

71
00:02:47,234 --> 00:02:49,567
So every--
every mutable collection

72
00:02:49,567 --> 00:02:51,901
is usually going to have
a copy constructor

73
00:02:51,901 --> 00:02:55,734
or a static factory method that
serves as a copy constructor.

74
00:02:55,734 --> 00:02:57,400
In the JDK collections,

75
00:02:57,400 --> 00:02:59,400
there are constructors
that take collection.

76
00:02:59,400 --> 00:03:01,901
In our library, we have static
methods that take iterable,

77
00:03:01,901 --> 00:03:03,734
but the concept is the same.

78
00:03:03,734 --> 00:03:05,400
man:
Right, um...

79
00:03:05,400 --> 00:03:06,734
just to follow up,

80
00:03:06,734 --> 00:03:09,567
in a--if you have--

81
00:03:09,567 --> 00:03:11,400
man: Just put it
up to your mouth.

82
00:03:11,400 --> 00:03:14,567
man: Oh,
if you have a...

83
00:03:14,567 --> 00:03:17,067
the immutable case,

84
00:03:17,067 --> 00:03:21,234
once you've created a collection
that is immutable to begin with,

85
00:03:21,234 --> 00:03:23,667
you can exploit some extra
data structuring underneath,

86
00:03:23,667 --> 00:03:25,334
perhaps, to take advantage
of the fact

87
00:03:25,334 --> 00:03:26,801
that there will be
no more insertion to it.

88
00:03:26,801 --> 00:03:28,067
Bourrillion:
Right.

89
00:03:28,067 --> 00:03:29,834
man: So do you do anything--
can you talk about that?

90
00:03:29,834 --> 00:03:32,734
Bourrillion: So, um,
in the immutable collections,

91
00:03:32,734 --> 00:03:34,100
it's a very--

92
00:03:34,100 --> 00:03:36,501
you know, we know up front
what the exact size is gonna be

93
00:03:36,501 --> 00:03:37,934
so we can size
the data structure,

94
00:03:37,934 --> 00:03:39,567
and we don't have to have
any of that logic

95
00:03:39,567 --> 00:03:43,734
for providing
for resize operations at all.

96
00:03:43,734 --> 00:03:46,067
The other thing
that's nice is

97
00:03:46,067 --> 00:03:48,901
in certain cases
like an immutable set,

98
00:03:48,901 --> 00:03:50,734
we can actually--
the first time

99
00:03:50,734 --> 00:03:53,200
that someone calculates
the hashCode of the set--

100
00:03:53,200 --> 00:03:54,567
This is getting
a little esoteric,

101
00:03:54,567 --> 00:03:56,734
because most people
don't call hashCode

102
00:03:56,734 --> 00:03:58,067
on their sets very often,

103
00:03:58,067 --> 00:03:59,400
but the hashCode of a set
is defined

104
00:03:59,400 --> 00:04:01,734
as the sum of the hashCodes
of all the elements.

105
00:04:01,734 --> 00:04:04,567
Once we do that once, we can
just simply cache that result

106
00:04:04,567 --> 00:04:06,567
and then we don't have to keep
doing it over and over.

107
00:04:06,567 --> 00:04:09,167
And that means if we're testing
two immutable sets for equality,

108
00:04:09,167 --> 00:04:10,634
we can first check
their hashCodes

109
00:04:10,634 --> 00:04:13,567
and it's really, really fast
if they're not equal.

110
00:04:13,567 --> 00:04:15,834
man: What about also
the queries--

111
00:04:15,834 --> 00:04:17,734
the individual queries
into a set

112
00:04:17,734 --> 00:04:20,567
or an immutable set
or an immutable map?

113
00:04:20,567 --> 00:04:22,467
You can optimize
the data structure inside to say

114
00:04:22,467 --> 00:04:25,067
each query itself
can be pretty fast.

115
00:04:25,067 --> 00:04:26,901
Bourrillion: Well, I suppose
what we should do is--

116
00:04:26,901 --> 00:04:29,567
like, when you get out of here,
you could--

117
00:04:29,567 --> 00:04:32,067
you could go look
at our code and--

118
00:04:32,067 --> 00:04:33,834
or if we have a laptop,
we can look at it together

119
00:04:33,834 --> 00:04:35,501
after the talk,
and we'll sort of look at how--

120
00:04:35,501 --> 00:04:36,901
I don't know
if I could talk through it

121
00:04:36,901 --> 00:04:38,234
off the top of my head.

122
00:04:38,234 --> 00:04:40,033
But certainly--

123
00:04:40,033 --> 00:04:43,367
there's certainly a lot of
corners that we're able to cut

124
00:04:43,367 --> 00:04:47,267
because of
the immutability situation.

125
00:04:49,067 --> 00:04:51,167
man: What about testing
with JSTL?

126
00:04:51,167 --> 00:04:53,100
'Cause, like, I see, like,
with the count you mentioned,

127
00:04:53,100 --> 00:04:55,067
you didn't do a get count
and things like that,

128
00:04:55,067 --> 00:04:57,734
and that's gonna require
a key to look up.

129
00:04:57,734 --> 00:04:59,501
Has any testing
been done there?

130
00:04:59,501 --> 00:05:00,667
If I was to--

131
00:05:00,667 --> 00:05:02,934
Bourrillion:
I don't know what JSTL is.

132
00:05:02,934 --> 00:05:05,400
man: Okay.

133
00:05:05,400 --> 00:05:07,934
Bourrillion: Do you want
to tell us about it or is it--

134
00:05:07,934 --> 00:05:09,667
[laughter]

135
00:05:09,667 --> 00:05:12,300
We can talk later.
I'm sorry.

136
00:05:12,300 --> 00:05:13,400
Bad me.

137
00:05:13,400 --> 00:05:14,567
Gentleman in the front row

138
00:05:14,567 --> 00:05:16,567
is beginning to become
something of a pest.

139
00:05:16,567 --> 00:05:17,834
[laughter]

140
00:05:17,834 --> 00:05:19,167
Josh: I'll shut up
if you want.

141
00:05:19,167 --> 00:05:20,434
Bourrillion:
No, that's okay.

142
00:05:20,434 --> 00:05:22,734
Josh: But I wanted to make
a very minor point,

143
00:05:22,734 --> 00:05:26,901
which is that what you referred
to as "copy constructor."

144
00:05:26,901 --> 00:05:29,901
I apologize. I really think
I used the term wrong

145
00:05:29,901 --> 00:05:32,167
in the first edition
of "Effective Java."

146
00:05:32,167 --> 00:05:34,734
So, in the second edition
of "Effective Java,"

147
00:05:34,734 --> 00:05:37,901
I call them
"conversion constructors."

148
00:05:37,901 --> 00:05:38,968
That's it.

149
00:05:38,968 --> 00:05:40,400
Bourrillion:
Conversion contructors.

150
00:05:40,400 --> 00:05:42,667
Josh: Because you're picking
the, you know, type

151
00:05:42,667 --> 00:05:45,534
of the thing
that you're creating.

152
00:05:45,534 --> 00:05:48,400
Bourrillion:
Okay, I'm gonna try to get

153
00:05:48,400 --> 00:05:50,234
a little bit faster,
but not much.

154
00:05:50,234 --> 00:05:53,234
So now we move on
from Multisets to Multimaps.

155
00:05:53,234 --> 00:05:55,567
So how many times

156
00:05:55,567 --> 00:05:57,734
have you ended up
writing code like this,

157
00:05:57,734 --> 00:06:00,667
where you have a map
from some key

158
00:06:00,667 --> 00:06:03,067
to some collection of values,

159
00:06:03,067 --> 00:06:06,067
and you're trying
to basically store

160
00:06:06,067 --> 00:06:08,501
a many-to-many relationship?

161
00:06:10,234 --> 00:06:12,901
In this case
we have salespeople and sales.

162
00:06:12,901 --> 00:06:16,734
And we want to build up a map
that will let us find

163
00:06:16,734 --> 00:06:20,067
all of the sales corresponding
to a particular salesperson.

164
00:06:20,067 --> 00:06:21,701
And this is the current way
of doing it

165
00:06:21,701 --> 00:06:24,934
without the benefit
of libraries like ours.

166
00:06:26,901 --> 00:06:30,334
Each time that you make a new
sale that needs to be added,

167
00:06:30,334 --> 00:06:31,734
you've got to find out

168
00:06:31,734 --> 00:06:34,634
whether you already have a list
stored in this map for that key,

169
00:06:34,634 --> 00:06:36,200
and if you do,
you can just add to it,

170
00:06:36,200 --> 00:06:38,901
and if you don't, you've got to
create one and add it yourself.

171
00:06:38,901 --> 00:06:40,567
So this is pretty much
an idiom,

172
00:06:40,567 --> 00:06:42,734
and, you know, once
you've encountered it once,

173
00:06:42,734 --> 00:06:44,734
you can sort of do the same
thing from time to time,

174
00:06:44,734 --> 00:06:47,400
and it's--you know,
it's not that bad.

175
00:06:47,400 --> 00:06:50,734
But let's look further.

176
00:06:50,734 --> 00:06:53,834
Would you rather do this?

177
00:06:53,834 --> 00:06:56,167
In this case, we create
what we call a Multimap.

178
00:06:56,167 --> 00:06:58,267
Okay, we're not the only ones
who call it a Multimap.

179
00:06:58,267 --> 00:07:00,000
You can look it up
on Wikipedia.

180
00:07:00,000 --> 00:07:03,067
Everyone calls it a Multimap.

181
00:07:03,067 --> 00:07:04,567
From salesperson to sale--

182
00:07:04,567 --> 00:07:09,067
and this time the implementation
of our method is simply put.

183
00:07:09,067 --> 00:07:10,901
That's all we have to do,

184
00:07:10,901 --> 00:07:14,000
and under the covers, it will do
all this ugly stuff for us.

185
00:07:17,133 --> 00:07:20,234
The--the benefits
of this are pretty clear

186
00:07:20,234 --> 00:07:22,567
and they're similar
to the benefits of the Multiset.

187
00:07:22,567 --> 00:07:25,334
The code has become a lot
less verbose and bug prone.

188
00:07:26,901 --> 00:07:29,067
It also offers--
this is another--

189
00:07:29,067 --> 00:07:32,234
you know, returning to what
I was emphasizing before,

190
00:07:32,234 --> 00:07:33,734
it means that as you start

191
00:07:33,734 --> 00:07:35,901
to need more and more
complicated things,

192
00:07:35,901 --> 00:07:38,400
the library is ready
to give you those things.

193
00:07:38,400 --> 00:07:40,234
You don't have to go
and write all that code

194
00:07:40,234 --> 00:07:42,067
to do those things again.

195
00:07:42,067 --> 00:07:47,167
And here's an exam--
this is not an example.

196
00:07:47,167 --> 00:07:48,734
Okay, first, I'm gonna--
yes, question.

197
00:07:48,734 --> 00:07:51,234
man: This is one-in-many,
not many-to-many.

198
00:07:51,234 --> 00:07:53,267
Bourrillion:
Uh...

199
00:07:53,267 --> 00:07:55,067
man: One salesman
has multiple--

200
00:07:55,067 --> 00:07:56,734
Bourrillion: It's many-to-many
in the sense--

201
00:07:56,734 --> 00:07:58,734
Okay, it's not
bidirectional many-to-many,

202
00:07:58,734 --> 00:08:01,567
but the same key
can have multiple values,

203
00:08:01,567 --> 00:08:05,067
and the same value can have
multiple keys as before.

204
00:08:05,067 --> 00:08:07,067
So you could say that--

205
00:08:07,067 --> 00:08:09,234
in this terminology,
you could say a regular map

206
00:08:09,234 --> 00:08:11,901
is many-to-one, right?

207
00:08:11,901 --> 00:08:14,334
Because you could have distinct
keys with the same value.

208
00:08:14,334 --> 00:08:15,667
But it's not bidirectional.

209
00:08:15,667 --> 00:08:17,400
You can't navigate it backward
in that direction.

210
00:08:17,400 --> 00:08:19,901
Am I making any sense?

211
00:08:19,901 --> 00:08:21,234
Okay.

212
00:08:21,234 --> 00:08:25,400
Suffice it to say,
here's what a Multimap is.

213
00:08:25,400 --> 00:08:28,567
It's a collection of key-value
pairs, just like a map,

214
00:08:28,567 --> 00:08:31,167
except that keys
don't have to be unique

215
00:08:31,167 --> 00:08:33,234
in this collection
of key-value pairs.

216
00:08:33,234 --> 00:08:37,767
So you can have A=1, A=2
and then B=3,

217
00:08:37,767 --> 00:08:39,400
and then you could have a bunch
of values for C.

218
00:08:39,400 --> 00:08:42,567
And now I see a lot of hands up,
so let's start over here.

219
00:08:42,567 --> 00:08:44,501
Do you want to find
a microphone?

220
00:08:47,234 --> 00:08:49,367
man: So in all the examples
that you have shown,

221
00:08:49,367 --> 00:08:51,968
you've basically been using
the factory intent

222
00:08:51,968 --> 00:08:55,400
to create, uh,
any of your collections.

223
00:08:55,400 --> 00:08:59,234
But you are not using
the constructors anywhere.

224
00:08:59,234 --> 00:09:00,734
Is there any
particular reason?

225
00:09:00,734 --> 00:09:01,968
Bourrillion:
Yes.

226
00:09:01,968 --> 00:09:06,400
Yes, constructors
are basically pains in the--

227
00:09:06,400 --> 00:09:08,734
can I say asses?

228
00:09:08,734 --> 00:09:10,734
I think I just did.

229
00:09:10,734 --> 00:09:13,567
They're--constructors really
are a big pain.

230
00:09:13,567 --> 00:09:15,901
The main reason--

231
00:09:15,901 --> 00:09:17,901
the most
immediately apparent reason

232
00:09:17,901 --> 00:09:20,234
is that Java C
does not have type inference

233
00:09:20,234 --> 00:09:22,734
for the generic-type parameters
of a constructor.

234
00:09:22,734 --> 00:09:24,734
So, as long
as you're calling constructors,

235
00:09:24,734 --> 00:09:28,901
you always have to do
really ugly stuff like this.

236
00:09:28,901 --> 00:09:32,734
All these type parameters
on your type variable here

237
00:09:32,734 --> 00:09:34,901
have to be repeated
word for word

238
00:09:34,901 --> 00:09:36,734
on the constructor.

239
00:09:36,734 --> 00:09:39,067
There is absolutely
nothing else

240
00:09:39,067 --> 00:09:41,033
that you could put
in between these angle brackets.

241
00:09:41,033 --> 00:09:43,067
It has to be exactly this
or it won't compile.

242
00:09:43,067 --> 00:09:46,400
Yet Java C
makes you specify it anyway.

243
00:09:46,400 --> 00:09:48,734
man: But do you have the public
constructors in your--

244
00:09:48,734 --> 00:09:50,367
Bourrillion:
Do we have public constructors?

245
00:09:50,367 --> 00:09:52,567
We do have public
no-argument constructors,

246
00:09:52,567 --> 00:09:56,567
but we don't go and provide all
the same convenient overloads

247
00:09:56,567 --> 00:09:58,901
in the constructors
as we do in the static--

248
00:09:58,901 --> 00:10:00,567
in--in fact, if you look in--

249
00:10:00,567 --> 00:10:03,567
I think it's section one
of "Effective Java,"

250
00:10:03,567 --> 00:10:06,400
that says prefer or consider
static factory methods.

251
00:10:06,400 --> 00:10:07,901
And there's
a lot of advantages in there

252
00:10:07,901 --> 00:10:10,667
to static factory methods
that we agree with.

253
00:10:12,234 --> 00:10:14,567
Other question?

254
00:10:14,567 --> 00:10:16,234
Or maybe--okay.

255
00:10:16,234 --> 00:10:17,734
man:
Is there any provision

256
00:10:17,734 --> 00:10:20,734
for going multiple levels deep
on those lists?

257
00:10:20,734 --> 00:10:22,400
'Cause I sometimes
had to create,

258
00:10:22,400 --> 00:10:25,400
like, you know,
a list of a list of something.

259
00:10:25,400 --> 00:10:27,067
Bourrillion: I don't think
we have anything

260
00:10:27,067 --> 00:10:29,234
that specifically
addresses that right now--

261
00:10:29,234 --> 00:10:33,067
like, basically a map
from a key

262
00:10:33,067 --> 00:10:35,567
to a map from another key
to a value

263
00:10:35,567 --> 00:10:38,567
and sort of multilevel things
like that or lists of lists.

264
00:10:38,567 --> 00:10:40,567
man: Well, yeah,
like a map from a key

265
00:10:40,567 --> 00:10:43,000
to a list of lists
of something.

266
00:10:43,000 --> 00:10:44,634
Bourrillion: Oh, okay,
no, I don't think we have

267
00:10:44,634 --> 00:10:45,968
anything like that
right now.

268
00:10:45,968 --> 00:10:49,400
We just sort of work in order
of, you know, the volume

269
00:10:49,400 --> 00:10:51,434
of code that needs the method.

270
00:10:51,434 --> 00:10:53,667
No, I don't think
we've gotten around to that yet.

271
00:10:57,234 --> 00:11:00,334
So, in this case--

272
00:11:00,334 --> 00:11:03,067
Yeah, all right.

273
00:11:03,067 --> 00:11:06,400
man: Just one question
about Multimaps.

274
00:11:06,400 --> 00:11:09,067
What will return method get

275
00:11:09,067 --> 00:11:13,400
if no--any elements
will follow...

276
00:11:13,400 --> 00:11:16,234
Bourrillion:
Oh, yeah, so any time--

277
00:11:16,234 --> 00:11:18,400
man: Null or empty
collection.

278
00:11:18,400 --> 00:11:20,400
Bourrillion: Very good question,
and I believe that question

279
00:11:20,400 --> 00:11:23,067
has a right answer
and a wrong answer.

280
00:11:23,067 --> 00:11:27,400
"Multimap.get(key) returns
a modifiable Collection view

281
00:11:27,400 --> 00:11:29,400
of the values associated
with that key."

282
00:11:29,400 --> 00:11:31,234
Therefore,
if there are no values,

283
00:11:31,234 --> 00:11:33,234
you get an empty collection.

284
00:11:33,234 --> 00:11:35,567
We're not
just gonna return null.

285
00:11:35,567 --> 00:11:38,400
And in fact,
this is a live view.

286
00:11:38,400 --> 00:11:41,000
So even if it's empty, you can
insert an element into it,

287
00:11:41,000 --> 00:11:42,567
and that will cause
the corresponding entry

288
00:11:42,567 --> 00:11:43,734
to appear in the Multimap.

289
00:11:43,734 --> 00:11:45,734
So this is a very--

290
00:11:45,734 --> 00:11:49,400
a very powerful thing
about Multimap,

291
00:11:49,400 --> 00:11:51,067
is it supports
lots of view collections

292
00:11:51,067 --> 00:11:52,567
that allow you
to look at the data

293
00:11:52,567 --> 00:11:55,000
in many different ways,
and this is one of them.

294
00:11:56,901 --> 00:11:59,067
So sometimes
you want to think

295
00:11:59,067 --> 00:12:00,667
of your Multimap
in these sort of terms.

296
00:12:00,667 --> 00:12:03,234
So, for example, like,
if you do web programming,

297
00:12:03,234 --> 00:12:05,234
you know that URL
query strings

298
00:12:05,234 --> 00:12:06,901
can look like this,
like I've described.

299
00:12:06,901 --> 00:12:09,901
You can have the same key
appearing multiple times.

300
00:12:09,901 --> 00:12:13,067
And so we have a URI--
or URL class

301
00:12:13,067 --> 00:12:14,400
that actually uses Multimap

302
00:12:14,400 --> 00:12:16,567
to represent
the query parameters.

303
00:12:16,567 --> 00:12:19,901
But sometimes you would actually
rather think of it

304
00:12:19,901 --> 00:12:21,067
this way below,

305
00:12:21,067 --> 00:12:22,567
where you have a single key

306
00:12:22,567 --> 00:12:26,067
and then the collection of all
the values that map to it.

307
00:12:26,067 --> 00:12:27,701
So if you want to look
at it this way,

308
00:12:27,701 --> 00:12:30,734
we have an asMap view
that you call on the Multimap,

309
00:12:30,734 --> 00:12:34,000
and now you can look at it
in this way.

310
00:12:36,567 --> 00:12:38,400
There are a few subtypes
of Multimaps.

311
00:12:38,400 --> 00:12:40,901
So right here,
I said that get on a key

312
00:12:40,901 --> 00:12:42,734
returns you a view

313
00:12:42,734 --> 00:12:45,567
of all the values
that correspond to that key.

314
00:12:45,567 --> 00:12:50,234
And that view is a collection,
but different Multimaps

315
00:12:50,234 --> 00:12:52,567
will have different behavior
to that collection.

316
00:12:52,567 --> 00:12:56,400
So the names that we're using
for these types

317
00:12:56,400 --> 00:12:58,234
are ListMultimap
and SetMultimap,

318
00:12:58,234 --> 00:13:00,834
because in ListMultimap,

319
00:13:00,834 --> 00:13:02,901
the collection of values
corresponding to a key

320
00:13:02,901 --> 00:13:04,734
implements the list interface.

321
00:13:04,734 --> 00:13:06,901
And in SetMultimap,
it implements the set interface.

322
00:13:06,901 --> 00:13:09,567
So you get the behaviors
that this implies.

323
00:13:09,567 --> 00:13:10,901
For example,
in a SetMultimap,

324
00:13:10,901 --> 00:13:13,067
you're never gonna have
duplicate entries.

325
00:13:13,067 --> 00:13:14,567
You couldn't have
duplicate entries,

326
00:13:14,567 --> 00:13:15,901
because then
the value collection

327
00:13:15,901 --> 00:13:19,567
corresponding to a key
would not be a set anymore.

328
00:13:19,567 --> 00:13:21,234
So we have ListMultimap,
SetMultimap,

329
00:13:21,234 --> 00:13:23,067
and SortedSetMultimap.

330
00:13:23,067 --> 00:13:25,200
And there could be others.

331
00:13:25,200 --> 00:13:27,067
At this point,
you might be thinking

332
00:13:27,067 --> 00:13:29,567
it sort of sounds
like we've come full circle,

333
00:13:29,567 --> 00:13:32,067
and you just
basically have a map

334
00:13:32,067 --> 00:13:34,400
from key
to a collection of values,

335
00:13:34,400 --> 00:13:36,734
so you could almost have just
stuck with the original code.

336
00:13:36,734 --> 00:13:40,534
But now I'm about
to kick it up a notch.

337
00:13:40,534 --> 00:13:43,400
Let's go back to our
"salesperson and sale" example.

338
00:13:43,400 --> 00:13:46,567
Now we want to find
the largest sale.

339
00:13:46,567 --> 00:13:48,400
That's it.

340
00:13:48,400 --> 00:13:50,067
We had to write all that code.

341
00:13:50,067 --> 00:13:54,501
So we have this data structure
that maps salespersons to sales.

342
00:13:54,501 --> 00:13:56,000
And we just want to find
the biggest one.

343
00:13:56,000 --> 00:13:57,567
And look at what we had to do.

344
00:13:57,567 --> 00:14:00,300
You know, this should make
your blood boil, right?

345
00:14:00,300 --> 00:14:02,400
When you see this,
you should think, you know--

346
00:14:02,400 --> 00:14:03,901
You know how some people
are always saying,

347
00:14:03,901 --> 00:14:05,234
"There ought to be a law"?

348
00:14:05,234 --> 00:14:06,567
So when you see this,
you should think,

349
00:14:06,567 --> 00:14:08,133
"There ought to be a library."

350
00:14:08,133 --> 00:14:09,300
And you should expect

351
00:14:09,300 --> 00:14:11,334
to find that library
somewhere, hopefully.

352
00:14:11,334 --> 00:14:13,234
And in this case,
it's our library.

353
00:14:13,234 --> 00:14:14,901
What did we have to do?

354
00:14:14,901 --> 00:14:17,734
We had to loop
through each of the lists

355
00:14:17,734 --> 00:14:19,234
that were stored in the map.

356
00:14:19,234 --> 00:14:22,400
We have to find the max sale
in that list

357
00:14:22,400 --> 00:14:25,734
and then compare it
to our previous max sale

358
00:14:25,734 --> 00:14:28,734
and, you know, close all
these loops and then return it.

359
00:14:28,734 --> 00:14:30,901
Or we could've built up
a temporary collection

360
00:14:30,901 --> 00:14:32,667
and for each list
put the biggest

361
00:14:32,667 --> 00:14:34,901
in the temporary collection
and then call max

362
00:14:34,901 --> 00:14:36,901
on the temporary collection.

363
00:14:36,901 --> 00:14:38,868
But what would this look like
with a Multimap?

364
00:14:38,868 --> 00:14:40,501
It looks like that.

365
00:14:42,567 --> 00:14:44,400
One line of code.

366
00:14:44,400 --> 00:14:46,400
The reason it's so simple
is that the Multimap

367
00:14:46,400 --> 00:14:48,567
has all kinds
of view collections

368
00:14:48,567 --> 00:14:52,067
that let you view the data
in different ways.

369
00:14:52,067 --> 00:14:54,567
And when you can view data
as a collection,

370
00:14:54,567 --> 00:14:56,934
then you can take advantage
of all the many utilities

371
00:14:56,934 --> 00:14:58,901
that have been already built
to deal with collections.

372
00:14:58,901 --> 00:15:01,734
So collections.max
expects the collections,

373
00:15:01,734 --> 00:15:03,567
so we use
the Multimap.values view,

374
00:15:03,567 --> 00:15:06,400
which feeds it all the values
across all the keys

375
00:15:06,400 --> 00:15:09,033
and just pulls out
the largest one.

376
00:15:12,901 --> 00:15:13,901
So...

377
00:15:13,901 --> 00:15:15,567
man:
Where's the comparator?

378
00:15:15,567 --> 00:15:17,234
Bourrillion:
Where's the comparator defined?

379
00:15:17,234 --> 00:15:18,767
man:
To be fair.

380
00:15:18,767 --> 00:15:20,234
Bourrillion:
It could be anything, though.

381
00:15:20,234 --> 00:15:22,234
So the comparator is the same
in both examples.

382
00:15:22,234 --> 00:15:24,567
So I use it
in this example here

383
00:15:24,567 --> 00:15:26,400
and I use it in this example.

384
00:15:26,400 --> 00:15:30,234
So, you know, what it probably
does is it takes a sale,

385
00:15:30,234 --> 00:15:33,067
and it calls the .get charge
method on that sale,

386
00:15:33,067 --> 00:15:34,801
and then it does the same thing
to the other sale

387
00:15:34,801 --> 00:15:37,734
and compares
the charge values.

388
00:15:37,734 --> 00:15:39,367
But it doesn't--
it's not really relevant

389
00:15:39,367 --> 00:15:41,300
to the A-versus-B comparison.

390
00:15:41,300 --> 00:15:43,167
man: Oh, I see. I'm sorry.
I withdraw the question.

391
00:15:43,167 --> 00:15:44,400
Bourrillion:
Okay.

392
00:15:44,400 --> 00:15:46,067
[laughter]

393
00:15:46,067 --> 00:15:48,567
Cool.

394
00:15:48,567 --> 00:15:51,267
Whew.
He withdrew the question.

395
00:15:51,267 --> 00:15:54,567
man: If only
I could go back in time.

396
00:15:54,567 --> 00:15:56,567
Bourrillion:
Okay.

397
00:15:56,567 --> 00:15:59,901
So, yeah, the point of this
is we love view collections.

398
00:15:59,901 --> 00:16:01,234
They're very, very powerful.

399
00:16:01,234 --> 00:16:02,901
They allow you to magnify,

400
00:16:02,901 --> 00:16:06,067
to multiply the total number
of different things you can do.

401
00:16:06,067 --> 00:16:08,901
Is there a question?
Yes.

402
00:16:08,901 --> 00:16:10,834
Microphone.

403
00:16:14,901 --> 00:16:16,901
man: So now that you got
your biggest sale,

404
00:16:16,901 --> 00:16:20,067
how do you get to the salesman
who made that sale?

405
00:16:20,067 --> 00:16:22,334
Bourrillion: Well, this example
isn't doing that.

406
00:16:22,334 --> 00:16:23,334
man: Okay.

407
00:16:23,334 --> 00:16:26,067
[laughter]

408
00:16:26,067 --> 00:16:28,400
Bourrillion: So I--
what did you say,

409
00:16:28,400 --> 00:16:29,567
you withdrew
the question?

410
00:16:29,567 --> 00:16:31,067
I withdraw the answer.

411
00:16:31,067 --> 00:16:33,901
[laughter]

412
00:16:33,901 --> 00:16:35,734
Different slide,
different day.

413
00:16:35,734 --> 00:16:40,400
man: So couldn't you
just use the same technique

414
00:16:40,400 --> 00:16:44,734
with a different comparator
and, you know, view the thing--

415
00:16:44,734 --> 00:16:46,901
taking the appropriate view,
which preserves--

416
00:16:46,901 --> 00:16:48,567
Bourrillion: Yes.
Here's what we would do.

417
00:16:48,567 --> 00:16:50,067
Instead of taking
the value's view,

418
00:16:50,067 --> 00:16:52,400
we would take
the entry's view.

419
00:16:52,400 --> 00:16:55,400
Entry's is a view
containing Map.Entry objects,

420
00:16:55,400 --> 00:16:58,601
which are the same type
that you have in a regular map,

421
00:16:58,601 --> 00:17:01,334
because all they do is they
consist of key and value.

422
00:17:01,334 --> 00:17:03,901
And you'd use the--you'd find
the max entry from that,

423
00:17:03,901 --> 00:17:07,067
and then you could navigate
from there to both the--

424
00:17:07,067 --> 00:17:09,067
Thank you.
You saved me.

425
00:17:09,067 --> 00:17:11,567
I un-withdraw my answer.

426
00:17:11,567 --> 00:17:15,734
[man speaking indistinctly]

427
00:17:15,734 --> 00:17:18,400
man: Please take
the mike.

428
00:17:18,400 --> 00:17:21,067
man: Right? It blows up
the entire set of values

429
00:17:21,067 --> 00:17:23,234
into one list.

430
00:17:23,234 --> 00:17:25,901
Bourrillion: Okay, I can also
just repeat the question.

431
00:17:25,901 --> 00:17:28,734
That's fine, too.

432
00:17:28,734 --> 00:17:32,267
man: It just expands the whole
set of values into one list.

433
00:17:32,267 --> 00:17:34,367
So if you've got a map
that's got lots of values in it,

434
00:17:34,367 --> 00:17:36,133
it can use up
a lot of memory.

435
00:17:36,133 --> 00:17:37,234
Bourrillion:
No, actually.

436
00:17:37,234 --> 00:17:38,234
man: No?

437
00:17:38,234 --> 00:17:39,634
Bourrillion:
So this value

438
00:17:39,634 --> 00:17:42,501
is simply returning to you
a view upon all those values.

439
00:17:42,501 --> 00:17:45,234
It's not actually copying
all of that data

440
00:17:45,234 --> 00:17:46,901
into another structure.

441
00:17:46,901 --> 00:17:49,234
It's simply
a custom implementation.

442
00:17:49,234 --> 00:17:52,400
And this is why we have Jared,
Jared--

443
00:17:52,400 --> 00:17:55,067
'cause he masterminded doing
this kind of crazy stuff.

444
00:17:55,067 --> 00:17:57,067
man: This sounds
much cooler than I thought.

445
00:17:57,067 --> 00:17:59,067
Bourrillion: Yes,
it's--that's--you know...

446
00:17:59,067 --> 00:18:00,334
[laughter]

447
00:18:00,334 --> 00:18:01,734
If there's one takeaway

448
00:18:01,734 --> 00:18:03,734
I would like everyone to have
from this presentation,

449
00:18:03,734 --> 00:18:05,100
could you repeat that?

450
00:18:05,100 --> 00:18:06,734
[laughter]

451
00:18:06,734 --> 00:18:08,133
man: I guess...

452
00:18:08,133 --> 00:18:09,167
Bourrillion:
I think it was,

453
00:18:09,167 --> 00:18:10,334
"It's much cooler
than I thought."

454
00:18:10,334 --> 00:18:12,200
man: It sounds much cooler
than I thought.

455
00:18:12,200 --> 00:18:14,901
Bourrillion: That's good.
That's how I feel.

456
00:18:14,901 --> 00:18:19,067
Okay, so I was supposed
to pick up the speed a little.

457
00:18:19,067 --> 00:18:20,734
Most of the methods
on Multimap

458
00:18:20,734 --> 00:18:23,567
are really just very parallel
to the same methods on Map.

459
00:18:23,567 --> 00:18:26,167
And if you can imagine
going back in time

460
00:18:26,167 --> 00:18:27,667
with all this being
in the JDK,

461
00:18:27,667 --> 00:18:29,501
these could've implemented
a common interface

462
00:18:29,501 --> 00:18:31,901
because they behave
exactly the same.

463
00:18:31,901 --> 00:18:34,400
Other ones
look a little bit different.

464
00:18:34,400 --> 00:18:36,567
For example,
the get method--

465
00:18:36,567 --> 00:18:38,267
you know, instead
of returning a V,

466
00:18:38,267 --> 00:18:39,901
it returns
a collection of V.

467
00:18:39,901 --> 00:18:42,734
And we have a couple
of different remove methods.

468
00:18:42,734 --> 00:18:44,234
One to remove
a particular entry

469
00:18:44,234 --> 00:18:47,567
and another to remove
all of the values for an entry

470
00:18:47,567 --> 00:18:48,901
and so on and so forth.

471
00:18:48,901 --> 00:18:51,400
I'm gonna gloss over that
a little bit.

472
00:18:51,400 --> 00:18:53,234
And there's
a few new things too.

473
00:18:53,234 --> 00:18:55,400
It's very full-featured.

474
00:18:55,400 --> 00:18:58,901
And we have
five implementations...

475
00:18:58,901 --> 00:19:00,634
so far.

476
00:19:03,901 --> 00:19:06,734
Okay, that's it
for Multimaps.

477
00:19:06,734 --> 00:19:09,234
I'm going to start now doing
more of a rapid fire

478
00:19:09,234 --> 00:19:10,734
over some of the other types,

479
00:19:10,734 --> 00:19:13,234
because they're a little bit
less ubiquitously--

480
00:19:13,234 --> 00:19:15,734
a little less popular
than the first two, I guess.

481
00:19:15,734 --> 00:19:17,667
Question.

482
00:19:19,734 --> 00:19:21,567
man:
Concurrent Multimap--

483
00:19:21,567 --> 00:19:25,200
Bourrillion: Oh, yeah,
so Concurrent Multimap

484
00:19:25,200 --> 00:19:28,400
is in experimental stage
right now.

485
00:19:28,400 --> 00:19:30,901
We're still going back and forth
on a few of the design issues.

486
00:19:30,901 --> 00:19:32,234
We're sort of letting it--

487
00:19:32,234 --> 00:19:35,067
letting it build up some usages
internally first.

488
00:19:35,067 --> 00:19:38,734
And we may end up promoting it
into the external library.

489
00:19:38,734 --> 00:19:39,734
Hopefully.

490
00:19:39,734 --> 00:19:41,901
[man speaking indistinctly]

491
00:19:41,901 --> 00:19:43,067
I'm sorry.

492
00:19:43,067 --> 00:19:44,734
[man speaking indistinctly]

493
00:19:44,734 --> 00:19:46,067
Yeah, theoretically it works,

494
00:19:46,067 --> 00:19:49,567
and it appears to work
in practice.

495
00:19:49,567 --> 00:19:52,734
So a BiMap, also known
as a unique-value map,

496
00:19:52,734 --> 00:19:55,734
is just a map where all
the values are unique.

497
00:19:55,734 --> 00:19:58,234
So this is good for--

498
00:19:58,234 --> 00:20:00,567
first of all, if you just want
the extra checking,

499
00:20:00,567 --> 00:20:02,067
you know,
if you're building up a map

500
00:20:02,067 --> 00:20:04,067
and you know the values
are supposed to be unique,

501
00:20:04,067 --> 00:20:05,901
go ahead and use a BiMap,

502
00:20:05,901 --> 00:20:08,267
and that way it will blow up if,
you know,

503
00:20:08,267 --> 00:20:10,234
if those aren't unique,

504
00:20:10,234 --> 00:20:11,767
at the expense
of the extra memory

505
00:20:11,767 --> 00:20:14,567
that a BiMap does require.

506
00:20:14,567 --> 00:20:16,734
The coolest thing
about a BiMap is that

507
00:20:16,734 --> 00:20:19,567
because the values are unique,
it has an inverse view,

508
00:20:19,567 --> 00:20:22,234
which is also
another instance of BiMap.

509
00:20:22,234 --> 00:20:24,734
Can view that same BiMap
in either direction.

510
00:20:24,734 --> 00:20:26,400
And if you take the inverse
of the inverse,

511
00:20:26,400 --> 00:20:29,400
you get right back
where you started again.

512
00:20:29,400 --> 00:20:32,901
So I'm sure that many times
you've had data

513
00:20:32,901 --> 00:20:35,234
that you populated
in a forward Map

514
00:20:35,234 --> 00:20:37,234
and a backward Map
separately.

515
00:20:37,234 --> 00:20:38,901
You can keep doing that
if you want,

516
00:20:38,901 --> 00:20:40,400
or you can just let us do it
for you.

517
00:20:40,400 --> 00:20:43,400
That's basically what--
what this interface amounts to.

518
00:20:43,400 --> 00:20:45,901
We'll take care of, you know,
making absolutely sure

519
00:20:45,901 --> 00:20:47,567
that those two stay in sync,

520
00:20:47,567 --> 00:20:49,834
even in the face
of all kinds of mutation

521
00:20:49,834 --> 00:20:52,601
that they could be undergoing.

522
00:20:52,601 --> 00:20:55,100
And there's a few
implementations of this too.

523
00:20:57,834 --> 00:21:00,334
ReferenceMap--
this is not a new type.

524
00:21:00,334 --> 00:21:03,567
It implements ConcurrentMap,
which is an existing type.

525
00:21:03,567 --> 00:21:05,734
And, uh,

526
00:21:05,734 --> 00:21:07,067
you know,
if you have never used

527
00:21:07,067 --> 00:21:08,567
weak references
or soft references,

528
00:21:08,567 --> 00:21:09,567
first of all,
you're lucky.

529
00:21:09,567 --> 00:21:11,200
I mean, like,
that's great

530
00:21:11,200 --> 00:21:12,534
if you never have to deal
with them.

531
00:21:12,534 --> 00:21:15,400
You're--I kind of wish
I was in those shoes.

532
00:21:15,400 --> 00:21:17,400
But if you--if you
aren't familiar with them,

533
00:21:17,400 --> 00:21:19,567
you can take a snooze.

534
00:21:19,567 --> 00:21:22,734
If you are familiar with them,
then you know about weak HashMap

535
00:21:22,734 --> 00:21:24,234
in the JDK.

536
00:21:24,234 --> 00:21:28,901
It's supports weak keys
with, what, strong values?

537
00:21:28,901 --> 00:21:30,567
Martin, Josh?

538
00:21:30,567 --> 00:21:32,534
But there's really
nine different combinations

539
00:21:32,534 --> 00:21:33,667
that you could want.

540
00:21:33,667 --> 00:21:35,734
You might want any
of strong references,

541
00:21:35,734 --> 00:21:37,567
weak references,
or soft references

542
00:21:37,567 --> 00:21:38,667
for your keys

543
00:21:38,667 --> 00:21:41,000
and strong, soft, or weak
for your values.

544
00:21:42,734 --> 00:21:44,567
So there are
nine possible combinations.

545
00:21:44,567 --> 00:21:46,567
Of course, if your combination
is strong and strong,

546
00:21:46,567 --> 00:21:48,067
then you wouldn't be using
this anyway.

547
00:21:48,067 --> 00:21:50,234
You would just be using
a regular HashMap.

548
00:21:50,234 --> 00:21:52,234
In addition to this,

549
00:21:52,234 --> 00:21:55,400
it fully implements
the ConcurrentMap interface,

550
00:21:55,400 --> 00:21:58,734
and it is a fully
concurrent data structure.

551
00:21:58,734 --> 00:22:00,501
And it has to be,

552
00:22:00,501 --> 00:22:03,234
because cleanup
of these stale references

553
00:22:03,234 --> 00:22:05,901
is happening in the GC thread.

554
00:22:05,901 --> 00:22:08,734
So as long as we were following
that strategy anyway,

555
00:22:08,734 --> 00:22:11,901
we went ahead and exposed
this concurrent behavior fully

556
00:22:11,901 --> 00:22:13,901
in the API to you.

557
00:22:13,901 --> 00:22:15,400
Josh.

558
00:22:15,400 --> 00:22:16,901
Josh: One last question,
I promise.

559
00:22:16,901 --> 00:22:19,734
So those idiots

560
00:22:19,734 --> 00:22:22,400
who wrote weak HashMap

561
00:22:22,400 --> 00:22:26,067
really got the identity
semantics all wrong.

562
00:22:26,067 --> 00:22:29,067
It uses equality
rather than identity,

563
00:22:29,067 --> 00:22:30,400
but it only makes sense

564
00:22:30,400 --> 00:22:32,901
when equality and identity
are one and the same.

565
00:22:32,901 --> 00:22:34,234
So did you smart folks,

566
00:22:34,234 --> 00:22:36,067
you know, fix this up
in any way?

567
00:22:36,067 --> 00:22:38,701
[Bourrillion laughs]

568
00:22:38,701 --> 00:22:40,534
Bourrillion: Yes,
so rather than going to idiots,

569
00:22:40,534 --> 00:22:42,567
I went to Crazy Bob.

570
00:22:42,567 --> 00:22:44,234
And so Crazy Bob
implemented this.

571
00:22:44,234 --> 00:22:46,400
And, yes,
he does the right thing.

572
00:22:46,400 --> 00:22:48,801
The--with weak references
and soft references,

573
00:22:48,801 --> 00:22:50,567
it's always
identity semantics.

574
00:22:50,567 --> 00:22:52,400
With strong references,

575
00:22:52,400 --> 00:22:54,400
currently it's always
equality semantics,

576
00:22:54,400 --> 00:22:57,067
but we have considered the idea
of adding a fourth option,

577
00:22:57,067 --> 00:22:59,567
which is strong with identity.

578
00:22:59,567 --> 00:23:01,734
So you would have soft, weak,

579
00:23:01,734 --> 00:23:04,400
and then strong identity
and strong...

580
00:23:04,400 --> 00:23:06,067
the other one.

581
00:23:06,067 --> 00:23:08,734
But we haven't done that.

582
00:23:08,734 --> 00:23:10,234
I felt compelled to point out

583
00:23:10,234 --> 00:23:13,734
that it is not yet
as fast as it could be.

584
00:23:13,734 --> 00:23:16,734
If the code ever
becomes imported into the JDK,

585
00:23:16,734 --> 00:23:19,734
such that it has access to some
of the package private internals

586
00:23:19,734 --> 00:23:22,901
of java.util,
we can make it faster.

587
00:23:22,901 --> 00:23:25,400
We could also make it faster
if we were willing to do

588
00:23:25,400 --> 00:23:27,234
some really, really ugly stuff
with the code.

589
00:23:27,234 --> 00:23:29,234
And we might have to resort
to that one day,

590
00:23:29,234 --> 00:23:31,067
but for now, we're using it
in production,

591
00:23:31,067 --> 00:23:34,400
and it's fast enough,
so we're--we're not worried.

592
00:23:34,400 --> 00:23:36,234
man: You have a lot
of computers to run it on.

593
00:23:36,234 --> 00:23:37,434
Bourrillion:
Yes, we do.

594
00:23:37,434 --> 00:23:40,234
We do have a couple computers
to run it on.

595
00:23:40,234 --> 00:23:41,501
That's true.

596
00:23:44,067 --> 00:23:47,234
So this--this is sort of unique
among our collections,

597
00:23:47,234 --> 00:23:50,734
in that if you don't--
if you need to do what it does,

598
00:23:50,734 --> 00:23:53,901
it's just really, really hard
to do it any other way.

599
00:23:53,901 --> 00:23:55,901
man: Could you give us,
like, one example

600
00:23:55,901 --> 00:23:58,234
of, you know,
where this gets used?

601
00:23:58,234 --> 00:24:00,334
Bourrillion:
Okay, so it's used a lot--

602
00:24:00,334 --> 00:24:02,234
it's used a lot for caching.

603
00:24:02,234 --> 00:24:04,734
Say that you have, like,
a customer object,

604
00:24:04,734 --> 00:24:08,234
and you want to cache in memory
this whole list of transactions,

605
00:24:08,234 --> 00:24:10,734
but what you want is for when
that customer gets garbage--

606
00:24:10,734 --> 00:24:12,934
You want that customer--
you don't want to prevent

607
00:24:12,934 --> 00:24:15,734
that customer
from being garbage collected.

608
00:24:15,734 --> 00:24:18,400
And if you just use strong
references in your cache,

609
00:24:18,400 --> 00:24:21,567
now you have--you're gonna hold
on to this customer forever.

610
00:24:21,567 --> 00:24:22,834
Actually, as a business,

611
00:24:22,834 --> 00:24:24,734
we do want to hold on
to our customers forever.

612
00:24:24,734 --> 00:24:28,567
But in our code, we like them
to get cleaned up.

613
00:24:28,567 --> 00:24:32,234
So the weak reference will--will
not prevent garbage collection,

614
00:24:32,234 --> 00:24:34,067
and when garbage collection
does happen,

615
00:24:34,067 --> 00:24:37,367
the entry will just get removed
from the Map automatically.

616
00:24:39,567 --> 00:24:41,400
Okay.

617
00:24:41,400 --> 00:24:44,734
Switching gears,
we have a class called Ordering.

618
00:24:44,734 --> 00:24:46,901
I mean, it's starting to get
to the part of the talk

619
00:24:46,901 --> 00:24:50,234
where I'm just gonna skip from
random thing to random thing.

620
00:24:50,234 --> 00:24:53,734
In the JDK, you probably know
the interface comparator.

621
00:24:53,734 --> 00:24:55,567
And it's used
for comparing things

622
00:24:55,567 --> 00:24:57,567
and deciding which one's
less than the other

623
00:24:57,567 --> 00:24:58,901
or if they're equal.

624
00:24:58,901 --> 00:25:01,400
And this is an interface
with one method,

625
00:25:01,400 --> 00:25:03,400
and so it's very easy
to implement,

626
00:25:03,400 --> 00:25:05,567
but it's a pain to use.

627
00:25:05,567 --> 00:25:07,067
Usually
there's a trade-off there,

628
00:25:07,067 --> 00:25:09,067
and the designers, rightly so,

629
00:25:09,067 --> 00:25:11,067
decided to focus
on ease of implementation,

630
00:25:11,067 --> 00:25:14,234
because you tend to implement
these things a lot.

631
00:25:14,234 --> 00:25:17,067
What we have done
is created a class

632
00:25:17,067 --> 00:25:19,100
which we've had
to call Ordering,

633
00:25:19,100 --> 00:25:21,734
which really is a richer version
of the comparator.

634
00:25:21,734 --> 00:25:24,067
And what you do is you take
your existing comparator--

635
00:25:24,067 --> 00:25:26,067
So here's a comparator
that exists in the JDK,

636
00:25:26,067 --> 00:25:28,901
String.CASE_INSENSITIVE_ORDER.

637
00:25:28,901 --> 00:25:31,400
It's a comparator
that compares strings,

638
00:25:31,400 --> 00:25:33,400
ignoring case.

639
00:25:33,400 --> 00:25:35,400
And you can call
Ordering.forComparator,

640
00:25:35,400 --> 00:25:36,734
and you get
the ordering instance

641
00:25:36,734 --> 00:25:38,400
that corresponds
to that same comparator.

642
00:25:38,400 --> 00:25:41,400
Now, this ordering
also implements comparator.

643
00:25:41,400 --> 00:25:43,067
So you can use it
as comparator,

644
00:25:43,067 --> 00:25:45,400
but it has a whole bunch of--

645
00:25:45,400 --> 00:25:48,567
Oh, of tasty methods
on it also,

646
00:25:48,567 --> 00:25:52,601
like min, max, isIncreasing,
sortedCopy of an iterable.

647
00:25:52,601 --> 00:25:54,400
You can also call
.reverse on it.

648
00:25:54,400 --> 00:25:55,734
Now you have another ordering

649
00:25:55,734 --> 00:25:58,734
that is just the reverse
semantics to the original one.

650
00:25:58,734 --> 00:26:01,067
So this
is a slightly more OO way

651
00:26:01,067 --> 00:26:02,734
to provide
all of these utilities.

652
00:26:02,734 --> 00:26:05,400
Instead of just having a long
list of static methods

653
00:26:05,400 --> 00:26:08,400
that take, you know,
these iterables

654
00:26:08,400 --> 00:26:10,067
and comparators passed in,

655
00:26:10,067 --> 00:26:12,901
we let you turn that comparator
into a richer version of itself.

656
00:26:12,901 --> 00:26:14,734
We let you upgrade
your comparator

657
00:26:14,734 --> 00:26:16,734
to a super comparator.

658
00:26:16,734 --> 00:26:18,567
And then you can do
all this fun stuff

659
00:26:18,567 --> 00:26:22,167
much more naturally and
object-oriented in--in a way.

660
00:26:25,100 --> 00:26:29,567
I'm gonna move on to covering
some of our static utilities.

661
00:26:29,567 --> 00:26:32,667
Static factory methods, we--
has them.

662
00:26:34,567 --> 00:26:36,067
We do this
for all of our collections.

663
00:26:36,067 --> 00:26:37,734
We don't--
We touched on this earlier.

664
00:26:37,734 --> 00:26:40,567
We don't want you to have
to type all of this garbage

665
00:26:40,567 --> 00:26:42,734
in your code.

666
00:26:42,734 --> 00:26:44,567
Garbage belongs
in the garbage collector,

667
00:26:44,567 --> 00:26:46,067
not in your code.

668
00:26:46,067 --> 00:26:48,400
So things like this
are just tremendously sad,

669
00:26:48,400 --> 00:26:51,067
and it's--I mean,
it's--it's more sad

670
00:26:51,067 --> 00:26:52,901
to the people who worked
on generics and the language

671
00:26:52,901 --> 00:26:53,901
than anybody else.

672
00:26:53,901 --> 00:26:55,100
You know, it's like,

673
00:26:55,100 --> 00:26:57,734
there's real weeping
that happens over this.

674
00:26:57,734 --> 00:26:59,601
I've seen it.

675
00:26:59,601 --> 00:27:01,567
And we'd very much like this
to be fixed

676
00:27:01,567 --> 00:27:04,067
in the language
in the future

677
00:27:04,067 --> 00:27:06,067
so that you did not have
to redundantly specify

678
00:27:06,067 --> 00:27:07,234
all this stuff.

679
00:27:07,234 --> 00:27:10,400
But our library
is about what you can do today,

680
00:27:10,400 --> 00:27:12,901
so we make sure to provide you
a static method.

681
00:27:12,901 --> 00:27:14,400
It just happens that in Java,

682
00:27:14,400 --> 00:27:16,734
static methods
have excellent type inference,

683
00:27:16,734 --> 00:27:19,567
and so you don't have to go
and repeat those parameters,

684
00:27:19,567 --> 00:27:23,067
except in a minority
of edge cases.

685
00:27:23,067 --> 00:27:26,234
In fact, this is so nice
that we also provide

686
00:27:26,234 --> 00:27:28,067
this whole litany
of static factory methods

687
00:27:28,067 --> 00:27:30,234
for JDK collections as well.

688
00:27:30,234 --> 00:27:33,734
And we put them in classes
called Lists, Sets, and Maps.

689
00:27:33,734 --> 00:27:37,067
These are actually by far
the most popular thing

690
00:27:37,067 --> 00:27:38,400
in our whole library.

691
00:27:38,400 --> 00:27:40,067
They're
one-liner implementations.

692
00:27:40,067 --> 00:27:42,067
They do absolutely nothing,

693
00:27:42,067 --> 00:27:43,734
but they make
your code cleaner,

694
00:27:43,734 --> 00:27:45,234
and that's
really important to us.

695
00:27:45,234 --> 00:27:48,501
We want your code to be clean.
We want it to be very readable.

696
00:27:50,400 --> 00:27:54,400
And this is something
that if you,

697
00:27:54,400 --> 00:27:57,567
for whatever reason,
don't use our library,

698
00:27:57,567 --> 00:27:59,734
but you are using Java 5,

699
00:27:59,734 --> 00:28:02,734
you should at least open up
these files

700
00:28:02,734 --> 00:28:04,234
and paste all that source code

701
00:28:04,234 --> 00:28:06,734
into some class in your own--
in your own project

702
00:28:06,734 --> 00:28:08,234
so that you can call
these methods,

703
00:28:08,234 --> 00:28:11,667
because it's just--you know,
this stuff is just such noise.

704
00:28:13,400 --> 00:28:16,567
But them in its--that in itself
might not be enough for you

705
00:28:16,567 --> 00:28:18,234
to motivate you
to use our entire library,

706
00:28:18,234 --> 00:28:20,501
but you can at least steal
that stuff from it.

707
00:28:23,234 --> 00:28:26,234
I wanted to talk
for a few minutes

708
00:28:26,234 --> 00:28:28,234
about working
with iterators and iterables.

709
00:28:28,234 --> 00:28:31,734
This is another big area
of support in our library.

710
00:28:31,734 --> 00:28:34,400
It's something that we--

711
00:28:34,400 --> 00:28:36,567
we tend to treat iterators
and iterables

712
00:28:36,567 --> 00:28:37,734
as first-class citizens

713
00:28:37,734 --> 00:28:39,601
a little more
than the JDK library does.

714
00:28:39,601 --> 00:28:41,067
And it's a constant source
of friction

715
00:28:41,067 --> 00:28:43,167
between me
and my office mate here.

716
00:28:45,234 --> 00:28:48,901
In our opinion, collection
is a really good abstraction

717
00:28:48,901 --> 00:28:51,734
to be working at when all
of your data is in memory.

718
00:28:51,734 --> 00:28:53,567
If all of your data
is not in memory,

719
00:28:53,567 --> 00:28:57,067
like you're, you know, reading
it from a file or whatnot

720
00:28:57,067 --> 00:28:58,734
and you want to make
a single pass through it,

721
00:28:58,734 --> 00:29:00,334
you can implement collection,

722
00:29:00,334 --> 00:29:02,400
and, you know,
that can be all right sometimes.

723
00:29:02,400 --> 00:29:04,734
But it tends to be
more cumbersome

724
00:29:04,734 --> 00:29:06,901
than is always necessary,

725
00:29:06,901 --> 00:29:09,234
and when you're all done
with all that cumbersome stuff,

726
00:29:09,234 --> 00:29:10,567
you're gonna end up
with a collection

727
00:29:10,567 --> 00:29:12,601
that may be
sort of badly behaved.

728
00:29:12,601 --> 00:29:15,467
People may take that collection
and just called that size on it,

729
00:29:15,467 --> 00:29:16,801
and they may not realize

730
00:29:16,801 --> 00:29:18,734
that that's gonna cause
your collection to go and slurp

731
00:29:18,734 --> 00:29:20,567
the entire,
you know, data stream

732
00:29:20,567 --> 00:29:22,667
out of a BigTable
or what have you.

733
00:29:24,734 --> 00:29:28,400
So we tend to focus

734
00:29:28,400 --> 00:29:30,067
on iterator and iterable.

735
00:29:30,067 --> 00:29:32,267
If--if that's all our method
needs you to give us,

736
00:29:32,267 --> 00:29:33,467
that's all we ask for.

737
00:29:33,467 --> 00:29:35,400
We don't make you pass us
a collection.

738
00:29:38,234 --> 00:29:41,734
As well, we also have classes
called iterators and iterables

739
00:29:41,734 --> 00:29:44,734
that are full
of useful utilities

740
00:29:44,734 --> 00:29:47,234
for working
with these things.

741
00:29:47,234 --> 00:29:49,567
So these
are parallel structure.

742
00:29:49,567 --> 00:29:53,234
You know, the exact same methods
appear in iterators class

743
00:29:53,234 --> 00:29:54,567
that take iterator parameters

744
00:29:54,567 --> 00:29:57,901
and iterables class
that take iterable parameters,

745
00:29:57,901 --> 00:30:01,234
except for the ones that don't
make sense in one or the other.

746
00:30:01,234 --> 00:30:03,067
And they
let you do things, like,

747
00:30:03,067 --> 00:30:05,067
I've omitted some
of the generics from here

748
00:30:05,067 --> 00:30:08,400
because it was too verbose
for my slides.

749
00:30:08,400 --> 00:30:09,734
But you can transform.

750
00:30:09,734 --> 00:30:12,734
You can--you can pass
all the elements of one iterable

751
00:30:12,734 --> 00:30:15,234
through a function
to get another iterable.

752
00:30:15,234 --> 00:30:17,400
You can filter
based on a predicate

753
00:30:17,400 --> 00:30:20,234
and a whole bunch of--of other
methods with predicates,

754
00:30:20,234 --> 00:30:23,667
like find, any, all,
and so forth.

755
00:30:25,067 --> 00:30:27,734
You can concatenate
an iterable of iterables.

756
00:30:27,734 --> 00:30:28,901
So, if you have
a whole bunch--

757
00:30:28,901 --> 00:30:30,901
So we were talking
about lists of lists.

758
00:30:30,901 --> 00:30:33,067
If you have a list of lists
or something like that

759
00:30:33,067 --> 00:30:34,901
and you want to view them all
as a flattened list,

760
00:30:34,901 --> 00:30:36,067
you can use this method.

761
00:30:36,067 --> 00:30:37,734
You can cycle--
you can get an iterable

762
00:30:37,734 --> 00:30:41,400
that cycles over
a source iterable infinitely.

763
00:30:41,400 --> 00:30:42,734
Things like that.

764
00:30:42,734 --> 00:30:44,734
The thing that all these methods
have in common

765
00:30:44,734 --> 00:30:49,400
is that they're absolutely
as lazy as possible...

766
00:30:49,400 --> 00:30:52,267
because I wrote them, and I'm
absolutely as lazy as possible.

767
00:30:52,267 --> 00:30:54,234
[light laughter]

768
00:30:54,234 --> 00:30:58,901
So they will never access
the backing iterator or iterable

769
00:30:58,901 --> 00:31:00,734
until they have to.

770
00:31:00,734 --> 00:31:02,734
So this will be familiar

771
00:31:02,734 --> 00:31:07,400
to many devotees of functional
programming languages.

772
00:31:07,400 --> 00:31:08,901
It's a really good thing--

773
00:31:08,901 --> 00:31:10,901
When you have
a lot of data to process,

774
00:31:10,901 --> 00:31:12,567
you can set up a whole--

775
00:31:12,567 --> 00:31:14,234
you know, you can concatenate
these things

776
00:31:14,234 --> 00:31:16,067
and then filter them
and transform them,

777
00:31:16,067 --> 00:31:18,067
and then only
as you start to access the data

778
00:31:18,067 --> 00:31:19,567
will it actually turn
all of these gears

779
00:31:19,567 --> 00:31:22,234
and actually go through
and read all of the input.

780
00:31:25,234 --> 00:31:27,067
It needs to be said

781
00:31:27,067 --> 00:31:30,234
that having interfaces

782
00:31:30,234 --> 00:31:31,901
called function
and predicate

783
00:31:31,901 --> 00:31:35,234
and having methods
to transform and filter them

784
00:31:35,234 --> 00:31:37,567
based on them,
does not exactly make Java

785
00:31:37,567 --> 00:31:40,734
into a wonderful
functional programming language.

786
00:31:40,734 --> 00:31:42,567
So if you love
functional programming,

787
00:31:42,567 --> 00:31:44,734
and a lot of people do
for very good reasons,

788
00:31:44,734 --> 00:31:47,067
and you'd love to be able
to do FP in Java,

789
00:31:47,067 --> 00:31:51,567
you can--you can do it,
but it's gonna be ugly.

790
00:31:51,567 --> 00:31:53,400
And I would say
in many of the cases

791
00:31:53,400 --> 00:31:56,734
where people
have started using these APIs,

792
00:31:56,734 --> 00:31:58,067
in some cases,
it's a net win,

793
00:31:58,067 --> 00:32:00,200
and in some cases,
it's actually a net loss.

794
00:32:00,200 --> 00:32:03,234
Sometimes their code ends up
just being more confusing

795
00:32:03,234 --> 00:32:05,234
and filled with more
generic-type parameters

796
00:32:05,234 --> 00:32:08,734
in inner classes and jumbled
than it was before.

797
00:32:08,734 --> 00:32:11,400
Java, as a language right now,

798
00:32:11,400 --> 00:32:14,901
isn't really set up
to do FP that well.

799
00:32:14,901 --> 00:32:16,567
The reason
that these methods exist

800
00:32:16,567 --> 00:32:18,734
is because sometimes
they're just what you need.

801
00:32:18,734 --> 00:32:22,067
And when they are just what you
need, you should use them.

802
00:32:22,067 --> 00:32:23,567
But if you do use them,

803
00:32:23,567 --> 00:32:25,234
take a--take a look
when you're all done

804
00:32:25,234 --> 00:32:26,901
if you really like the way
that your code came out,

805
00:32:26,901 --> 00:32:28,567
'cause you may find that,
in some cases,

806
00:32:28,567 --> 00:32:29,734
you would've been better off

807
00:32:29,734 --> 00:32:31,901
just doing things
the old-fashioned way.

808
00:32:31,901 --> 00:32:34,334
And that's my spiel
about that.

809
00:32:37,567 --> 00:32:39,567
Questions?

810
00:32:39,567 --> 00:32:41,868
Nobody wants to take me
to task about FP?

811
00:32:41,868 --> 00:32:43,067
Yeah.

812
00:32:43,067 --> 00:32:45,901
man: There's a class,
like a navigable.

813
00:32:45,901 --> 00:32:49,901
The collection--is the iterable,
like, similar?

814
00:32:49,901 --> 00:32:52,167
Bourrillion: No,
so iterable is--

815
00:32:52,167 --> 00:32:55,734
sits at the very base of the--
of the inheritance tree.

816
00:32:55,734 --> 00:32:58,234
It is even more general
than collection.

817
00:32:58,234 --> 00:33:01,734
So iterable has only one method
called "iterator,"

818
00:33:01,734 --> 00:33:03,400
which will let you get
an iterator.

819
00:33:03,400 --> 00:33:07,567
And then you have collections,
sets, sorted sets,

820
00:33:07,567 --> 00:33:09,901
and navigable set
is way down here.

821
00:33:09,901 --> 00:33:13,234
It's a very large API
for dealing with sorted data

822
00:33:13,234 --> 00:33:15,901
and, you know, navigating it
in both directions

823
00:33:15,901 --> 00:33:17,400
and finding the head set
and the tail set

824
00:33:17,400 --> 00:33:19,067
and all kinds
of really great stuff.

825
00:33:19,067 --> 00:33:20,501
We're really looking forward

826
00:33:20,501 --> 00:33:23,901
to supporting navigable set
and navigable Map in our API,

827
00:33:23,901 --> 00:33:28,033
which we will do once we make
our big Java 6 transition.

828
00:33:30,701 --> 00:33:32,767
Other stuff--
Yeah.

829
00:33:32,767 --> 00:33:34,400
Yeah.

830
00:33:34,400 --> 00:33:36,567
man: One thing that--I don't
know if it's ever been fixed,

831
00:33:36,567 --> 00:33:39,734
but has always seemed like
a really big conundrum to me,

832
00:33:39,734 --> 00:33:43,400
which was that anybody
in this world could divide--

833
00:33:43,400 --> 00:33:46,400
design an interface like Set

834
00:33:46,400 --> 00:33:48,501
and not have their
most basic operations in it,

835
00:33:48,501 --> 00:33:51,067
like Intersection
and Difference,

836
00:33:51,067 --> 00:33:54,067
which I think Rogue Wave does,
but the JDK doesn't.

837
00:33:54,067 --> 00:33:56,234
And I never could figure out
how anybody could do that.

838
00:33:56,234 --> 00:33:57,567
It just puzzles me.

839
00:33:57,567 --> 00:33:58,567
[laughter]

840
00:33:58,567 --> 00:34:01,400
Bourrillion:
Who can we blame?

841
00:34:01,400 --> 00:34:03,734
Who can we lynch?

842
00:34:03,734 --> 00:34:07,067
Josh: So, you know,
basically it's one-liners

843
00:34:07,067 --> 00:34:08,567
to get those things,
right?

844
00:34:08,567 --> 00:34:12,067
Remove all and retain all
give you precisely that,

845
00:34:12,067 --> 00:34:15,234
but you have the choice as to
whether you want to do them

846
00:34:15,234 --> 00:34:18,234
destructively
or nondestructively.

847
00:34:18,234 --> 00:34:19,734
So, you know, we gave you

848
00:34:19,734 --> 00:34:22,734
slightly more
general operations.

849
00:34:22,734 --> 00:34:26,567
That said, I acknowledge
that, you know, the names

850
00:34:26,567 --> 00:34:29,067
are a little harder
to understand,

851
00:34:29,067 --> 00:34:32,567
and I certainly believe that
when you're designing an API,

852
00:34:32,567 --> 00:34:34,901
you know, you must understand
your audience.

853
00:34:34,901 --> 00:34:39,067
You must produce an API
that is pleasant to use,

854
00:34:39,067 --> 00:34:42,067
and I think, perhaps,
we could've done better there.

855
00:34:42,067 --> 00:34:45,234
That said, you know,
I-I think that on balance,

856
00:34:45,234 --> 00:34:47,100
we made a lot
of good decisions,

857
00:34:47,100 --> 00:34:49,901
and I think that, you know,
the past 11 years have shown

858
00:34:49,901 --> 00:34:53,567
that it is an API that has
withstood the test of time,

859
00:34:53,567 --> 00:34:56,567
you know,
albeit it has faults.

860
00:34:56,567 --> 00:35:00,167
Bourrillion: And I want to point
out that if you want union

861
00:35:00,167 --> 00:35:03,234
and intersection
and difference methods,

862
00:35:03,234 --> 00:35:05,067
we have them in our library.

863
00:35:05,067 --> 00:35:06,501
[laughter]

864
00:35:06,501 --> 00:35:09,234
So you can use them.
Josh hates them. No.

865
00:35:09,234 --> 00:35:10,901
Josh: No, no,
I don't hate them at all.

866
00:35:10,901 --> 00:35:12,567
And in fact, I'm surprised

867
00:35:12,567 --> 00:35:15,067
that we didn't have them
in collections.

868
00:35:15,067 --> 00:35:16,767
Bourrillion: It's actually
a little nontrivial

869
00:35:16,767 --> 00:35:18,167
to decide
how to implement them

870
00:35:18,167 --> 00:35:21,067
because you don't want
to simply choose for the user

871
00:35:21,067 --> 00:35:22,901
what type of implementation

872
00:35:22,901 --> 00:35:24,901
you're gonna put
the results into,

873
00:35:24,901 --> 00:35:26,734
because the user
might have SortedSets,

874
00:35:26,734 --> 00:35:29,234
or he might have
Linked HashSets,

875
00:35:29,234 --> 00:35:30,901
or EnumSets,
or whatever.

876
00:35:30,901 --> 00:35:32,267
And you don't want to just
arbitrarily say,

877
00:35:32,267 --> 00:35:34,234
"We're gonna use Linked HashSet
for our result type."

878
00:35:34,234 --> 00:35:37,567
So our--our union
and intersection

879
00:35:37,567 --> 00:35:40,400
and difference methods
are implemented as views.

880
00:35:40,400 --> 00:35:42,033
So when you call methods
on them,

881
00:35:42,033 --> 00:35:43,734
they simply call
to the underlying methods.

882
00:35:43,734 --> 00:35:45,667
And then there's a method
you can say, "Copy into."

883
00:35:45,667 --> 00:35:47,033
And then you can tell it

884
00:35:47,033 --> 00:35:49,400
exactly what kind of collection
you want to copy it into.

885
00:35:49,400 --> 00:35:51,901
That's sort of in common
throughout our whole libraries.

886
00:35:51,901 --> 00:35:56,234
We try never to choose
implementation for you

887
00:35:56,234 --> 00:35:59,067
unless it's in a method called
new Hash Set, you know?

888
00:35:59,067 --> 00:36:00,834
Then we give you a HashSet.

889
00:36:00,834 --> 00:36:03,400
But instead, we try to, like,
return you in iterable

890
00:36:03,400 --> 00:36:05,901
and let you copy it into
the type that you want it to be,

891
00:36:05,901 --> 00:36:07,334
things like that.

892
00:36:09,400 --> 00:36:12,234
This is the slide
that I'm gonna just skip.

893
00:36:12,234 --> 00:36:13,801
This is the stuff we're not
telling you about.

894
00:36:13,801 --> 00:36:15,901
We're not telling you about all
of our forwarding collections,

895
00:36:15,901 --> 00:36:18,901
constrained collections,
precondition check methods,

896
00:36:18,901 --> 00:36:20,601
union/intersection/difference--

897
00:36:20,601 --> 00:36:22,567
but we did tell you
about those--

898
00:36:22,567 --> 00:36:25,567
Multimaps.index
and Maps.uniqueindex,

899
00:36:25,567 --> 00:36:27,734
ClassToInstanceMap,

900
00:36:27,734 --> 00:36:29,901
AbstractIterator,
PeekingIterator,

901
00:36:29,901 --> 00:36:31,067
and all kinds of other stuff.

902
00:36:31,067 --> 00:36:33,434
So that stuff exists too.

903
00:36:33,434 --> 00:36:35,067
Not telling you about it.

904
00:36:35,067 --> 00:36:36,567
And we're just about done,

905
00:36:36,567 --> 00:36:39,567
but I wanted to put one slide
on here to brag--

906
00:36:39,567 --> 00:36:41,234
[laughs]
to tell you about how we test

907
00:36:41,234 --> 00:36:42,567
all of this stuff,

908
00:36:42,567 --> 00:36:43,734
because we have

909
00:36:43,734 --> 00:36:46,400
over 25,000 unit tests
for this library.

910
00:36:46,400 --> 00:36:48,567
A fact
which I'm very proud of.

911
00:36:48,567 --> 00:36:53,067
And we owe this fact
to a couple of Googlers.

912
00:36:53,067 --> 00:36:57,400
I have their names down there--
Chris Povirk and George.

913
00:36:57,400 --> 00:37:00,501
And Chris Povirk and George
built this framework that--

914
00:37:00,501 --> 00:37:03,567
basically for every different
collection implementation

915
00:37:03,567 --> 00:37:04,901
that we have,

916
00:37:04,901 --> 00:37:08,567
we sort of use this API to tell
it the features

917
00:37:08,567 --> 00:37:09,901
that that collection has.

918
00:37:09,901 --> 00:37:11,567
Does it allow null values?

919
00:37:11,567 --> 00:37:15,234
Does it have comparator order
or arbitrary order or whatever?

920
00:37:15,234 --> 00:37:17,234
And we, you know,
fill in an interface

921
00:37:17,234 --> 00:37:18,734
where we actually
create the thing,

922
00:37:18,734 --> 00:37:20,067
and we send it
off to this thing,

923
00:37:20,067 --> 00:37:21,467
and it returns us
a JUnit TestSuite

924
00:37:21,467 --> 00:37:23,534
that'll have, like,
115 methods in it,

925
00:37:23,534 --> 00:37:25,067
or tests in it.

926
00:37:25,067 --> 00:37:28,133
And it's pulling those from--
we have these big test files

927
00:37:28,133 --> 00:37:30,234
full of all these methods
that are annotated,

928
00:37:30,234 --> 00:37:31,567
and it matches up
these features

929
00:37:31,567 --> 00:37:33,100
with the annotations
and methods,

930
00:37:33,100 --> 00:37:34,734
and it constructs just
the right TestSuite

931
00:37:34,734 --> 00:37:38,400
that verifies every last
unbelievably nitty-gritty thing

932
00:37:38,400 --> 00:37:39,734
about the collection.

933
00:37:39,734 --> 00:37:42,901
In fact, there are several
JDK collections

934
00:37:42,901 --> 00:37:45,667
that do not pass
all of our tests.

935
00:37:45,667 --> 00:37:46,901
And ours do.

936
00:37:46,901 --> 00:37:49,234
Now, this is not to say
that JDK collections suck.

937
00:37:49,234 --> 00:37:50,901
This is to say
that we're talking

938
00:37:50,901 --> 00:37:53,567
about really anal-retentive
little things here.

939
00:37:53,567 --> 00:37:54,734
And in every case,

940
00:37:54,734 --> 00:37:56,734
there are bugs filed already
against the JDK,

941
00:37:56,734 --> 00:37:58,100
but it hasn't, you know,

942
00:37:58,100 --> 00:38:01,000
hasn't been super-high priority
to get them fixed yet.

943
00:38:01,000 --> 00:38:02,734
But hopefully that gives you
an idea of the--

944
00:38:02,734 --> 00:38:05,901
our level of commitment
to really honoring the letter

945
00:38:05,901 --> 00:38:08,567
of our specification
very, very tightly.

946
00:38:08,567 --> 00:38:09,901
And this framework

947
00:38:09,901 --> 00:38:13,234
will be open-sourced
at some point soon,

948
00:38:13,234 --> 00:38:14,901
and then if you write
your own collections,

949
00:38:14,901 --> 00:38:17,834
you can actually use this to
test your own collections too.

950
00:38:20,234 --> 00:38:21,267
That's it.

951
00:38:21,267 --> 00:38:22,901
We finally made it to the end.
Andreas.

952
00:38:22,901 --> 00:38:24,734
Andreas: Yeah, a question
about the previous slide.

953
00:38:24,734 --> 00:38:28,067
Bourrillion:
Yes.

954
00:38:28,067 --> 00:38:29,367
Andreas:
You guys are saying

955
00:38:29,367 --> 00:38:31,734
you're, like, being very
particular about the test.

956
00:38:31,734 --> 00:38:34,234
Why are you using
a string literal then?

957
00:38:34,234 --> 00:38:35,400
Bourrillion:
String literal?

958
00:38:35,400 --> 00:38:36,701
Andreas: I mean,
for the, like, name.

959
00:38:36,701 --> 00:38:38,734
I mean, why not actually...

960
00:38:38,734 --> 00:38:39,868
Bourrillion:
Oh, for the name.

961
00:38:39,868 --> 00:38:41,067
Andreas:
Yeah, for the name.

962
00:38:41,067 --> 00:38:42,567
'Cause, like, for the test,

963
00:38:42,567 --> 00:38:44,367
'cause then that's another place
somebody can screw up.

964
00:38:44,367 --> 00:38:45,367
Bourrillion:
This right here?

965
00:38:45,367 --> 00:38:46,501
Andreas: Yeah.

966
00:38:46,501 --> 00:38:47,968
Bourrillion:
So this is just decoration.

967
00:38:47,968 --> 00:38:49,734
This is just so that
when your TestSuite is running,

968
00:38:49,734 --> 00:38:51,033
it's showing you
what it's doing.

969
00:38:51,033 --> 00:38:52,033
That's all.

970
00:38:52,033 --> 00:38:53,267
Andreas: Okay.

971
00:38:53,267 --> 00:38:54,868
Bourrillion: Yeah, and then
these things here

972
00:38:54,868 --> 00:38:56,534
are actually Enums--
these general purpose,

973
00:38:56,534 --> 00:38:58,734
allows null values,
and so forth.

974
00:38:58,734 --> 00:38:59,734
Andreas:
Okay, cool.

975
00:38:59,734 --> 00:39:02,167
Bourrillion: Okay.
Questions?

976
00:39:04,734 --> 00:39:06,567
man: So is the intention
to put this

977
00:39:06,567 --> 00:39:09,567
through the JCP
at some point?

978
00:39:09,567 --> 00:39:11,734
Bourrillion: Do one of you want
to answer this,

979
00:39:11,734 --> 00:39:14,667
or should I take a crack?

980
00:39:16,400 --> 00:39:17,567
Josh: Yes.

981
00:39:17,567 --> 00:39:18,901
[laughter]

982
00:39:18,901 --> 00:39:20,067
Bourrillion:
There you go.

983
00:39:20,067 --> 00:39:21,200
So it's really--

984
00:39:21,200 --> 00:39:24,234
The JCP is not necessarily
the ideal form

985
00:39:24,234 --> 00:39:27,734
to do real
forward-thinking development.

986
00:39:27,734 --> 00:39:30,067
It's a lot easier
to just develop all this stuff

987
00:39:30,067 --> 00:39:32,234
under the auspices
of an open-source project,

988
00:39:32,234 --> 00:39:33,567
get people using it,

989
00:39:33,567 --> 00:39:34,901
and then when things look
pretty firm,

990
00:39:34,901 --> 00:39:36,267
and you've battle-tested them,

991
00:39:36,267 --> 00:39:38,133
and you've figured out
what things should be named,

992
00:39:38,133 --> 00:39:40,234
then the hope
is that we'll start a JSR

993
00:39:40,234 --> 00:39:42,901
or do whatever process
will exist at that time

994
00:39:42,901 --> 00:39:45,067
to--to try to put some
of the stuff in the JDK.

995
00:39:45,067 --> 00:39:46,601
Martin.

996
00:39:46,601 --> 00:39:49,400
Martin: So when something
goes into the JDK,

997
00:39:49,400 --> 00:39:54,067
it--it's kind of like
it's frozen forever, right?

998
00:39:54,067 --> 00:39:56,567
Code is really, really,
really hard to change

999
00:39:56,567 --> 00:39:59,067
once it's in there, so...

1000
00:39:59,067 --> 00:40:01,067
And the--when you--

1001
00:40:01,067 --> 00:40:03,734
So I used to work at Sun,
and when you work at Sun,

1002
00:40:03,734 --> 00:40:05,734
it's--you have to work--

1003
00:40:05,734 --> 00:40:08,567
you know, you have to try to get
it right the first time.

1004
00:40:08,567 --> 00:40:10,067
And human beings
aren't very good

1005
00:40:10,067 --> 00:40:11,400
at getting it right
the first time.

1006
00:40:11,400 --> 00:40:13,901
So I think that the model
that's being used here,

1007
00:40:13,901 --> 00:40:16,067
where code
is actually being run,

1008
00:40:16,067 --> 00:40:18,400
it's being used by real people
in production,

1009
00:40:18,400 --> 00:40:20,767
and then you want to put it
in the JDK.

1010
00:40:20,767 --> 00:40:24,067
I think that's the right order
to do things in.

1011
00:40:24,067 --> 00:40:25,400
Bourrillion:
That brings up a point

1012
00:40:25,400 --> 00:40:28,234
that I wanted to--to explain,
which is, you know,

1013
00:40:28,234 --> 00:40:29,901
why is this library
being developed at Google,

1014
00:40:29,901 --> 00:40:32,234
and why is it
coming from Google?

1015
00:40:32,234 --> 00:40:34,234
Part of it is
because, you know,

1016
00:40:34,234 --> 00:40:36,067
we have some really,
really good people

1017
00:40:36,067 --> 00:40:38,400
who I've been able to ask all
of my questions.

1018
00:40:38,400 --> 00:40:43,067
I-I-I basically typify
the--the expression

1019
00:40:43,067 --> 00:40:44,734
of standing
on the shoulders of giants,

1020
00:40:44,734 --> 00:40:46,400
because everything I do,
I just ask,

1021
00:40:46,400 --> 00:40:47,567
like, enough,
you know, experts

1022
00:40:47,567 --> 00:40:48,901
and try to put it all together
in my head

1023
00:40:48,901 --> 00:40:50,067
and figure out what to do.

1024
00:40:50,067 --> 00:40:52,400
But the other part is ju--

1025
00:40:52,400 --> 00:40:54,234
we simply have
an environment at Google

1026
00:40:54,234 --> 00:40:55,734
that is very, very conducive

1027
00:40:55,734 --> 00:40:57,567
to the development
of libraries like this.

1028
00:40:57,567 --> 00:40:59,067
It's really very unique.

1029
00:40:59,067 --> 00:41:01,400
We have
a very aggressive attitude

1030
00:41:01,400 --> 00:41:02,901
towards sharing code here.

1031
00:41:02,901 --> 00:41:06,234
If I have, like,
a performance improvement

1032
00:41:06,234 --> 00:41:08,234
or an API improvement that
I want to make to a library,

1033
00:41:08,234 --> 00:41:10,567
I can get that change made
and actually out in production

1034
00:41:10,567 --> 00:41:13,567
in every Google service
on their next push.

1035
00:41:13,567 --> 00:41:15,067
It's sort of a system--

1036
00:41:15,067 --> 00:41:18,234
it sounds kind of mind-blowing
when you think about it,

1037
00:41:18,234 --> 00:41:20,901
that I can actually cause
changes that don't have to wait

1038
00:41:20,901 --> 00:41:23,400
for the sign-off of every
individual project first.

1039
00:41:23,400 --> 00:41:28,400
But this situation has led
to a really unique ability

1040
00:41:28,400 --> 00:41:32,734
to, you know, write code,
get it used, see how it works.

1041
00:41:32,734 --> 00:41:35,901
If I need to rename something,
I literally open up

1042
00:41:35,901 --> 00:41:38,234
all of the Java code
in Google in IntelliJ,

1043
00:41:38,234 --> 00:41:41,067
and I hit Shift-F6,
and I modify that code

1044
00:41:41,067 --> 00:41:42,901
and everybody's client code
at the same time.

1045
00:41:42,901 --> 00:41:45,734
That's literally
what I do so...

1046
00:41:45,734 --> 00:41:48,400
And together with that,
we have no shortage

1047
00:41:48,400 --> 00:41:51,234
of really wonderful,
opinionated engineers,

1048
00:41:51,234 --> 00:41:52,901
who join my mailing lists,

1049
00:41:52,901 --> 00:41:55,734
and we discuss all
of these things, and through--

1050
00:41:55,734 --> 00:41:57,901
you know, when we get a really
heated debate going on,

1051
00:41:57,901 --> 00:42:00,200
that's when we really know that
we're--we're gonna hit

1052
00:42:00,200 --> 00:42:02,400
on something really good
out of that.

1053
00:42:02,400 --> 00:42:03,734
So it's sort of like--

1054
00:42:03,734 --> 00:42:05,734
I don't know
how we could've developed this

1055
00:42:05,734 --> 00:42:09,234
anywhere else, but at Google,
and I just wanted to...

1056
00:42:09,234 --> 00:42:11,400
say that.

1057
00:42:11,400 --> 00:42:15,067
I think you had your hand up
first, in the front row.

1058
00:42:15,067 --> 00:42:16,901
man:
Yes, so I was gonna ask

1059
00:42:16,901 --> 00:42:18,901
about whether
you were influenced

1060
00:42:18,901 --> 00:42:22,067
by the Apache Jakarta Commons
or whatever,

1061
00:42:22,067 --> 00:42:23,901
but now I want to ask you,

1062
00:42:23,901 --> 00:42:27,067
when you do those huge
global refactorings

1063
00:42:27,067 --> 00:42:29,234
like rename or whatever,
do you find that the next day

1064
00:42:29,234 --> 00:42:32,167
anybody has changed
anything back?

1065
00:42:32,167 --> 00:42:33,434
Bourrillion:
Nope.

1066
00:42:33,434 --> 00:42:35,567
If they did, their code--
their build would break.

1067
00:42:35,567 --> 00:42:38,234
man: Okay. So then maybe
the Apache question.

1068
00:42:38,234 --> 00:42:39,534
Bourrillion: Okay.

1069
00:42:39,534 --> 00:42:43,234
So we were not really influenced
by the Apache library.

1070
00:42:43,234 --> 00:42:45,901
We were aware that it existed,
but because Google

1071
00:42:45,901 --> 00:42:49,901
adopted Java 5 in generics
very early on, it was very--

1072
00:42:49,901 --> 00:42:51,200
and we went through

1073
00:42:51,200 --> 00:42:53,567
and we generified all
of our code, like, really fast.

1074
00:42:53,567 --> 00:42:55,067
Again, I used IntelliJ.

1075
00:42:55,067 --> 00:42:56,567
I loaded up
a big swath of code,

1076
00:42:56,567 --> 00:43:00,167
and I hit, you know,
Alt-Shift-F12 or whatever,

1077
00:43:00,167 --> 00:43:02,567
and it generified
all the code.

1078
00:43:02,567 --> 00:43:04,901
So once we crossed
that Rubicon,

1079
00:43:04,901 --> 00:43:07,100
then--then generics
were very important to us,

1080
00:43:07,100 --> 00:43:10,901
and there was no officially
available generified version

1081
00:43:10,901 --> 00:43:13,067
of the Apache library
at that time.

1082
00:43:13,067 --> 00:43:16,234
When we noticed that and we also
noticed that the Apache library

1083
00:43:16,234 --> 00:43:19,567
takes a different approach
to us in many ways,

1084
00:43:19,567 --> 00:43:23,901
when it comes to adhering to
the letter of the specifications

1085
00:43:23,901 --> 00:43:26,234
of the interfaces that they
implement from the JDK.

1086
00:43:26,234 --> 00:43:29,067
So we're very,
very hard core

1087
00:43:29,067 --> 00:43:32,567
about following those interfaces
as tightly as we can,

1088
00:43:32,567 --> 00:43:35,067
and their library,
for valid reasons,

1089
00:43:35,067 --> 00:43:37,567
decides to depart,
you know--

1090
00:43:37,567 --> 00:43:41,100
I don't want to say it's
a totally dumb thing to do,

1091
00:43:41,100 --> 00:43:43,234
but they've chosen to depart
from those specifications

1092
00:43:43,234 --> 00:43:44,734
in certain ways
and just try to flag it

1093
00:43:44,734 --> 00:43:47,434
in their java.doc
as saying, "Violation."

1094
00:43:47,434 --> 00:43:50,901
Um, I decide that--
or we decided that

1095
00:43:50,901 --> 00:43:53,100
when, um, code implements
an interface

1096
00:43:53,100 --> 00:43:54,501
but it doesn't adhere
to the letter

1097
00:43:54,501 --> 00:43:56,167
of what that interface says,

1098
00:43:56,167 --> 00:43:58,200
then your code is gonna
be harder for people to learn.

1099
00:43:58,200 --> 00:44:00,267
They have more stuff that they
have to keep in their head.

1100
00:44:00,267 --> 00:44:02,133
The more edge cases
they have to think about.

1101
00:44:02,133 --> 00:44:04,467
And if you just get religious
about it as much as possible,

1102
00:44:04,467 --> 00:44:07,267
then you've just made
everyone's lives easier.

1103
00:44:07,267 --> 00:44:09,601
So because of that, you know,
we just sort of have

1104
00:44:09,601 --> 00:44:12,300
an independent evolution
from that library.

1105
00:44:12,300 --> 00:44:15,100
We've never really, like,
you know, reviewed that library

1106
00:44:15,100 --> 00:44:16,501
to get ideas of what to do.

1107
00:44:16,501 --> 00:44:19,334
Our ideas come directly
from what actual Googlers

1108
00:44:19,334 --> 00:44:20,734
are trying to do
in their projects.

1109
00:44:20,734 --> 00:44:22,467
We look at their code
and we say, oh,

1110
00:44:22,467 --> 00:44:23,968
you had to write 50 lines
to do this.

1111
00:44:23,968 --> 00:44:26,334
Let's--let's write a library
that you can use.

1112
00:44:28,767 --> 00:44:30,601
man: Uh, this is kind of
a two-part question.

1113
00:44:30,601 --> 00:44:33,434
The first part is, uh,
how many people did it take

1114
00:44:33,434 --> 00:44:36,667
to write those 25,000,
uh, unit tests?

1115
00:44:36,667 --> 00:44:38,367
Bourrillion: So the 25,000
unit tests

1116
00:44:38,367 --> 00:44:39,734
weren't written by people,
right?

1117
00:44:39,734 --> 00:44:42,067
They're written by this
framework that spits them out.

1118
00:44:42,067 --> 00:44:45,033
Right? So in terms of actual
number of test methods

1119
00:44:45,033 --> 00:44:48,200
that we've written, maybe it's
only like 2,000 or something.

1120
00:44:48,200 --> 00:44:50,868
I don't know. And then it's
recombining those in many ways.

1121
00:44:50,868 --> 00:44:54,334
And it's doing it--
it's doing so in such a way

1122
00:44:54,334 --> 00:44:57,200
that everything gets created as
an independent JUnit test case

1123
00:44:57,200 --> 00:44:58,767
so that when one fails,

1124
00:44:58,767 --> 00:45:01,033
it doesn't cause a whole huge
thing to fail.

1125
00:45:01,033 --> 00:45:03,634
It just pinpoints exactly
what the failures were.

1126
00:45:03,634 --> 00:45:05,100
And that's what blows
those numbers up.

1127
00:45:05,100 --> 00:45:06,234
man: Oh, okay.

1128
00:45:06,234 --> 00:45:08,100
And the second part
of the question was, um,

1129
00:45:08,100 --> 00:45:10,968
if, um, it takes, uh,
all this, uh, experience

1130
00:45:10,968 --> 00:45:14,200
and--and expertise of the
world's top Java programmers

1131
00:45:14,200 --> 00:45:17,501
to write these--what
accomplishes this task here,

1132
00:45:17,501 --> 00:45:21,033
which is really, uh, relatively
simple at least on the surface--

1133
00:45:21,033 --> 00:45:22,100
I mean, you know,
you're not--

1134
00:45:22,100 --> 00:45:23,467
we're not doing
rocket science here.

1135
00:45:23,467 --> 00:45:25,200
We're doing the kind of stuff
that we learned in,

1136
00:45:25,200 --> 00:45:28,767
you know, data structures
classes and what like that.

1137
00:45:28,767 --> 00:45:31,300
Um, then what--what chance do
the rest of us poor mortals have

1138
00:45:31,300 --> 00:45:33,434
of writing a bug-free code
when we're actually writing

1139
00:45:33,434 --> 00:45:35,267
a real application
that's really complicated

1140
00:45:35,267 --> 00:45:39,000
like maybe putting a lander
on Mars or something like that?

1141
00:45:40,901 --> 00:45:44,067
Bourrillion: Um,
so the question is, uh,

1142
00:45:44,067 --> 00:45:47,033
so I've alluded
to the difficulty

1143
00:45:47,033 --> 00:45:49,367
of writing this library or how
much work we've spent on it.

1144
00:45:49,367 --> 00:45:51,567
And the question is sort of,
if it's--

1145
00:45:51,567 --> 00:45:54,067
if it was that hard
for us to write the library...

1146
00:45:54,067 --> 00:45:56,367
man: Yeah. This is a fairly
simple task compared to, um...

1147
00:45:56,367 --> 00:45:58,300
Bourrillion: Which is a fairly--
writing the library?

1148
00:45:58,300 --> 00:45:59,834
man: Yeah, I mean,
a library is a relatively

1149
00:45:59,834 --> 00:46:01,200
constrained environment.

1150
00:46:01,200 --> 00:46:03,300
It's not--it's a pretty
small task compared to...

1151
00:46:03,300 --> 00:46:05,033
Bourrillion: I remember
when I used to think so.

1152
00:46:05,033 --> 00:46:06,167
man: Right.

1153
00:46:06,167 --> 00:46:07,634
Bourrillion: That would be
before I spent

1154
00:46:07,634 --> 00:46:09,367
the last three years
of my life writing libraries.

1155
00:46:09,367 --> 00:46:11,334
man: Right. But just think
of a large application that has,

1156
00:46:11,334 --> 00:46:13,501
uh, you know, uh, really life--
life-threatening consequences

1157
00:46:13,501 --> 00:46:16,334
or, you know, safety concerns
and things like that,

1158
00:46:16,334 --> 00:46:19,267
uh, with--without--doesn't have
the kind of resources even

1159
00:46:19,267 --> 00:46:20,868
that you can really bear down
on such a small--

1160
00:46:20,868 --> 00:46:23,734
you--you're using a fairly large
amount of resources

1161
00:46:23,734 --> 00:46:26,567
at least intellectually
on a fairly small problem,

1162
00:46:26,567 --> 00:46:29,033
whereas the rest of us a lot
of times probably have to deal

1163
00:46:29,033 --> 00:46:30,901
with a bigger problem
with less resources.

1164
00:46:30,901 --> 00:46:33,801
I'm wondering how we can
actually write code that's--

1165
00:46:33,801 --> 00:46:35,834
that's reliable.

1166
00:46:35,834 --> 00:46:37,701
Bourrillion: Our approach,
you know, the approach

1167
00:46:37,701 --> 00:46:40,634
that, you know, Jared and I
and, uh, the rest of us

1168
00:46:40,634 --> 00:46:43,100
who've worked on this
have been taking

1169
00:46:43,100 --> 00:46:45,834
is to try to build up
from the bottom level,

1170
00:46:45,834 --> 00:46:47,434
higher and higher level,

1171
00:46:47,434 --> 00:46:49,934
utilities that do more
of the work for you,

1172
00:46:49,934 --> 00:46:51,701
that cause you to have to write
less code,

1173
00:46:51,701 --> 00:46:54,100
that cause you to have to test
less code,

1174
00:46:54,100 --> 00:46:56,634
and test--we test the hell
out of our things,

1175
00:46:56,634 --> 00:46:59,167
so that, uh, that--

1176
00:46:59,167 --> 00:47:01,834
do I want to say that rising
tide lifts all boats?

1177
00:47:01,834 --> 00:47:03,000
I just said it.

1178
00:47:03,000 --> 00:47:06,334
Um, so that's our angle

1179
00:47:06,334 --> 00:47:07,834
on trying to make
your job easier.

1180
00:47:07,834 --> 00:47:10,133
Other people are working
on possible language changes.

1181
00:47:10,133 --> 00:47:11,834
Other people work on tools
and so forth.

1182
00:47:11,834 --> 00:47:13,601
We do it through libraries.

1183
00:47:13,601 --> 00:47:17,400
Uh, it's, you know,

1184
00:47:17,400 --> 00:47:21,534
I-I kind of want to address
the idea

1185
00:47:21,534 --> 00:47:25,200
that writing the library
is--is easy or simple

1186
00:47:25,200 --> 00:47:28,100
because it's not.

1187
00:47:28,100 --> 00:47:30,100
I don't know how else
to describe why.

1188
00:47:30,100 --> 00:47:32,734
But it's been very
challenging.

1189
00:47:32,734 --> 00:47:35,901
Um...so...

1190
00:47:35,901 --> 00:47:37,400
man: Sorry for that
distraction.

1191
00:47:37,400 --> 00:47:38,968
Bourrillion:
That's all right.

1192
00:47:40,734 --> 00:47:42,033
Next question.

1193
00:47:42,033 --> 00:47:43,934
Uh, Josh?

1194
00:47:43,934 --> 00:47:45,501
Josh: Well, can I just add
a little to your--

1195
00:47:45,501 --> 00:47:46,501
your previous answer?

1196
00:47:46,501 --> 00:47:47,901
Bourrillion:
Yes, please.

1197
00:47:47,901 --> 00:47:52,033
Josh: So writing libraries
is much harder than it looks.

1198
00:47:52,033 --> 00:47:55,734
I think the guy who, well,
is reputed to have said it best

1199
00:47:55,734 --> 00:47:57,067
is, uh, Thelonious Monk.

1200
00:47:57,067 --> 00:47:59,400
Although he wasn't actually
talking about libraries.

1201
00:47:59,400 --> 00:48:01,200
Um, he said simple
ain't easy.

1202
00:48:01,200 --> 00:48:02,667
He didn't actually say that.

1203
00:48:02,667 --> 00:48:04,701
It turns out what he really
said was, "them simple chords

1204
00:48:04,701 --> 00:48:05,868
ain't so easy to play now."

1205
00:48:05,868 --> 00:48:07,234
But it's the same idea.

1206
00:48:07,234 --> 00:48:10,868
The thing about a library is
if you did it right,

1207
00:48:10,868 --> 00:48:13,667
it looks
and feels incredibly simple.

1208
00:48:13,667 --> 00:48:16,634
And achieving that turns out
to be incredibly difficult.

1209
00:48:16,634 --> 00:48:19,300
And it's worth it because
of the economies of scale.

1210
00:48:19,300 --> 00:48:21,267
You write these things once

1211
00:48:21,267 --> 00:48:24,968
and they're used by millions
of people for tens of years.

1212
00:48:24,968 --> 00:48:27,567
And that's why it's worth
putting so much effort

1213
00:48:27,567 --> 00:48:30,267
into libraries, you know,
because you have this tremendous

1214
00:48:30,267 --> 00:48:31,667
economy of scale.

1215
00:48:31,667 --> 00:48:34,667
And you can't afford to apply,
uh, that much effort

1216
00:48:34,667 --> 00:48:36,067
to the system
that you're building.

1217
00:48:36,067 --> 00:48:38,000
You know, does that mean
you--you can't make

1218
00:48:38,000 --> 00:48:39,701
a mission critical system
that works?

1219
00:48:39,701 --> 00:48:41,200
No, it doesn't mean that.

1220
00:48:41,200 --> 00:48:43,200
But the thing about
your system is

1221
00:48:43,200 --> 00:48:44,934
it doesn't have millions
of programmers

1222
00:48:44,934 --> 00:48:47,667
are gonna confronted
with actually using those APIs.

1223
00:48:47,667 --> 00:48:49,601
So if the APIs are a little bit
more difficult to use,

1224
00:48:49,601 --> 00:48:51,234
it's not the end
of the world.

1225
00:48:51,234 --> 00:48:53,767
If his are a little bit
more difficult to use, you know,

1226
00:48:53,767 --> 00:48:57,000
multiply the pain
by the millions of programmers

1227
00:48:57,000 --> 00:48:58,701
who are gonna use them
over the years

1228
00:48:58,701 --> 00:49:00,200
that they're gonna be
using them.

1229
00:49:00,200 --> 00:49:01,400
And--and furthermore,

1230
00:49:01,400 --> 00:49:03,634
if you can make them
just a tiny bit faster,

1231
00:49:03,634 --> 00:49:05,000
they're in people's
inner loop.

1232
00:49:05,000 --> 00:49:06,400
This is inner loop code.

1233
00:49:06,400 --> 00:49:09,200
So, you know, all the time
we talk about

1234
00:49:09,200 --> 00:49:10,868
don't prematurely optimize.

1235
00:49:10,868 --> 00:49:13,901
In this case, you know,
we actually have to optimize.

1236
00:49:13,901 --> 00:49:15,133
And it's not premature.

1237
00:49:15,133 --> 00:49:17,734
We know upfront
this is inner loop code.

1238
00:49:19,534 --> 00:49:21,501
Bourrillion: Anyone else?

1239
00:49:21,501 --> 00:49:22,834
man: Time for two more
questions.

1240
00:49:22,834 --> 00:49:25,234
I just wanted to get queued up
to do the raffle.

1241
00:49:25,234 --> 00:49:27,200
Just as a--
just as a segue though,

1242
00:49:27,200 --> 00:49:29,767
you mentioned several times
about IntelliJ IDEA.

1243
00:49:29,767 --> 00:49:32,267
The one thing we're raffling
off tonight is a free license

1244
00:49:32,267 --> 00:49:34,334
to IntelliJ IDEA so...

1245
00:49:34,334 --> 00:49:36,100
Bourrillion: I would be lost
without it.

1246
00:49:36,100 --> 00:49:37,300
man: Cool.

1247
00:49:37,300 --> 00:49:38,467
man: I just wanted to...

1248
00:49:38,467 --> 00:49:40,200
man: People that worked
on a project?

1249
00:49:40,200 --> 00:49:41,334
man: Oh, I'm sorry.

1250
00:49:41,334 --> 00:49:43,534
This is everyone who registered
in advance.

1251
00:49:43,534 --> 00:49:44,667
When we do the raffle,

1252
00:49:44,667 --> 00:49:47,100
the spinner is actually
written in JavaFX.

1253
00:49:47,100 --> 00:49:48,467
Woo-hoo.

1254
00:49:48,467 --> 00:49:50,567
Bourrillion: The--the list
of people who have contributed

1255
00:49:50,567 --> 00:49:52,367
meaningfully to our project
would probably have

1256
00:49:52,367 --> 00:49:53,901
just about that many names
on it though.

1257
00:49:53,901 --> 00:49:55,734
Although it's a long
tail effect.

1258
00:49:55,734 --> 00:49:59,534
But because of the open, uh,
sort of development process

1259
00:49:59,534 --> 00:50:00,734
that we have
in the mailing lists

1260
00:50:00,734 --> 00:50:02,467
that anyone can join
and participate in any

1261
00:50:02,467 --> 00:50:04,601
of our discussions
and every line of code

1262
00:50:04,601 --> 00:50:05,834
that we write gets,
you know,

1263
00:50:05,834 --> 00:50:08,200
emailed out and discussed
to death on these lists.

1264
00:50:08,200 --> 00:50:10,400
So I can't even properly
thank all the people

1265
00:50:10,400 --> 00:50:12,501
that I--that I should
be thanking.

1266
00:50:12,501 --> 00:50:13,868
Uh, but certainly, uh,

1267
00:50:13,868 --> 00:50:16,501
Josh has been our biggest
spiritual advisor.

1268
00:50:16,501 --> 00:50:18,834
And, uh, Jared,
who may have slipped out,

1269
00:50:18,834 --> 00:50:20,467
has written--
oh, there's Jared--

1270
00:50:20,467 --> 00:50:21,901
has written most of the code.

1271
00:50:21,901 --> 00:50:25,634
And, uh, and Jesse's been
a huge help--back there.

1272
00:50:25,634 --> 00:50:27,467
And, uh, some other people
at other offices

1273
00:50:27,467 --> 00:50:29,167
who aren't able to be here.

1274
00:50:29,167 --> 00:50:30,968
Did I just snub anyone?

1275
00:50:35,767 --> 00:50:37,801
man: Can--I just wanted
to make my comment

1276
00:50:37,801 --> 00:50:40,534
that I very much appreciate
your work

1277
00:50:40,534 --> 00:50:43,200
especially with the java.util
collections library.

1278
00:50:43,200 --> 00:50:45,434
And I know that you put
a lot of work into it.

1279
00:50:45,434 --> 00:50:48,534
And I use it all the time.
And I value it very highly.

1280
00:50:48,534 --> 00:50:52,901
And this stuff looks fantastic.
So, uh, so thank you.

1281
00:50:52,901 --> 00:50:54,200
Bourrillion: Thank you.

1282
00:50:54,200 --> 00:50:59,934
[applause]

1283
00:50:59,934 --> 00:51:01,634
You wouldn't believe
how infrequently

1284
00:51:01,634 --> 00:51:03,734
people bother to say things
like that.

1285
00:51:03,734 --> 00:51:05,367
So thank you.

1286
00:51:05,367 --> 00:51:07,100
man: Yes. Thank you very much,
Kevin.

1287
00:51:07,100 --> 00:51:11,200
Uh, so, I-I actually did not
do one of the announcements

1288
00:51:11,200 --> 00:51:12,334
at the beginning.

1289
00:51:12,334 --> 00:51:14,400
Um, there was someone here
from QCon,

1290
00:51:14,400 --> 00:51:15,667
but they weren't able
to stay.

1291
00:51:15,667 --> 00:51:18,601
So the QCon conference
coming up in November--

1292
00:51:18,601 --> 00:51:20,767
Uh, I guess I should have said
that my favorite conference

1293
00:51:20,767 --> 00:51:23,100
locally is--in September--

1294
00:51:23,100 --> 00:51:25,133
is--is the Rich Web
Experience.

1295
00:51:25,133 --> 00:51:27,234
But my favorite con--
well, I can't even say that.

1296
00:51:27,234 --> 00:51:28,567
But it is a good conference.

1297
00:51:28,567 --> 00:51:29,734
I haven't been to QCon.

1298
00:51:29,734 --> 00:51:31,200
But if you look
at the speaker list,

1299
00:51:31,200 --> 00:51:32,868
it's just really impressive.

1300
00:51:32,868 --> 00:51:35,100
So I have some, um,
handouts here

1301
00:51:35,100 --> 00:51:37,968
that have a promotion code
for $100 off.

1302
00:51:37,968 --> 00:51:39,300
If you think you're at all
interested

1303
00:51:39,300 --> 00:51:41,501
or if you know someone
who might be, please take one.

1304
00:51:41,501 --> 00:51:47,434
Uh, and next meeting,
the--the JUG user meeting,

1305
00:51:47,434 --> 00:51:49,267
uh, on the 18th
with Rod Johnson,

1306
00:51:49,267 --> 00:51:52,267
she'll be coming back since she
wasn't able to do it tonight

1307
00:51:52,267 --> 00:51:53,667
and we'll be raffling off
one free pass

1308
00:51:53,667 --> 00:51:55,000
to that conference.

1309
00:51:55,000 --> 00:51:57,634
And it's, uh,
I don't know what it goes for,

1310
00:51:57,634 --> 00:51:59,434
but that--that's at least
in excess

1311
00:51:59,434 --> 00:52:03,100
of $500 conference
so, uh...

1312
00:52:03,100 --> 00:52:05,467
And besides, it's Rod Johnson,
so you gotta come back.

1313
00:52:05,467 --> 00:52:06,534
[laughs]

1314
00:52:06,534 --> 00:52:07,834
So let's just do
the raffle now

1315
00:52:07,834 --> 00:52:10,367
for the IntelliJ IDEA
license.

1316
00:52:10,367 --> 00:52:12,968
Um, you have to be here
to win.

1317
00:52:12,968 --> 00:52:14,167
And so we'll keep going.

1318
00:52:14,167 --> 00:52:16,200
And if you really won't use it,
just say so,

1319
00:52:16,200 --> 00:52:18,167
and we'll spin again.

1320
00:52:18,167 --> 00:52:20,234
But you really should use it
if you haven't been already.

1321
00:52:20,234 --> 00:52:21,734
man: Put these
on the back table.

1322
00:52:21,734 --> 00:52:22,834
man: Okay. Great.

1323
00:52:22,834 --> 00:52:24,033
man: These'll be
on the back table

1324
00:52:24,033 --> 00:52:25,400
if you're interested.

1325
00:52:25,400 --> 00:52:27,801
man: And--and so
we're spinning.

1326
00:52:27,801 --> 00:52:28,801
[laughs]

1327
00:52:28,801 --> 00:52:30,000
man: Who wrote this?

1328
00:52:30,000 --> 00:52:31,534
man: Uh, Jim Weaver wrote
the original code.

1329
00:52:31,534 --> 00:52:32,667
We tweaked it a little--

1330
00:52:32,667 --> 00:52:34,133
actually, Kevin tweaked it
a little bit.

1331
00:52:34,133 --> 00:52:35,934
man: It's me. Oh!

1332
00:52:35,934 --> 00:52:39,567
man: And the winner
is Oswald!

1333
00:52:39,567 --> 00:52:42,701
Where are you, Oswald?
Did he leave?

1334
00:52:42,701 --> 00:52:44,200
He was here.

1335
00:52:44,200 --> 00:52:45,701
man: Oh, we gotta give it
to him.

1336
00:52:45,701 --> 00:52:47,501
man: Oh, no, you have to be
present to win

1337
00:52:47,501 --> 00:52:48,567
even though we know
the person.

1338
00:52:48,567 --> 00:52:49,601
man: Oswald's a good guy.

1339
00:52:49,601 --> 00:52:50,834
man: He's actually someone

1340
00:52:50,834 --> 00:52:52,300
who's been a great supporter
of the group.

1341
00:52:52,300 --> 00:52:54,501
But I'll just have to--
I'll have to run again.

1342
00:52:54,501 --> 00:52:55,634
He's gonna be bummed.

1343
00:52:55,634 --> 00:52:57,868
He probably already has
a license actually.

1344
00:52:59,000 --> 00:53:01,200
man: I bet I can get him one
anyway.

1345
00:53:01,200 --> 00:53:02,968
[laughter]

1346
00:53:09,133 --> 00:53:10,834
man: Stephen!
Are you here, Stephen?

1347
00:53:10,834 --> 00:53:13,033
All right,
another long-time regular.

1348
00:53:13,033 --> 00:53:15,400
Cool. So we'll just
have to get your email

1349
00:53:15,400 --> 00:53:18,133
and we'll--we send your name
and email to them

1350
00:53:18,133 --> 00:53:19,634
and then they set you up.

1351
00:53:19,634 --> 00:53:21,767
Okay, so if you come back
on the 18th,

1352
00:53:21,767 --> 00:53:23,100
we'll have another license--

1353
00:53:23,100 --> 00:53:25,334
you'll have another, like,
1 in 100 odds chance

1354
00:53:25,334 --> 00:53:27,200
to win a license
to IntelliJ.

1355
00:53:27,200 --> 00:53:28,534
[laughs]

1356
00:53:28,534 --> 00:53:30,734
All right. Thank you.
Thank you for coming.

