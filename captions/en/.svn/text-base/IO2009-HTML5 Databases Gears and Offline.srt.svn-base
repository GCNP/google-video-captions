1
00:00:01,300 --> 00:00:04,267
Kroeger: So good afternoon.
My name is Robert Kroeger,

2
00:00:04,267 --> 00:00:05,734
and I'm gonna talk
to you about

3
00:00:05,734 --> 00:00:10,033
caching patterns for building
offline web applications.

4
00:00:10,033 --> 00:00:15,000
Um, where did my slide go?

5
00:00:15,000 --> 00:00:17,200
There we go.

6
00:00:17,200 --> 00:00:21,868
Um, this is, uh--

7
00:00:21,868 --> 00:00:24,834
This is the sort of
design pattern we use

8
00:00:24,834 --> 00:00:26,934
underneath the mobile
GMAIL application

9
00:00:26,934 --> 00:00:30,167
that you might have seen
on the iPhone or the Android.

10
00:00:30,167 --> 00:00:33,167
So of course,
first question is

11
00:00:33,167 --> 00:00:36,701
why build a mobile
web application at all,

12
00:00:36,701 --> 00:00:39,334
you know, instead of, say,
a native application that runs

13
00:00:39,334 --> 00:00:41,033
directly on the phone?

14
00:00:41,033 --> 00:00:42,634
Web applications,
they tend to have

15
00:00:42,634 --> 00:00:46,000
two large advantages that
Vic alluded to this morning

16
00:00:46,000 --> 00:00:47,434
in the keynote.

17
00:00:47,434 --> 00:00:49,767
First off,
phones are pretty small.

18
00:00:49,767 --> 00:00:51,934
I mean, our phone is,
you know--

19
00:00:51,934 --> 00:00:53,701
it's better than
the Unix work station

20
00:00:53,701 --> 00:00:55,434
I had on my desk
ten years ago.

21
00:00:55,434 --> 00:00:59,200
But it's still really tiny
compared to our data center.

22
00:00:59,200 --> 00:01:01,667
You just can't run the kinds
of apps on the phone

23
00:01:01,667 --> 00:01:04,367
that you might like to.

24
00:01:04,367 --> 00:01:06,200
Another problem
with the phone--

25
00:01:06,200 --> 00:01:07,467
with building native apps--

26
00:01:07,467 --> 00:01:10,267
is that it's hard
to distribute phones.

27
00:01:10,267 --> 00:01:12,133
So much easier to distribute
a web app.

28
00:01:12,133 --> 00:01:14,701
There's no app store
approval process.

29
00:01:14,701 --> 00:01:16,367
You know what
I'm talking about.

30
00:01:16,367 --> 00:01:18,868
You'll get to launch
on the schedule you pick.

31
00:01:18,868 --> 00:01:20,901
You don't have to wait
for someone else to decide

32
00:01:20,901 --> 00:01:24,634
that it's okay to have your code
on their device.

33
00:01:24,634 --> 00:01:26,701
There's no mobile provider
in the way.

34
00:01:26,701 --> 00:01:29,033
And you can update frequently
and fix bugs.

35
00:01:29,033 --> 00:01:30,300
Maybe even weekly.

36
00:01:30,300 --> 00:01:33,400
Maybe even daily,
like we have had to do lately.

37
00:01:33,400 --> 00:01:37,300
Um, the problem is that
sometimes

38
00:01:37,300 --> 00:01:40,334
building a mobile web app
is kind of slow.

39
00:01:40,334 --> 00:01:42,334
You know, I mean,
the server has a nice,

40
00:01:42,334 --> 00:01:45,067
fat connection to the internet.

41
00:01:45,067 --> 00:01:47,434
But the phone has
a little, skinny,

42
00:01:47,434 --> 00:01:49,667
not-so-fat connection
to the internet

43
00:01:49,667 --> 00:01:52,234
over EDGE or 3G.

44
00:01:52,234 --> 00:01:54,701
And there's two problems
to this connection.

45
00:01:54,701 --> 00:01:58,234
The first is it can be
very high latency.

46
00:01:58,234 --> 00:02:01,667
It can take seconds to establish
a radio connection.

47
00:02:01,667 --> 00:02:04,968
And the other big problem
with this is it comes and goes.

48
00:02:04,968 --> 00:02:07,267
I don't know if you ever tried
web browsing on MUNI

49
00:02:07,267 --> 00:02:09,400
or on any other
public transit system,

50
00:02:09,400 --> 00:02:12,000
but sometimes
it's going along great,

51
00:02:12,000 --> 00:02:13,634
and then all of a sudden
it's, like, oop,

52
00:02:13,634 --> 00:02:15,567
no signal, no signal.

53
00:02:15,567 --> 00:02:17,133
And this is king of
disappointing,

54
00:02:17,133 --> 00:02:21,167
especially if you application is
synchronously connected

55
00:02:21,167 --> 00:02:23,734
to a server over the pipe.

56
00:02:23,734 --> 00:02:25,501
So how can we fix this?

57
00:02:25,501 --> 00:02:27,267
We fix this,
at least in mobile GMAIL,

58
00:02:27,267 --> 00:02:29,000
with caching.

59
00:02:29,000 --> 00:02:34,067
We wanted to split the--
split the UI

60
00:02:34,067 --> 00:02:36,801
from being dependent,
synchronously,

61
00:02:36,801 --> 00:02:38,934
on a connection to the server.

62
00:02:38,934 --> 00:02:41,934
And we did this by inserting
a big green cache--

63
00:02:41,934 --> 00:02:44,701
that's a pun,
and it's kinds bad--I'm sorry--

64
00:02:44,701 --> 00:02:49,834
between the actual UI
and the rest of the system.

65
00:02:49,834 --> 00:02:53,067
So you see that at the bottom
of the lower diagram

66
00:02:53,067 --> 00:02:55,701
where we've placed this cache
that's connected to the UI.

67
00:02:55,701 --> 00:02:59,000
And so as a result,
UI updates needed

68
00:02:59,000 --> 00:03:00,634
to repaint the user interface,

69
00:03:00,634 --> 00:03:03,467
they come out of the cache,
they go to the UI.

70
00:03:03,467 --> 00:03:07,434
And obviously the user makes
modifications to the,

71
00:03:07,434 --> 00:03:09,334
you know, the state
of the application.

72
00:03:09,334 --> 00:03:12,033
That gets written
into the cache.

73
00:03:12,033 --> 00:03:13,601
And we have this nice
little loop

74
00:03:13,601 --> 00:03:16,501
that's entirely local
from the user interface

75
00:03:16,501 --> 00:03:18,534
to the cache and back.

76
00:03:18,534 --> 00:03:20,534
And then, of course,
the cache--

77
00:03:20,534 --> 00:03:22,501
Asynchronous [indistinct]
user's interaction

78
00:03:22,501 --> 00:03:23,767
with the system

79
00:03:23,767 --> 00:03:26,067
pushes these changes
to the server,

80
00:03:26,067 --> 00:03:30,934
and, of course,
responses come...oops--

81
00:03:30,934 --> 00:03:34,434
sorry--
come back from the server

82
00:03:34,434 --> 00:03:37,067
and get written to the cache.

83
00:03:37,067 --> 00:03:40,100
And the cache has to
merge all this together.

84
00:03:40,100 --> 00:03:43,067
And so we've divided
our application up

85
00:03:43,067 --> 00:03:45,200
into a part that's local
and synchronous,

86
00:03:45,200 --> 00:03:48,067
and a part that is asynchronous
and involves

87
00:03:48,067 --> 00:03:49,801
the connection to that work.

88
00:03:49,801 --> 00:03:52,601
So let's look inside
the green box--

89
00:03:52,601 --> 00:03:54,334
the cache pattern itself.

90
00:03:54,334 --> 00:03:59,567
So it has four basic
data flows on the left side.

91
00:03:59,567 --> 00:04:02,300
The red ones are the data flows
to the user interface

92
00:04:02,300 --> 00:04:05,868
that are intended to be
reasonably fast and immediate.

93
00:04:05,868 --> 00:04:09,234
And on the right we have
the sort of asynchronous,

94
00:04:09,234 --> 00:04:13,934
arbitrary latency interactions
with the server.

95
00:04:13,934 --> 00:04:16,434
But, you know, we need a place
to keep all the data

96
00:04:16,434 --> 00:04:18,334
that we're storing
in this cache.

97
00:04:18,334 --> 00:04:21,901
And so, you know,
where do we keep it?

98
00:04:21,901 --> 00:04:23,634
We want some kind of
persistent storage

99
00:04:23,634 --> 00:04:25,667
in the browser itself.

100
00:04:25,667 --> 00:04:29,067
And that brings us
to structured storage.

101
00:04:29,067 --> 00:04:31,767
So HTML 5 and Gears
they're both--

102
00:04:31,767 --> 00:04:33,767
they both add some kind
of structured storage

103
00:04:33,767 --> 00:04:35,067
to the browser.

104
00:04:35,067 --> 00:04:36,634
And structured storage is
really great

105
00:04:36,634 --> 00:04:37,968
for implementing this cache.

106
00:04:37,968 --> 00:04:40,501
It's a largely complete
SQL database.

107
00:04:40,501 --> 00:04:42,567
And it's all
on the mobile device,

108
00:04:42,567 --> 00:04:45,133
so you don't have to go off
over the network to fetch it.

109
00:04:45,133 --> 00:04:46,868
And we can actually
get to it

110
00:04:46,868 --> 00:04:49,367
even if we don't have
a network connection at all.

111
00:04:49,367 --> 00:04:51,968
Um...

112
00:04:51,968 --> 00:04:55,200
And you know, it has
two really great properties.

113
00:04:55,200 --> 00:04:57,167
First off is it's persistent.

114
00:04:57,167 --> 00:04:59,334
If the browser crashes
or is terminated

115
00:04:59,334 --> 00:05:01,901
by the operating system
because you ran out of memory,

116
00:05:01,901 --> 00:05:03,367
it's still all there.

117
00:05:03,367 --> 00:05:04,801
All your edits stay there

118
00:05:04,801 --> 00:05:07,167
in the persistent structured
storage.

119
00:05:07,167 --> 00:05:08,767
And, of course,
it also implements

120
00:05:08,767 --> 00:05:11,634
the sort of standard database
ACD properties.

121
00:05:11,634 --> 00:05:15,067
You know, atomic
and consistent and durable,

122
00:05:15,067 --> 00:05:17,467
and all that goodness
that they taught us

123
00:05:17,467 --> 00:05:18,968
long ago in computer science
class.

124
00:05:18,968 --> 00:05:22,701
And that's also really helpful
in the case of, "Hey, look.

125
00:05:22,701 --> 00:05:25,267
The operating system
just tossed the browser."

126
00:05:25,267 --> 00:05:28,767
So that way you don't lose
your edits.

127
00:05:28,767 --> 00:05:30,133
Now, there's a problem,

128
00:05:30,133 --> 00:05:33,033
and the problem is that
HTML 5 and Gears have

129
00:05:33,033 --> 00:05:36,200
really quite radically different
programming models

130
00:05:36,200 --> 00:05:39,300
for how to get access
to the structured store.

131
00:05:39,300 --> 00:05:42,334
Gears has a synchronous
interface to the database.

132
00:05:42,334 --> 00:05:43,634
So what does that mean?

133
00:05:43,634 --> 00:05:44,834
It means that you have
the nice little

134
00:05:44,834 --> 00:05:47,000
JavaScript thread
running your code.

135
00:05:47,000 --> 00:05:49,834
And when you want to make a call
with Gears Call

136
00:05:49,834 --> 00:05:51,434
to fetch data
out of the database--

137
00:05:51,434 --> 00:05:53,667
You can make a function call
into Gears.

138
00:05:53,667 --> 00:05:56,367
That's the sort of red
database action code there

139
00:05:56,367 --> 00:05:57,868
in the top diagram.

140
00:05:57,868 --> 00:06:00,634
And then the Gears code
processes.

141
00:06:00,634 --> 00:06:03,467
And then it returns
in the standard kind of,

142
00:06:03,467 --> 00:06:05,868
you know, UNIX-system-y call
kind of way

143
00:06:05,868 --> 00:06:09,400
to the calling JavaScript
thread.

144
00:06:09,400 --> 00:06:11,567
HTML 5 is different.

145
00:06:11,567 --> 00:06:13,667
You know,
it starts out the same.

146
00:06:13,667 --> 00:06:15,934
The JavaScript code
makes a call

147
00:06:15,934 --> 00:06:19,467
to the, um--

148
00:06:19,467 --> 00:06:21,734
to an underlying,
or a SQL thread,

149
00:06:21,734 --> 00:06:23,400
that runs database actions.

150
00:06:23,400 --> 00:06:27,100
But that sort of runs separately
and independently.

151
00:06:27,100 --> 00:06:31,801
And it--it doesn't return data
to the JavaScript.

152
00:06:31,801 --> 00:06:34,534
Instead it calls back
into the JavaScript

153
00:06:34,534 --> 00:06:36,434
at some arbitrary point later.

154
00:06:36,434 --> 00:06:39,501
Now, this is sometimes
harder to program,

155
00:06:39,501 --> 00:06:42,367
but it also has the advantage
that other JavaScript,

156
00:06:42,367 --> 00:06:51,200
like button clicks,
can happen in the meantime.

157
00:06:51,200 --> 00:06:53,000
So we can kind of sum up
this difference

158
00:06:53,000 --> 00:06:55,367
in this nice little table here.

159
00:06:55,367 --> 00:06:59,501
On the Android device,
we get SQL databases,

160
00:06:59,501 --> 00:07:01,267
we get via Gears.

161
00:07:01,267 --> 00:07:02,968
So it's a synchronous
programming model.

162
00:07:02,968 --> 00:07:07,367
And on the iPhone we get
HTML 5 databases

163
00:07:07,367 --> 00:07:08,834
that are asynchronous.

164
00:07:08,834 --> 00:07:11,501
And so in, you know,
that little red problem area,

165
00:07:11,501 --> 00:07:16,133
we can't have structured storage
on both platforms the same way

166
00:07:16,133 --> 00:07:19,501
that have different
programming models--it's a pain.

167
00:07:19,501 --> 00:07:21,334
So we have a solution
for this.

168
00:07:21,334 --> 00:07:24,133
It's something we call the
Web Storage Portability Layer,

169
00:07:24,133 --> 00:07:26,334
which is a long descriptive
name, and I know it's too long.

170
00:07:26,334 --> 00:07:29,200
And I'm gonna frequently say
WSPL instead.

171
00:07:29,200 --> 00:07:33,501
Um, WSPL,
you write your cache,

172
00:07:33,501 --> 00:07:37,667
or any other kind of structured
storage web application,

173
00:07:37,667 --> 00:07:40,200
to a single common
programming model.

174
00:07:40,200 --> 00:07:43,300
And on HTML 5 devices,

175
00:07:43,300 --> 00:07:44,934
the nice little wrapper
translates that

176
00:07:44,934 --> 00:07:47,167
into HTML 5 calls.

177
00:07:47,167 --> 00:07:50,133
And on Gears we emulate the
asynchronous programming model

178
00:07:50,133 --> 00:07:53,167
with a Gears worker
that runs asynchronously

179
00:07:53,167 --> 00:07:55,734
to the mainline thread
and does all the database--

180
00:07:55,734 --> 00:07:59,367
all the synchronous
database actions using Gears.

181
00:07:59,367 --> 00:08:01,300
And this is, uh--

182
00:08:01,300 --> 00:08:03,934
You know, as of yesterday,
this is now open-sourced

183
00:08:03,934 --> 00:08:11,000
from code.google.com/p/
webstorageportabilitylayer.

184
00:08:11,000 --> 00:08:13,434
And I encourage you
to go have a look.

185
00:08:13,434 --> 00:08:15,567
And eventually the material
in these slides,

186
00:08:15,567 --> 00:08:22,767
at least some of it,
will get added to that site.

187
00:08:22,767 --> 00:08:26,334
So thanks to this WSPL layer,
we have solved the whole

188
00:08:26,334 --> 00:08:29,767
"where to keep the data" that
we want to put in our cache.

189
00:08:29,767 --> 00:08:34,968
We keep it in some kind of
arbitrary WSPL-wrapped database

190
00:08:34,968 --> 00:08:37,868
that sits underneath
our web application.

191
00:08:37,868 --> 00:08:42,000
And you'll see
there's two arrows

192
00:08:42,000 --> 00:08:46,000
going into and out of
the WSPL layer in the picture.

193
00:08:46,000 --> 00:08:48,234
And this is because
WSPL has to provide

194
00:08:48,234 --> 00:08:49,834
an asynchronous programming
model

195
00:08:49,834 --> 00:08:52,033
to be compatible
with HTML 5.

196
00:08:52,033 --> 00:08:54,934
And so the one arrow going into
the WSPL layer,

197
00:08:54,934 --> 00:08:56,834
those are calls
from the cache.

198
00:08:56,834 --> 00:09:00,701
And then there's callbacks.
That's the other arrow.

199
00:09:00,701 --> 00:09:04,367
So the underlying kind
of mechanism is taken care of.

200
00:09:04,367 --> 00:09:08,033
We talked about, sort of,
the cache structure.

201
00:09:08,033 --> 00:09:10,801
And this is very much
the architectural pattern

202
00:09:10,801 --> 00:09:12,534
that is found in mobile GMAIL.

203
00:09:12,534 --> 00:09:15,267
Albeit with some tweaks
and differences.

204
00:09:15,267 --> 00:09:18,334
We can talk about
the cache pattern in detail.

205
00:09:18,334 --> 00:09:20,901
So it's kind of busy,
so sorry.

206
00:09:20,901 --> 00:09:23,334
But you know, there's--
It's not that--

207
00:09:23,334 --> 00:09:25,834
It's pretty complicated
in some ways.

208
00:09:25,834 --> 00:09:28,133
The first thing that you'll see
is I've doubled up

209
00:09:28,133 --> 00:09:29,334
all the arrows

210
00:09:29,334 --> 00:09:32,601
because, you know,
the interface to the WSPL

211
00:09:32,601 --> 00:09:34,534
has just, you know,
one call one way,

212
00:09:34,534 --> 00:09:35,801
and then a call the other way.

213
00:09:35,801 --> 00:09:39,400
And so all the other interfaces
on this cache structure

214
00:09:39,400 --> 00:09:41,467
have to be bi-directional
as well.

215
00:09:41,467 --> 00:09:45,634
So I've also given
each of these calls names.

216
00:09:45,634 --> 00:09:47,934
And that's because
there's a demo app

217
00:09:47,934 --> 00:09:50,167
that comes with the WSPL
distribution

218
00:09:50,167 --> 00:09:51,934
that I called "Simple Notes"

219
00:09:51,934 --> 00:09:54,334
that actually uses these names
in the code.

220
00:09:54,334 --> 00:09:57,634
So you take, for example,
"Get" values--

221
00:09:57,634 --> 00:10:00,067
that is a call from the UI--

222
00:10:00,067 --> 00:10:02,234
into the cache to get content.

223
00:10:02,234 --> 00:10:05,267
And then there's a callback--
a value callback--

224
00:10:05,267 --> 00:10:07,501
logically enough,
that delivers the content

225
00:10:07,501 --> 00:10:15,901
from the cache
back to the user interface.

226
00:10:15,901 --> 00:10:18,234
So what about this
Simple Notes thing?

227
00:10:18,234 --> 00:10:21,567
So the simple point
of Simple Notes is essentially

228
00:10:21,567 --> 00:10:24,200
just to make all this
more concrete,

229
00:10:24,200 --> 00:10:27,434
and to demonstrate the use
of WSPL,

230
00:10:27,434 --> 00:10:29,701
and to provide sort
of a concrete,

231
00:10:29,701 --> 00:10:32,801
somewhat simplified
"getting started" implementation

232
00:10:32,801 --> 00:10:35,400
of the cache
that people are free to use.

233
00:10:35,400 --> 00:10:37,934
You can extend it
any way you want.

234
00:10:37,934 --> 00:10:42,300
First off, Simple Notes
is really a toy application.

235
00:10:42,300 --> 00:10:45,567
And, because, you know,
I had too many years

236
00:10:45,567 --> 00:10:46,968
of college math.

237
00:10:46,968 --> 00:10:51,567
The server side is an exercise
for the audience.

238
00:10:51,567 --> 00:10:56,200
And the first person
who writes it gets some swag.

239
00:10:56,200 --> 00:10:58,033
And you should go
to the app engine talk

240
00:10:58,033 --> 00:10:59,100
and learn how.

241
00:10:59,100 --> 00:11:00,400
Now...
[chuckles]

242
00:11:00,400 --> 00:11:02,734
with that little Tom Sawyer
moment out of the way,

243
00:11:02,734 --> 00:11:05,901
Simple Notes has
three basic pages.

244
00:11:05,901 --> 00:11:07,834
They're essentially just
different divs.

245
00:11:07,834 --> 00:11:10,801
And they're hidden and displayed
by the appropriate

246
00:11:10,801 --> 00:11:12,601
CSS modification.

247
00:11:12,601 --> 00:11:14,667
There's a "list notes" page.

248
00:11:14,667 --> 00:11:17,400
There's a "show
and entire note" page.

249
00:11:17,400 --> 00:11:22,367
And then, of course, and "edit
or create a new note" page.

250
00:11:22,367 --> 00:11:26,334
And Simple Notes itself
is really not very useful,

251
00:11:26,334 --> 00:11:29,701
but the cache component is
pretty much complete

252
00:11:29,701 --> 00:11:32,601
and is a good starting point
for building

253
00:11:32,601 --> 00:11:38,033
an arbitrary cached application.

254
00:11:38,033 --> 00:11:40,934
So there's some important
design aspects

255
00:11:40,934 --> 00:11:43,501
to how you you actually
implement a cache

256
00:11:43,501 --> 00:11:45,801
of the kind that
we're talking about here.

257
00:11:45,801 --> 00:11:49,200
And they all sort of come out
of the hardware literature.

258
00:11:49,200 --> 00:11:51,300
Because, you know, people have
been building caches

259
00:11:51,300 --> 00:11:53,167
and hardware for years.

260
00:11:53,167 --> 00:11:54,934
The first thing is
we need to know--

261
00:11:54,934 --> 00:11:56,634
we need to be able
to determine

262
00:11:56,634 --> 00:12:00,033
if a requested entity is
in the cache or not.

263
00:12:00,033 --> 00:12:02,701
So we need some kind of
hit determination mechanism.

264
00:12:02,701 --> 00:12:06,033
In Simple Notes we keep
a contiguous range of notes

265
00:12:06,033 --> 00:12:07,601
in the cache at all times.

266
00:12:07,601 --> 00:12:11,667
So it's pretty easy to decide
if we have a note in the cache.

267
00:12:11,667 --> 00:12:13,400
If it's between two--

268
00:12:13,400 --> 00:12:15,801
You know, if its index is
between a pair of numbers, yay.

269
00:12:15,801 --> 00:12:17,467
Otherwise,
we have to go fetch it.

270
00:12:17,467 --> 00:12:21,200
We also have to have
some refresh mechanism.

271
00:12:21,200 --> 00:12:25,701
We have to have some way
to know when to fetch content.

272
00:12:25,701 --> 00:12:28,667
New notes from the server,
and how to add them

273
00:12:28,667 --> 00:12:32,033
to the, um...to the cache.

274
00:12:32,033 --> 00:12:35,801
And what to do about, of course,
getting rid of the notes

275
00:12:35,801 --> 00:12:38,200
we don't need--
the eviction process.

276
00:12:38,200 --> 00:12:40,567
And finally, we need
a coherency mechanism.

277
00:12:40,567 --> 00:12:42,968
We have to figure out,
in the client,

278
00:12:42,968 --> 00:12:45,334
how to join server changes

279
00:12:45,334 --> 00:12:47,801
and user changes together
in the cache

280
00:12:47,801 --> 00:12:50,467
such that you don't lose
the user changes.

281
00:12:50,467 --> 00:12:55,801
And--
And they don't like that.

282
00:12:55,801 --> 00:13:00,868
So now some more details.

283
00:13:00,868 --> 00:13:03,167
So first off,
Simple Notes is implemented

284
00:13:03,167 --> 00:13:06,267
as two separate
database tables.

285
00:13:06,267 --> 00:13:10,267
You'll see it's pretty standard
SQL code there.

286
00:13:10,267 --> 00:13:17,067
Also you'll notice that
we use the WSPL statement object

287
00:13:17,067 --> 00:13:19,334
to wrap our SQL strings.

288
00:13:19,334 --> 00:13:20,868
This is just
a convenience thing

289
00:13:20,868 --> 00:13:23,200
to simplify
parameter substitution

290
00:13:23,200 --> 00:13:27,000
so that it works both
on Gears and HTML 5.

291
00:13:27,000 --> 00:13:31,067
And also, we have some
statements down at the bottom.

292
00:13:31,067 --> 00:13:33,834
Select statements to go
to the database

293
00:13:33,834 --> 00:13:36,167
and find out
what are the end points

294
00:13:36,167 --> 00:13:38,267
of the range of notes
that are in the cache.

295
00:13:38,267 --> 00:13:40,367
And so this is what would get--

296
00:13:40,367 --> 00:13:43,734
These two statements
would get creation statements

297
00:13:43,734 --> 00:13:45,601
to build a database.

298
00:13:45,601 --> 00:13:47,467
And, of course, finding
the end points of the cache

299
00:13:47,467 --> 00:13:51,434
happens at the setup
of the application.

300
00:13:51,434 --> 00:13:57,133
We chose to separate
the cache's backing store

301
00:13:57,133 --> 00:13:59,634
into these two
separate tables.

302
00:13:59,634 --> 00:14:03,434
Into a right buffer table
and a cash notes table

303
00:14:03,434 --> 00:14:06,467
in order to divide state
fro actions.

304
00:14:06,467 --> 00:14:08,901
The state is, you know,
sort of the model

305
00:14:08,901 --> 00:14:10,868
that the user's seeing
and interacting with.

306
00:14:10,868 --> 00:14:14,267
And the actions are things
that we need to preserve

307
00:14:14,267 --> 00:14:16,601
because we're sending them
to the server,

308
00:14:16,601 --> 00:14:21,000
or merging them with refreshes
that have come from the server.

309
00:14:21,000 --> 00:14:23,133
And by putting these
in two different tables,

310
00:14:23,133 --> 00:14:25,734
it provides a nice
simplification

311
00:14:25,734 --> 00:14:27,100
of the architecture.

312
00:14:27,100 --> 00:14:30,968
And this sort of arrangement
of a table of actions

313
00:14:30,968 --> 00:14:32,267
and a state table

314
00:14:32,267 --> 00:14:34,033
corresponds
to the hardware notion

315
00:14:34,033 --> 00:14:37,367
of a write-through cache, which
was kind of one of the simpler

316
00:14:37,367 --> 00:14:40,968
"read, modify, write"
hardware caches

317
00:14:40,968 --> 00:14:47,033
that one could build.

318
00:14:47,033 --> 00:14:49,667
Here's some code.

319
00:14:49,667 --> 00:14:52,701
And it's, well,
it's essentially just a setup.

320
00:14:52,701 --> 00:14:54,467
And this is all in distribution,

321
00:14:54,467 --> 00:14:56,968
so if you down load it,
you can have a look at this.

322
00:14:56,968 --> 00:15:00,701
It creates tables,
and it loads some triggers.

323
00:15:00,701 --> 00:15:02,801
And we'll talk about
the triggers shortly.

324
00:15:02,801 --> 00:15:05,334
And it determines, as I said,
what's already in the database.

325
00:15:05,334 --> 00:15:08,467
The last two "selects."

326
00:15:08,467 --> 00:15:11,400
So one of the things
that you should know about

327
00:15:11,400 --> 00:15:15,167
this piece of code
is the use of "execute all."

328
00:15:15,167 --> 00:15:18,434
This is a convenience function
we added in WSPL.

329
00:15:18,434 --> 00:15:22,801
So you can pass an array
of statements to the library

330
00:15:22,801 --> 00:15:24,467
and say,
"just go do all these."

331
00:15:24,467 --> 00:15:28,634
As opposed to, in HTML 5,
just out of the box,

332
00:15:28,634 --> 00:15:31,267
for every single
separate SQL statement,

333
00:15:31,267 --> 00:15:34,067
you have to have a call
to HTML 5

334
00:15:34,067 --> 00:15:37,400
to fire the correct piece
of SQL,

335
00:15:37,400 --> 00:15:39,868
and then a callback handler.

336
00:15:39,868 --> 00:15:42,534
And this just
made life simpler.

337
00:15:42,534 --> 00:15:46,601
Also notice that
asynchrony comes up even here. 

338
00:15:46,601 --> 00:15:50,701
We don't know if
we've actually completed

339
00:15:50,701 --> 00:15:53,567
the creation of the tables
and the addition of--

340
00:15:53,567 --> 00:15:56,200
and the addition
of the triggers, et cetera,

341
00:15:56,200 --> 00:15:58,801
until some callback is fired
from inside

342
00:15:58,801 --> 00:16:00,901
of the WSPL library.

343
00:16:00,901 --> 00:16:03,634
And so we can't tell the UI
that we're done

344
00:16:03,634 --> 00:16:06,234
without a callback
that we provide in the,

345
00:16:06,234 --> 00:16:08,868
you know,
the callback argument.

346
00:16:17,501 --> 00:16:19,667
So let's talk about
the sort of data flows

347
00:16:19,667 --> 00:16:21,968
through the cache
in a little more detail.

348
00:16:21,968 --> 00:16:24,767
Um, this is the case
of the "get values."

349
00:16:24,767 --> 00:16:27,667
Your sort of basic
give me something

350
00:16:27,667 --> 00:16:30,534
out of the cache query,
and get a response.

351
00:16:30,534 --> 00:16:33,367
And so the basic idea is
the UI will call into the cache

352
00:16:33,367 --> 00:16:36,167
to obtain, say, a note,
or a list of notes.

353
00:16:36,167 --> 00:16:42,534
And there's a whole sequence
of WSPL calls,

354
00:16:42,534 --> 00:16:45,234
or HTML 5 calls,
as the case may be,

355
00:16:45,234 --> 00:16:46,667
that are required
to implement that.

356
00:16:46,667 --> 00:16:47,701
See that at the bottom.

357
00:16:47,701 --> 00:16:50,167
We have to first create
a transaction,

358
00:16:50,167 --> 00:16:52,000
and then,
inside of the transaction,

359
00:16:52,000 --> 00:16:53,133
callback.

360
00:16:53,133 --> 00:16:54,968
We have to dispatch
some SQL statements

361
00:16:54,968 --> 00:16:56,534
and then get the results.

362
00:16:56,534 --> 00:16:59,834
And then, finally, once we've
accumulated all the results--

363
00:16:59,834 --> 00:17:02,367
with accumulated results,
of course--

364
00:17:02,367 --> 00:17:04,601
we forward the response--

365
00:17:04,601 --> 00:17:06,701
the complete, entire
result set--

366
00:17:06,701 --> 00:17:09,701
back to the UI for display.

367
00:17:09,701 --> 00:17:12,334
The implementation looks
a bit like this.

368
00:17:12,334 --> 00:17:14,701
This is just, essentially,
a wrapper

369
00:17:14,701 --> 00:17:17,501
that fires off
the right kind of, sort of,

370
00:17:17,501 --> 00:17:19,033
a larger helper method.

371
00:17:19,033 --> 00:17:22,934
And...

372
00:17:22,934 --> 00:17:24,667
There's two things
wrapped here.

373
00:17:24,667 --> 00:17:27,133
First is, you know,
get notes--a list of notes.

374
00:17:27,133 --> 00:17:30,234
And the other one is get
just one note.

375
00:17:30,234 --> 00:17:32,667
And get one note is
much simpler.

376
00:17:32,667 --> 00:17:34,467
It only has to obtain
one thing.

377
00:17:34,467 --> 00:17:37,133
And so we just kind of
skipped over it.

378
00:17:37,133 --> 00:17:42,167
So the code looks like this,
pretty much.

379
00:17:42,167 --> 00:17:48,334
So it starts...on...

380
00:17:48,334 --> 00:17:50,300
It starts about there, really.

381
00:17:50,300 --> 00:17:52,167
Starts in the middle.

382
00:17:52,167 --> 00:17:54,234
All the stuff above
is the definition

383
00:17:54,234 --> 00:17:56,601
of callback functions.

384
00:17:56,601 --> 00:18:00,100
And then the first thing
that the mainline code does

385
00:18:00,100 --> 00:18:02,634
is it creates the transaction,
like I said.

386
00:18:02,634 --> 00:18:06,400
And then that transaction is

387
00:18:06,400 --> 00:18:08,701
the "in transaction,
get notes" function

388
00:18:08,701 --> 00:18:11,200
that you see second
from the top

389
00:18:11,200 --> 00:18:13,534
in the list of callback
functions.

390
00:18:13,534 --> 00:18:16,767
And then,
inside that transaction,

391
00:18:16,767 --> 00:18:19,501
we run the "list cache notes"
SQL statement,

392
00:18:19,501 --> 00:18:20,901
which, of course,
just does a select

393
00:18:20,901 --> 00:18:24,234
over all the notes
in the database,

394
00:18:24,234 --> 00:18:25,968
and returns that.

395
00:18:25,968 --> 00:18:28,000
And then that gets
accumulated

396
00:18:28,000 --> 00:18:30,100
in the "accumulate results"
callback.

397
00:18:30,100 --> 00:18:33,501
So the...
inside the transaction,

398
00:18:33,501 --> 00:18:36,300
the SQL statement's sent
to the WSPL library.

399
00:18:36,300 --> 00:18:39,734
And then the callbacks aggregate
in the "array notes,"

400
00:18:39,734 --> 00:18:41,868
and then the transaction ends.

401
00:18:41,868 --> 00:18:45,501
So this little color diagram
at the bottom

402
00:18:45,501 --> 00:18:46,968
shows you the time sequence.

403
00:18:46,968 --> 00:18:49,167
We have the start
of the function in red.

404
00:18:49,167 --> 00:18:52,834
And then the transaction
boundary is defined

405
00:18:52,834 --> 00:18:54,601
by the sort of yellow region.

406
00:18:54,601 --> 00:18:56,801
And we can control
the transaction boundary

407
00:18:56,801 --> 00:18:59,367
by explicitly creating
the transaction,

408
00:18:59,367 --> 00:19:03,167
and providing a function to run
inside of that transaction.

409
00:19:03,167 --> 00:19:06,200
And then that first function
that's run inside

410
00:19:06,200 --> 00:19:07,601
of our transaction,

411
00:19:07,601 --> 00:19:10,634
it dispatches the SQL
that we want to have execute.

412
00:19:10,634 --> 00:19:13,901
And then the callback also runs
inside of the transaction,

413
00:19:13,901 --> 00:19:17,100
and could, in theory, dispatch
yet more SQL, et cetera.

414
00:19:17,100 --> 00:19:18,968
And then finally,

415
00:19:18,968 --> 00:19:21,200
when all the functions
that were invoked

416
00:19:21,200 --> 00:19:25,067
with a valid transaction object
have finished,

417
00:19:25,067 --> 00:19:28,200
then the transaction is closed,
and the changes, if any,

418
00:19:28,200 --> 00:19:31,400
are committed
to the database.

419
00:19:31,400 --> 00:19:33,901
So there was a little piece
of code in there

420
00:19:33,901 --> 00:19:36,767
where we determined if
something's in the cache or not.

421
00:19:36,767 --> 00:19:39,300
As I said earlier,
it's really very simple.

422
00:19:39,300 --> 00:19:41,934
In Simple Notes we just have
a list of notes,

423
00:19:41,934 --> 00:19:44,033
and we store their
end-point IDs.

424
00:19:44,033 --> 00:19:45,334
And if you're in the range,
yay.

425
00:19:45,334 --> 00:19:46,501
And if you're not
in the range,

426
00:19:46,501 --> 00:19:48,834
we must go fetch the note
from the server--

427
00:19:48,834 --> 00:19:54,133
or range of notes
from the server.

428
00:19:54,133 --> 00:19:59,000
The next piece of the cache is
handling user changes.

429
00:19:59,000 --> 00:20:01,367
So this is the case where
the user makes some chan--

430
00:20:01,367 --> 00:20:02,534
uh, modification.

431
00:20:02,534 --> 00:20:05,400
And we want to put that
into the right buffer,

432
00:20:05,400 --> 00:20:13,200
and then apply that result to
the actual state of the cache.

433
00:20:13,200 --> 00:20:16,567
And we actually do
the application of the change

434
00:20:16,567 --> 00:20:18,934
from the right buffer
to the cache state

435
00:20:18,934 --> 00:20:20,367
with a trigger.

436
00:20:20,367 --> 00:20:23,567
And then finally acknowledge
the change to the UI.

437
00:20:23,567 --> 00:20:27,234
And triggers are a very,
very useful function

438
00:20:27,234 --> 00:20:30,901
in SQL light
and HTML 5 and Gears.

439
00:20:30,901 --> 00:20:32,734
They really help improve
performance

440
00:20:32,734 --> 00:20:34,834
and simplify development.

441
00:20:34,834 --> 00:20:36,767
And as a result of the use
of triggers,

442
00:20:36,767 --> 00:20:40,734
the actual JavaScript code for
making a change to the cache--

443
00:20:40,734 --> 00:20:44,100
to a user UI change
is very simple.

444
00:20:44,100 --> 00:20:45,567
All it does is--

445
00:20:45,567 --> 00:20:47,734
A little piece of SQL
that inserts an action

446
00:20:47,734 --> 00:20:50,534
into the right buffer.

447
00:20:50,534 --> 00:20:54,667
Now, why use triggers...

448
00:20:54,667 --> 00:20:56,767
for a complicated update,

449
00:20:56,767 --> 00:21:00,667
like updating a cache state
from an entry

450
00:21:00,667 --> 00:21:03,434
in the right buffer?

451
00:21:03,434 --> 00:21:06,033
Triggers help avoid
ping-ponging,

452
00:21:06,033 --> 00:21:07,868
which can be very expensive.

453
00:21:07,868 --> 00:21:10,801
Rather than having the case
where, you see at the top,

454
00:21:10,801 --> 00:21:12,968
where we run a little bit
of JavaScript,

455
00:21:12,968 --> 00:21:16,100
start a transaction,
fire off some SQL...

456
00:21:16,100 --> 00:21:19,434
The database does some stuff.
The database calls back.

457
00:21:19,434 --> 00:21:21,868
The JavaScript does some stuff.

458
00:21:21,868 --> 00:21:24,033
You know, executes some more
JavaScript.

459
00:21:24,033 --> 00:21:26,834
Rather than have that sequence
of back and forth,

460
00:21:26,834 --> 00:21:30,133
instead, we have one
little piece of JavaScript

461
00:21:30,133 --> 00:21:33,234
that starts the process by,
you know,

462
00:21:33,234 --> 00:21:35,367
writing to the right buffer.

463
00:21:35,367 --> 00:21:37,167
And then the trigger does
all the work.

464
00:21:37,167 --> 00:21:38,734
The transaction's shorter.

465
00:21:38,734 --> 00:21:40,801
There's no need to go
back and forth

466
00:21:40,801 --> 00:21:42,234
between the threads.

467
00:21:42,234 --> 00:21:46,734
And it just runs vastly--
It runs vastly faster.

468
00:21:46,734 --> 00:21:50,267
It especially runs faster
if you're emulating this model

469
00:21:50,267 --> 00:21:52,801
of the two threads
with Gears workers.

470
00:21:52,801 --> 00:21:55,434
And this also--

471
00:21:55,434 --> 00:21:57,033
By making your transaction
shorter,

472
00:21:57,033 --> 00:21:59,667
you can work around a number
of somewhat nasty bugs

473
00:21:59,667 --> 00:22:02,934
in the HTML implementations
currently shipping.

474
00:22:02,934 --> 00:22:07,133
Um...

475
00:22:07,133 --> 00:22:10,934
so here's the actual
trigger code for Simple Notes.

476
00:22:10,934 --> 00:22:14,601
The triggers for mobile GMAIL
are much more complicated

477
00:22:14,601 --> 00:22:17,200
because you can do more
to your mail

478
00:22:17,200 --> 00:22:20,767
than just add a note
consisting of note text

479
00:22:20,767 --> 00:22:23,100
and a subject.

480
00:22:23,100 --> 00:22:24,667
But the basic idea is the same.

481
00:22:24,667 --> 00:22:26,167
You know, we have something
in the action queue,

482
00:22:26,167 --> 00:22:28,734
and copy it into the cache.

483
00:22:28,734 --> 00:22:31,000
Uh, the cache state, per se.

484
00:22:31,000 --> 00:22:32,901
There's two statements here.

485
00:22:32,901 --> 00:22:34,601
The first just does the copy,

486
00:22:34,601 --> 00:22:38,000
and the second updates some
state bits in the action queue

487
00:22:38,000 --> 00:22:40,300
to track that we've actually
done the copy

488
00:22:40,300 --> 00:22:42,234
so we don't do it
over and over again.

489
00:22:42,234 --> 00:22:47,334
Um, it's worth noting...

490
00:22:47,334 --> 00:22:51,467
that--well, it's worth noting
that the trigger's the only way

491
00:22:51,467 --> 00:22:53,767
to do a whole bunch
of SQL statements

492
00:22:53,767 --> 00:22:55,400
without this ping-pong process.

493
00:22:55,400 --> 00:22:58,901
It's the nicest way if you have
a whole bunch of SQL,

494
00:22:58,901 --> 00:22:59,901
and you just want it to run

495
00:22:59,901 --> 00:23:01,534
without worrying
about its result--

496
00:23:01,534 --> 00:23:03,267
it's the nicest way
to do that.

497
00:23:03,267 --> 00:23:07,734
Makes it--
It's the easiest way to write.

498
00:23:07,734 --> 00:23:12,801
The next sort of main flow
in the cache itself

499
00:23:12,801 --> 00:23:15,234
is insert update.

500
00:23:15,234 --> 00:23:18,300
And insert update is perhaps
the most complicated flow

501
00:23:18,300 --> 00:23:19,701
through the cache.

502
00:23:19,701 --> 00:23:22,334
It's the case where
we've received--

503
00:23:22,334 --> 00:23:24,767
The application--
the mobile app--

504
00:23:24,767 --> 00:23:27,167
has received content
from the server.

505
00:23:27,167 --> 00:23:29,200
And we have to combine
that content

506
00:23:29,200 --> 00:23:31,968
with the existing contents
of the cache

507
00:23:31,968 --> 00:23:35,100
and any changes
the user has made to the cache

508
00:23:35,100 --> 00:23:37,868
that haven't yet reached
the server.

509
00:23:37,868 --> 00:23:42,234
So the basic idea is
that it all starts

510
00:23:42,234 --> 00:23:45,567
as a result of the callback
on XHR.

511
00:23:45,567 --> 00:23:49,934
That's the insert update
in the top right.

512
00:23:49,934 --> 00:23:55,033
And then we do some work
to put all the changes

513
00:23:55,033 --> 00:23:56,300
into the cache.

514
00:23:56,300 --> 00:23:59,767
Once again, we use a trigger
to replay actions

515
00:23:59,767 --> 00:24:01,501
that have not yet reached
the server

516
00:24:01,501 --> 00:24:07,567
against the changes made
by the server on the cache.

517
00:24:07,567 --> 00:24:11,133
And finally, if this was all
in response to a cache miss,

518
00:24:11,133 --> 00:24:14,167
we have to send
the new updated results

519
00:24:14,167 --> 00:24:15,734
back to the UI.

520
00:24:15,734 --> 00:24:18,968
Because the UI will have been
waiting the entire time

521
00:24:18,968 --> 00:24:20,267
for this round trip
to the server

522
00:24:20,267 --> 00:24:24,734
if the desired value
is not actually cached.

523
00:24:24,734 --> 00:24:27,334
Now, it could have been doing
useful things in the meantime,

524
00:24:27,334 --> 00:24:28,701
but it wouldn't have
been able to show

525
00:24:28,701 --> 00:24:31,901
whatever that requested
entity was.

526
00:24:31,901 --> 00:24:35,501
So here's a sample of a code.

527
00:24:35,501 --> 00:24:37,968
Um...
[clears throat]

528
00:24:37,968 --> 00:24:40,200
the basic idea is that we start
by creating

529
00:24:40,200 --> 00:24:42,434
all the statements necessary--

530
00:24:42,434 --> 00:24:44,367
at the top,
that's the four loop--

531
00:24:44,367 --> 00:24:47,100
to write the server's updates
to the cache.

532
00:24:47,100 --> 00:24:51,400
And this code presumes
that the changes are sent

533
00:24:51,400 --> 00:24:53,234
as a JSON-encoded array.

534
00:24:53,234 --> 00:24:55,100
That's just, you know,
an array of little--

535
00:24:55,100 --> 00:24:57,234
of JavaScript objects.

536
00:24:57,234 --> 00:24:59,334
The next thing we do is
we remove--

537
00:24:59,334 --> 00:25:00,534
that's the eviction statement--

538
00:25:00,534 --> 00:25:04,334
remove all of the notes
in the cache

539
00:25:04,334 --> 00:25:08,167
that are not part
of the desired request.

540
00:25:08,167 --> 00:25:11,834
And we have a very simple
eviction policy in Simple Notes.

541
00:25:11,834 --> 00:25:15,701
We maintain a range of,
you know, I through J of notes.

542
00:25:15,701 --> 00:25:17,634
And everything outside of that,
we just throw it away

543
00:25:17,634 --> 00:25:20,734
and assume the server has
kept it.

544
00:25:20,734 --> 00:25:26,033
The next thing we have to do
is we have to, um...

545
00:25:26,033 --> 00:25:28,701
mark the contents
of the right buffer--

546
00:25:28,701 --> 00:25:32,634
the actions--to reapply,
so they can get reapplied

547
00:25:32,634 --> 00:25:35,667
to what we've just put
into the cache.

548
00:25:35,667 --> 00:25:38,067
Because these series of updates
have possibly destroyed

549
00:25:38,067 --> 00:25:42,467
user changes that haven't
reached the server.

550
00:25:42,467 --> 00:25:44,767
We need to update,
at this point,

551
00:25:44,767 --> 00:25:46,367
where the little arrow points.

552
00:25:46,367 --> 00:25:49,133
The notion of what is
in the cache.

553
00:25:49,133 --> 00:25:52,300
And it's important to do this
at the start of the transaction,

554
00:25:52,300 --> 00:25:54,200
as opposed anywhere else,

555
00:25:54,200 --> 00:25:57,701
so that any subsequent
transactions

556
00:25:57,701 --> 00:25:59,767
will see correct state.

557
00:25:59,767 --> 00:26:04,834
And JavaScript code that is
not yet inside of a transaction

558
00:26:04,834 --> 00:26:08,000
will also see what state--

559
00:26:08,000 --> 00:26:10,801
It will find in the database
when it's allowed to have

560
00:26:10,801 --> 00:26:13,634
its transaction run.

561
00:26:13,634 --> 00:26:15,300
These kinds of--
Well, I don't know,

562
00:26:15,300 --> 00:26:16,801
I used to like drawing
diagrams

563
00:26:16,801 --> 00:26:18,133
to try to plot out these things.

564
00:26:18,133 --> 00:26:20,534
It can be a bit tricky
with the whole

565
00:26:20,534 --> 00:26:21,834
asynchronous callback model

566
00:26:21,834 --> 00:26:24,667
figuring out where
you actually are

567
00:26:24,667 --> 00:26:26,834
with regards to updates
in JavaScript,

568
00:26:26,834 --> 00:26:28,033
and updates in SQL.

569
00:26:28,033 --> 00:26:30,901
Because there's no
sort of--

570
00:26:30,901 --> 00:26:34,734
They can happen overlapped.

571
00:26:34,734 --> 00:26:39,701
Finally, if this particular
update is a result

572
00:26:39,701 --> 00:26:41,234
of a cache miss,

573
00:26:41,234 --> 00:26:43,701
we call back to the UI
delivering the content

574
00:26:43,701 --> 00:26:46,968
that we received
from the server.

575
00:26:54,434 --> 00:26:57,133
Finally, we have
this last case.

576
00:26:57,133 --> 00:27:01,834
which is where "get values"
is handling a cache miss.

577
00:27:01,834 --> 00:27:06,734
And in this case, you know,
we will have had

578
00:27:06,734 --> 00:27:09,100
a "get values" call
enter the cache.

579
00:27:09,100 --> 00:27:11,834
And it needs to do--

580
00:27:11,834 --> 00:27:13,734
It needs to obtain
from the cache

581
00:27:13,734 --> 00:27:14,901
all of the requests.

582
00:27:14,901 --> 00:27:16,267
It should replay--

583
00:27:16,267 --> 00:27:18,834
It should send to the server
prior to sending a query.

584
00:27:18,834 --> 00:27:21,300
And then, only after
it's done that,

585
00:27:21,300 --> 00:27:25,467
it sends this aggregate bundle
of updates plus queries

586
00:27:25,467 --> 00:27:29,834
all to a server as one
so that the server can apply,

587
00:27:29,834 --> 00:27:32,067
prior to generating
the query result,

588
00:27:32,067 --> 00:27:36,367
all of the as yet unseen
user actions.

589
00:27:36,367 --> 00:27:38,767
And this should be starting
to look pretty familiar by now--

590
00:27:38,767 --> 00:27:40,167
this code.

591
00:27:40,167 --> 00:27:42,000
It's the same basic structure.

592
00:27:42,000 --> 00:27:49,467
We begin at the top
by accumulating

593
00:27:49,467 --> 00:27:53,868
a bunch of records that we need
to send to the server.

594
00:27:53,868 --> 00:27:56,601
And we mark the state
of the records

595
00:27:56,601 --> 00:27:58,601
that we are sending
to the server.

596
00:27:58,601 --> 00:28:00,701
And the right buffer is
being in flight.

597
00:28:00,701 --> 00:28:04,100
And then we send those
plus the query upstream

598
00:28:04,100 --> 00:28:08,567
to the server via XHR.

599
00:28:08,567 --> 00:28:10,801
So this diagram should hopefully
make this

600
00:28:10,801 --> 00:28:12,033
a little bit more clear

601
00:28:12,033 --> 00:28:15,834
about how we're maintaining
consistency.

602
00:28:15,834 --> 00:28:18,734
The gray cloud is obviously
the network.

603
00:28:18,734 --> 00:28:21,968
And the green box is
the contents of the right buffer

604
00:28:21,968 --> 00:28:23,400
over time.

605
00:28:23,400 --> 00:28:25,934
And way out there
at the left,

606
00:28:25,934 --> 00:28:29,200
the user has made, prior to
the start of this diagram,

607
00:28:29,200 --> 00:28:33,100
one change that is stored
in the cache as "change 1."

608
00:28:33,100 --> 00:28:38,534
And they then do something
that causes a cache miss,

609
00:28:38,534 --> 00:28:40,300
and so the UI--

610
00:28:40,300 --> 00:28:43,167
The cache is gonna fire off
a "fetch from server" call.

611
00:28:43,167 --> 00:28:44,767
And what does it do?

612
00:28:44,767 --> 00:28:47,701
Well, it obtains update one,

613
00:28:47,701 --> 00:28:52,701
and it suffixes that
with the query--

614
00:28:52,701 --> 00:28:55,367
the desired object
that's wanted.

615
00:28:55,367 --> 00:28:56,667
It sends it out to the server.

616
00:28:56,667 --> 00:28:58,667
Well, let's say it fails.

617
00:28:58,667 --> 00:29:02,434
The XHR times out.
You're offline.

618
00:29:02,434 --> 00:29:05,634
And you need it to authenticate.
You lost your cookies.

619
00:29:05,634 --> 00:29:07,067
Something bad happened.

620
00:29:07,067 --> 00:29:09,567
In that case,
the app change response

621
00:29:09,567 --> 00:29:11,501
from the XHR comes back.

622
00:29:11,501 --> 00:29:16,267
And we mark in the failure
callback that, hey, we tried.

623
00:29:16,267 --> 00:29:18,601
We sent the action to bed,

624
00:29:18,601 --> 00:29:23,133
and we told the UI we couldn't
satisfy the request.

625
00:29:23,133 --> 00:29:24,334
Uh, more time passes.

626
00:29:24,334 --> 00:29:26,300
The user keeps using
the application.

627
00:29:26,300 --> 00:29:27,601
They make another change.

628
00:29:27,601 --> 00:29:30,901
This would be change 2,
via the applied UI change there.

629
00:29:30,901 --> 00:29:34,200
So now there's change 1
that has not reached the server.

630
00:29:34,200 --> 00:29:36,000
And change 2 that, well,

631
00:29:36,000 --> 00:29:37,334
we haven't sent it
to the server yet,

632
00:29:37,334 --> 00:29:39,667
but we don't know
if it would fail.

633
00:29:39,667 --> 00:29:43,334
But maybe by this point,
the user's gone online.

634
00:29:43,334 --> 00:29:48,334
And so they once again call
"fetch from server"

635
00:29:48,334 --> 00:29:50,400
to fetch more content.

636
00:29:50,400 --> 00:29:53,601
And once again we need to
extract from the write buffer

637
00:29:53,601 --> 00:29:55,434
changes 1 and 2.

638
00:29:55,434 --> 00:29:58,601
And then append to that
the desired query, "Q."

639
00:29:58,601 --> 00:30:01,033
And that all goes to the server
as one big bundle.

640
00:30:01,033 --> 00:30:03,434
And this time it succeeds.

641
00:30:03,434 --> 00:30:06,901
And so the server responds
positively

642
00:30:06,901 --> 00:30:09,601
with the desired
query result,

643
00:30:09,601 --> 00:30:12,801
and acknowledges it's received
changes 1 and 2.

644
00:30:12,801 --> 00:30:14,634
But in the meantime--
because it takes time

645
00:30:14,634 --> 00:30:15,934
for things to reach the server,

646
00:30:15,934 --> 00:30:17,634
and for the server
to do things--

647
00:30:17,634 --> 00:30:20,501
the user's made
another change: change 3.

648
00:30:20,501 --> 00:30:23,133
So if we replace
the cache contents

649
00:30:23,133 --> 00:30:24,467
with the result of the query

650
00:30:24,467 --> 00:30:26,367
that we have just sent
the server,

651
00:30:26,367 --> 00:30:28,701
we will lose change 3.

652
00:30:28,701 --> 00:30:30,834
And that's the point
of the reapplication,

653
00:30:30,834 --> 00:30:33,767
is that first we update
the response--

654
00:30:33,767 --> 00:30:36,100
that's the "Q" response there

655
00:30:36,100 --> 00:30:37,801
that you see there
in the diagram--

656
00:30:37,801 --> 00:30:39,434
by insert update.

657
00:30:39,434 --> 00:30:42,234
And then we reapply the change 3
via the trigger

658
00:30:42,234 --> 00:30:44,501
that I already discussed

659
00:30:44,501 --> 00:30:48,234
to make sure that now
the state of the cache is

660
00:30:48,234 --> 00:30:53,601
whatever was on the server
at time "Q," plus change 3.

661
00:31:05,133 --> 00:31:10,067
So some miscellaneous tidbits
that are worth talking out.

662
00:31:10,067 --> 00:31:13,133
First, I've assumed that
all the content going

663
00:31:13,133 --> 00:31:15,234
up and back to the server
is always some kind

664
00:31:15,234 --> 00:31:17,033
of JSON-encoded content.

665
00:31:17,033 --> 00:31:19,968
Always sent by XHR post.

666
00:31:19,968 --> 00:31:22,667
If you're using app cache
in your application as well,

667
00:31:22,667 --> 00:31:25,300
it almost has to be post.

668
00:31:25,300 --> 00:31:26,834
It probably can't beget.

669
00:31:26,834 --> 00:31:30,267
Or put--I guess put is post.

670
00:31:30,267 --> 00:31:33,100
Um, and then, you know,

671
00:31:33,100 --> 00:31:34,701
for all the missing bits
I haven't talked about,

672
00:31:34,701 --> 00:31:37,868
most of them are
in the distribution and will...

673
00:31:37,868 --> 00:31:41,534
and should run.

674
00:31:41,534 --> 00:31:44,667
The asynchronous programming
model that you see

675
00:31:44,667 --> 00:31:46,467
in HTML 5 databases,

676
00:31:46,467 --> 00:31:49,067
and you see in WSPL
for the same reason,

677
00:31:49,067 --> 00:31:51,634
can be kind of difficult
sometimes

678
00:31:51,634 --> 00:31:54,400
because it sort of changes
the order of your code.

679
00:31:54,400 --> 00:31:56,334
It makes the order
it runs in

680
00:31:56,334 --> 00:32:00,701
not necessarily even remotely
like the order it's written in.

681
00:32:00,701 --> 00:32:04,167
So it's a good idea
to have planned out

682
00:32:04,167 --> 00:32:06,934
what you think the order
of the code is--

683
00:32:06,934 --> 00:32:08,634
its execution order.

684
00:32:08,634 --> 00:32:11,434
And to invest in
some good logging frameworks

685
00:32:11,434 --> 00:32:15,133
for your code before developing
with HTML 5.

686
00:32:15,133 --> 00:32:17,300
So you know what
is happening when.

687
00:32:17,300 --> 00:32:20,367
It can be very hard
to deal with.

688
00:32:20,367 --> 00:32:23,701
Another important tidbit
with HTML 5 is

689
00:32:23,701 --> 00:32:25,133
triggers are--they really--

690
00:32:25,133 --> 00:32:28,067
they really make life
so much easier.

691
00:32:28,067 --> 00:32:30,367
The SQL in the trigger,
well it runs

692
00:32:30,367 --> 00:32:31,667
in the order it's written in.

693
00:32:31,667 --> 00:32:33,634
So it's easy to figure out
what it's doing

694
00:32:33,634 --> 00:32:36,868
in comparison to
the JavaScript callbacks.

695
00:32:36,868 --> 00:32:39,400
And it also makes it
a lot faster to develop.

696
00:32:39,400 --> 00:32:43,667
You can make some very rich,
pervasive,

697
00:32:43,667 --> 00:32:45,567
and well-structured changes
to your database

698
00:32:45,567 --> 00:32:47,200
pretty easily in SQL.

699
00:32:47,200 --> 00:32:50,934
Of course,
you can also damage it.

700
00:32:50,934 --> 00:32:54,634
So you know, my advice it
use triggers as much as you can.

701
00:32:54,634 --> 00:32:56,868
They make life easier.

702
00:32:56,868 --> 00:32:59,400
The other thing is that
they run on a separate thread

703
00:32:59,400 --> 00:33:00,934
from the UI thread.

704
00:33:00,934 --> 00:33:05,133
And so the fact that
a trigger is progressing

705
00:33:05,133 --> 00:33:08,834
does not block the execution
of the UI thread

706
00:33:08,834 --> 00:33:12,400
where the user is clicking,
and you're rendering the results

707
00:33:12,400 --> 00:33:15,634
of changes the users made
onto the screen.

708
00:33:15,634 --> 00:33:20,701
And that helps keep
the application responsive.

709
00:33:20,701 --> 00:33:22,801
And finally, I've sort of
glossed over

710
00:33:22,801 --> 00:33:25,267
some sort of tricky problems

711
00:33:25,267 --> 00:33:27,534
in the Simple Notes
example code.

712
00:33:27,534 --> 00:33:29,968
In particular,
at least on a mobile device,

713
00:33:29,968 --> 00:33:33,400
the database isn't actually fast
enough to serve as the model

714
00:33:33,400 --> 00:33:35,501
in a model-view-controller
architecture

715
00:33:35,501 --> 00:33:36,767
for your application.

716
00:33:36,767 --> 00:33:40,501
You need some kind
of memory-based model

717
00:33:40,501 --> 00:33:44,601
that is served from the cache.

718
00:33:44,601 --> 00:33:47,467
It's also the case that
the database size limits,

719
00:33:47,467 --> 00:33:49,567
at least on current-generation
iPhones,

720
00:33:49,567 --> 00:33:52,534
is such that you probably
will find that

721
00:33:52,534 --> 00:33:55,567
your model in memory,
and your model in database,

722
00:33:55,567 --> 00:33:58,534
will be both the same size.

723
00:33:58,534 --> 00:34:02,367
Which has some opportunities
and some additional issues

724
00:34:02,367 --> 00:34:03,901
having to do with
making sure that

725
00:34:03,901 --> 00:34:05,534
you evict the right stuff.

726
00:34:05,534 --> 00:34:07,834
I mean, in theory,
you could keep different things

727
00:34:07,834 --> 00:34:11,167
in cache and in RAM model,

728
00:34:11,167 --> 00:34:13,601
and sort of double up how much
you have available

729
00:34:13,601 --> 00:34:15,334
to show to the user.

730
00:34:15,334 --> 00:34:19,467
Finally, Simple Notes makes--
does too much data traffic.

731
00:34:19,467 --> 00:34:24,801
When you refresh your cache
in Simple Notes,

732
00:34:24,801 --> 00:34:27,267
we just grab all the notes
over again

733
00:34:27,267 --> 00:34:29,033
that are within
the desired range.

734
00:34:29,033 --> 00:34:31,167
It's clearly not
the right way to do things.

735
00:34:31,167 --> 00:34:32,667
The right way to do things
would be to grab

736
00:34:32,667 --> 00:34:35,400
only those notes that have
actually been modified

737
00:34:35,400 --> 00:34:36,467
on the server.

738
00:34:36,467 --> 00:34:39,901
And one way to do that
might be to add

739
00:34:39,901 --> 00:34:42,167
some kind of date stamp
to the tables,

740
00:34:42,167 --> 00:34:43,968
and then sent that
to the server.

741
00:34:43,968 --> 00:34:45,567
And then the server would say,

742
00:34:45,567 --> 00:34:47,000
"Ah, yes,
these ones have changed,"

743
00:34:47,000 --> 00:34:48,734
and only send those back.

744
00:34:48,734 --> 00:34:51,267
Now, that would require,

745
00:34:51,267 --> 00:34:54,801
as part of servicing cache miss,
a trip to the database

746
00:34:54,801 --> 00:34:57,501
before you can send the query
to the server.

747
00:34:57,501 --> 00:34:59,567
And that means that
it takes longer

748
00:34:59,567 --> 00:35:01,167
to service the cache miss,

749
00:35:01,167 --> 00:35:05,534
and that increases latency
if the cache is empty.

750
00:35:05,534 --> 00:35:08,534
So these are kind of--

751
00:35:08,534 --> 00:35:10,434
Lots of interesting
design trade-offs

752
00:35:10,434 --> 00:35:14,834
to be worked out.

753
00:35:14,834 --> 00:35:19,434
So in summary, the cache pattern
is workable in real products.

754
00:35:19,434 --> 00:35:22,400
It's actually what we're using
in GMAIL for mobile.

755
00:35:22,400 --> 00:35:26,200
The WSDL library is
also workable.

756
00:35:26,200 --> 00:35:29,567
It's actually, if you've used
you iPhone with GMAIL,

757
00:35:29,567 --> 00:35:32,200
this code is live and shipping--
WSDL.

758
00:35:32,200 --> 00:35:34,501
So it does actually work.

759
00:35:34,501 --> 00:35:38,501
And it does provide a workable
local storage solution

760
00:35:38,501 --> 00:35:45,300
across both iPhone and Android
platform devices.

761
00:35:45,300 --> 00:35:47,000
So that's--that's--

762
00:35:47,000 --> 00:35:48,834
We're at the end
of the presentation.

763
00:35:48,834 --> 00:35:50,300
I invite questions.

764
00:35:50,300 --> 00:35:53,567
You can go to the microphones,
please, if you have questions.

765
00:35:53,567 --> 00:35:58,234
Or we can use the moderator
to find it.

766
00:36:01,634 --> 00:36:04,033
Oops. Wrong window.

767
00:36:10,567 --> 00:36:12,701
Um...

768
00:36:20,067 --> 00:36:22,234
Questions?

769
00:36:26,968 --> 00:36:30,100
man: Hi. Uh, how well
the database is secured?

770
00:36:30,100 --> 00:36:31,300
Kroeger: Pardon me?

771
00:36:31,300 --> 00:36:33,033
man: The security
of the database.

772
00:36:33,033 --> 00:36:34,067
Kroeger: The security
of the database?

773
00:36:34,067 --> 00:36:35,200
man: Uh-huh.

774
00:36:35,200 --> 00:36:37,234
Kroeger: So the security
of the database is,

775
00:36:37,234 --> 00:36:40,601
in our case, left in the hands
of the browser.

776
00:36:40,601 --> 00:36:45,234
The browser enforces
domain-level access

777
00:36:45,234 --> 00:36:47,300
in the sense that
if your app is served

778
00:36:47,300 --> 00:36:50,601
from www.google.com,

779
00:36:50,601 --> 00:36:53,634
only other apps served
from that domain

780
00:36:53,634 --> 00:36:55,834
are allowed to access
the database.

781
00:36:55,834 --> 00:36:58,868
Obviously if you have
shell access

782
00:36:58,868 --> 00:37:00,334
to the device in question,

783
00:37:00,334 --> 00:37:05,000
the security doesn't exist.

784
00:37:05,000 --> 00:37:06,734
Like, if you've actually
logged into the device,

785
00:37:06,734 --> 00:37:09,300
and if you're using an HTML 5
database on your desktop,

786
00:37:09,300 --> 00:37:13,467
you can go find the actual file
in the file system and edit it,

787
00:37:13,467 --> 00:37:15,167
as you might expect.

788
00:37:15,167 --> 00:37:16,300
man: Okay.

789
00:37:16,300 --> 00:37:17,667
Kroeger: Does that answer
your question?

790
00:37:17,667 --> 00:37:21,100
man: So it's stored
in the clear text, or...

791
00:37:21,100 --> 00:37:23,567
Kroeger: Uh, yeah, they are.
man: Okay.

792
00:37:23,567 --> 00:37:27,834
Kroeger: The presumption being
that you can't--

793
00:37:27,834 --> 00:37:30,501
A web application cannot
get access to the database

794
00:37:30,501 --> 00:37:33,067
without being served
from the same domain

795
00:37:33,067 --> 00:37:35,200
as the web application
that created it.

796
00:37:35,200 --> 00:37:38,534
And the browser is
the gatekeeper.

797
00:37:38,534 --> 00:37:44,934
man: Okay. Thank you.

798
00:37:44,934 --> 00:37:47,200
man: Are the domain-based
security mechanism--

799
00:37:47,200 --> 00:37:49,934
Is it related to
single-origin policy?

800
00:37:49,934 --> 00:37:52,701
Kroeger: Yeah, that would be
the right way to say it.

801
00:37:52,701 --> 00:37:54,334
Thank you.

802
00:38:03,400 --> 00:38:06,434
More questions?

803
00:38:23,033 --> 00:38:26,901
Um...
are they appearing here?

804
00:38:45,868 --> 00:38:49,300
[man speaking indistinctly
without microphone]

805
00:38:57,334 --> 00:38:58,634
Kroeger:
I'll repeat the question

806
00:38:58,634 --> 00:39:00,567
for the benefit
of the recording.

807
00:39:00,567 --> 00:39:04,133
Is there a limit
on the amount of data

808
00:39:04,133 --> 00:39:05,367
that can be cached?

809
00:39:05,367 --> 00:39:08,634
And are we caching
to the SD card?

810
00:39:08,634 --> 00:39:15,234
So where the data goes is under
the control of the browser.

811
00:39:15,234 --> 00:39:17,601
We personally don't
control that.

812
00:39:17,601 --> 00:39:22,267
The HTML 5 spec says nothing
of where the browser or platform

813
00:39:22,267 --> 00:39:23,534
should put the data.

814
00:39:23,534 --> 00:39:25,734
It might put it
on the SD card.

815
00:39:25,734 --> 00:39:29,467
It might put it
in some other kind of store

816
00:39:29,467 --> 00:39:31,000
inside of the device.

817
00:39:31,000 --> 00:39:34,501
Um, on your desktop, it puts it
on your hard disk.

818
00:39:34,501 --> 00:39:36,868
The data volume--

819
00:39:36,868 --> 00:39:40,868
The current iPhone 2.2.1.
hard-limits your database

820
00:39:40,868 --> 00:39:43,901
to five megabytes
per domain.

821
00:39:43,901 --> 00:39:49,734
Um, Gears has a much more
flexible policy

822
00:39:49,734 --> 00:39:52,734
in that we could ask
the Gears database

823
00:39:52,734 --> 00:39:53,834
to be much larger.

824
00:39:53,834 --> 00:39:55,834
And as long as the user
has agreed

825
00:39:55,834 --> 00:39:58,567
in the Gears permission
dialogue,

826
00:39:58,567 --> 00:40:02,200
it could be much larger.

827
00:40:02,200 --> 00:40:08,601
Um, the size of the database
is something that's evolving.

828
00:40:08,601 --> 00:40:14,834
The HTML 5 specification is
sort of fuzzy about

829
00:40:14,834 --> 00:40:20,601
what, exactly, should happen
with database size.

830
00:40:20,601 --> 00:40:22,000
Like, what should the limit be?

831
00:40:22,000 --> 00:40:25,067
They say that there should be
some sort of reasonable default,

832
00:40:25,067 --> 00:40:27,934
and that perhaps the user agent
could ask the user

833
00:40:27,934 --> 00:40:29,200
if they wish it to grow.

834
00:40:29,200 --> 00:40:32,300
And this is how it works
in recent web kit nightlies

835
00:40:32,300 --> 00:40:37,968
and what is supposedly supported
on iPhone 3.0.

836
00:40:42,033 --> 00:40:44,634
man: So how do you foresee
the performance problems

837
00:40:44,634 --> 00:40:47,567
of on-device
or in-browser databases?

838
00:40:47,567 --> 00:40:49,234
Would it make sense
to build--

839
00:40:49,234 --> 00:40:52,801
to invest in making, like,
a JavaScript RM,

840
00:40:52,801 --> 00:40:59,534
or just to wait for
the databases to get faster?

841
00:40:59,534 --> 00:41:02,167
Kroeger: So the database is,
I think--

842
00:41:02,167 --> 00:41:04,701
The database is largely slow,
I believe,

843
00:41:04,701 --> 00:41:09,167
because, um, we're spoiled
by the desktop.

844
00:41:09,167 --> 00:41:13,567
And it's highly not slow
on the desktop.

845
00:41:13,567 --> 00:41:15,834
You know, I--

846
00:41:15,834 --> 00:41:22,300
A flash store on the phone
is not a high-speed

847
00:41:22,300 --> 00:41:25,367
random access storage device

848
00:41:25,367 --> 00:41:28,334
by the standards
of modern SATA disks.

849
00:41:28,334 --> 00:41:31,000
And that's why I think
the database is kinda slow.

850
00:41:31,000 --> 00:41:33,868
But I don't actually--
I don't really know for sure.

851
00:41:33,868 --> 00:41:35,901
man: But is this database
usually SQL Light?

852
00:41:35,901 --> 00:41:37,601
Kroeger: Yeah, it is.
It's SQL Light.

853
00:41:37,601 --> 00:41:39,868
man: So this could be addressed
in SQL Light?

854
00:41:39,868 --> 00:41:43,100
Kroeger: Yeah, that would be--
that would be nice,

855
00:41:43,100 --> 00:41:46,534
I think,
if they sped up SQL Light.

856
00:41:46,534 --> 00:41:52,934
Um, it's fast enough for--

857
00:41:52,934 --> 00:41:55,200
It's fast enough
for caching applications

858
00:41:55,200 --> 00:41:59,567
if you're not relying on it
to be the application model.

859
00:41:59,567 --> 00:42:02,501
man: Okay. Thanks.

860
00:42:02,501 --> 00:42:05,767
man: What's your experience been
with indexing

861
00:42:05,767 --> 00:42:08,767
and, kind of, other,
you know,

862
00:42:08,767 --> 00:42:12,100
more tuning, kind of, tunables
and stuff like that

863
00:42:12,100 --> 00:42:14,033
that you expect from
a SQL implementation?

864
00:42:14,033 --> 00:42:18,534
Kroeger: So indexing is a big--
is a win in SQL Light.

865
00:42:18,534 --> 00:42:21,467
It's not as much of a win
as we'd hoped for.

866
00:42:21,467 --> 00:42:29,033
Um, we got maybe 2x improvement
with indexes.

867
00:42:29,033 --> 00:42:33,801
The performance tools are
difficult to use

868
00:42:33,801 --> 00:42:35,934
on the device itself.

869
00:42:35,934 --> 00:42:38,067
You have to have jail-broken
your phone

870
00:42:38,067 --> 00:42:40,667
and run the SQL Light
command line--

871
00:42:40,667 --> 00:42:43,934
that is, of course,
from the jail-broken website--

872
00:42:43,934 --> 00:42:47,534
on the device to actually
access the database

873
00:42:47,534 --> 00:42:49,167
on the phone itself.

874
00:42:49,167 --> 00:42:52,300
Because the performance results
on the desktop mean nothing.

875
00:42:52,300 --> 00:42:56,434
Everything happens instantly.

876
00:42:56,434 --> 00:42:57,934
Essentially, so...

877
00:42:57,934 --> 00:43:00,267
man: What's the, um--

878
00:43:00,267 --> 00:43:01,834
That's the iPhone story.

879
00:43:01,834 --> 00:43:05,300
What's the similar story
for the Google device?

880
00:43:05,300 --> 00:43:06,400
Their--
Kroeger: The Android?

881
00:43:06,400 --> 00:43:08,934
man: Yeah.
Kroeger: Um...

882
00:43:08,934 --> 00:43:13,901
so once again you have to
run SQL Light on the device.

883
00:43:13,901 --> 00:43:16,267
It's included
in the Android SDK.

884
00:43:16,267 --> 00:43:18,400
It's the same basic idea.

885
00:43:18,400 --> 00:43:20,400
You log into
your Android device,

886
00:43:20,400 --> 00:43:23,968
and you can profile
your database as you see fit.

887
00:43:23,968 --> 00:43:27,968
The Gears implementation...

888
00:43:27,968 --> 00:43:31,367
The actual database interface
in Gears,

889
00:43:31,367 --> 00:43:33,067
perhaps because
it's synchronous,

890
00:43:33,067 --> 00:43:36,534
is faster than
the iPhone implementation.

891
00:43:36,534 --> 00:43:38,601
But the--

892
00:43:38,601 --> 00:43:41,767
Implementing the asynchrony
through a worker

893
00:43:41,767 --> 00:43:46,501
is actually slower
than HTML 5 implementation

894
00:43:46,501 --> 00:43:47,934
of the same thing.

895
00:43:47,934 --> 00:43:50,100
Because in HTML 5, you have
a native thread

896
00:43:50,100 --> 00:43:51,367
running the database.

897
00:43:51,367 --> 00:43:56,033
And then in WSPL,
we have a JavaScript thread

898
00:43:56,033 --> 00:43:58,667
running the synchronous
database.

899
00:43:58,667 --> 00:44:00,968
man: Excellent.

900
00:44:06,033 --> 00:44:07,834
man: Hello. Thank you.

901
00:44:07,834 --> 00:44:10,734
It was very informative.

902
00:44:10,734 --> 00:44:15,567
The question I have is,
the last time I checked,

903
00:44:15,567 --> 00:44:22,100
a custom Android app
did not directly support Gears.

904
00:44:22,100 --> 00:44:24,234
Kroeger: So these are all--

905
00:44:24,234 --> 00:44:26,501
This is a web app, right?

906
00:44:26,501 --> 00:44:28,567
Runs inside of the Android
web browser.

907
00:44:28,567 --> 00:44:33,634
And so the Android web browser
has Gears available.

908
00:44:33,634 --> 00:44:38,434
It's simply a matter of calling
the requisite--

909
00:44:38,434 --> 00:44:41,667
um, recommended code
that is available

910
00:44:41,667 --> 00:44:42,901
from the Gears web site.

911
00:44:42,901 --> 00:44:46,234
And it will put up
a permissions dialogue.

912
00:44:46,234 --> 00:44:49,300
And the user will need
to say yes, that it's okay

913
00:44:49,300 --> 00:44:52,834
for Gears to be available to
this particular web application.

914
00:44:52,834 --> 00:44:55,367
And once that's done,
you can use Gears Calls

915
00:44:55,367 --> 00:44:58,167
in your web app on Android.

916
00:44:58,167 --> 00:45:00,934
man: Okay, and just to,
you know--

917
00:45:00,934 --> 00:45:02,534
whether I got it right.

918
00:45:02,534 --> 00:45:05,167
You know, I know that browsers
on Android

919
00:45:05,167 --> 00:45:07,968
were supporting Gears--
like the browser app.

920
00:45:07,968 --> 00:45:11,901
But if I, say--
I create my own app XYZ...

921
00:45:11,901 --> 00:45:15,000
I mean, my understanding
the last time was

922
00:45:15,000 --> 00:45:16,934
it does not involve Gears.

923
00:45:16,934 --> 00:45:18,267
Or I cannot--

924
00:45:18,267 --> 00:45:20,534
Kroeger: I--I don't know...
man: Okay, thanks.

925
00:45:20,534 --> 00:45:22,701
Kroeger: the answer to that.

926
00:45:22,701 --> 00:45:24,033
man: Um, hi.

927
00:45:24,033 --> 00:45:28,901
Is the API going to evolve
into something like EJB 3?

928
00:45:28,901 --> 00:45:31,467
You know, like Objectory
and that stuff.

929
00:45:31,467 --> 00:45:33,567
Uh, you know, [indistinct].

930
00:45:33,567 --> 00:45:35,167
Kroeger: Which API?

931
00:45:35,167 --> 00:45:37,133
man: The WSPL.

932
00:45:37,133 --> 00:45:41,033
Kroeger: Oh. So the WSPL API
should look very much

933
00:45:41,033 --> 00:45:44,033
like the HTML 5 database API.

934
00:45:44,033 --> 00:45:47,033
If you're thinking that
we could add

935
00:45:47,033 --> 00:45:50,367
some kind of JavaScript
object-relational mapper,

936
00:45:50,367 --> 00:45:54,200
you're right,
and it might happen.

937
00:45:54,200 --> 00:45:57,200
But no promises.

938
00:46:10,133 --> 00:46:15,734
More questions?

939
00:46:15,734 --> 00:46:19,534
man: So what's the Google Gears
roadmap looks like?

940
00:46:19,534 --> 00:46:22,701
Because we have HTML 5 now,

941
00:46:22,701 --> 00:46:28,634
and you guys are going
toward HTML 5, so...

942
00:46:28,634 --> 00:46:32,033
Kroeger: Uh...um...

943
00:46:32,033 --> 00:46:35,868
[laughter]

944
00:46:35,868 --> 00:46:39,567
Yeah, um...

945
00:46:39,567 --> 00:46:43,300
I guess the simple answer,
which isn't really useful,

946
00:46:43,300 --> 00:46:46,467
is that they're converging.

947
00:46:46,467 --> 00:46:51,467
That eventually there will be
one API that is blessed

948
00:46:51,467 --> 00:46:57,567
by the, what...WG working group
that everybody uses.

949
00:46:57,567 --> 00:47:01,734
And people are working very hard
on making that happen.

950
00:47:01,734 --> 00:47:04,734
man: So would you recommend
us using Google Gears

951
00:47:04,734 --> 00:47:06,267
at this point or...?

952
00:47:06,267 --> 00:47:08,801
Kroeger: Well, so one of
the nice things about

953
00:47:08,801 --> 00:47:12,968
this WSPL library is that it
protects you from this choice.

954
00:47:12,968 --> 00:47:17,767
You can write database apps now
against an HTML 5 API.

955
00:47:17,767 --> 00:47:19,267
And they'll work on Gears too.

956
00:47:19,267 --> 00:47:23,868
So that's what we decided
to do.

957
00:47:23,868 --> 00:47:26,501
We had to support Android
and iPhone.

958
00:47:26,501 --> 00:47:28,234
And so, you know,

959
00:47:28,234 --> 00:47:30,167
we built this library
that let us do it.

960
00:47:30,167 --> 00:47:36,000
Um, if you have a need
to support both platforms now,

961
00:47:36,000 --> 00:47:38,634
then I would recommend
you try out our library.

962
00:47:38,634 --> 00:47:40,801
'Cause it will do the job.

963
00:47:40,801 --> 00:47:47,334
And then, as HTML 5 becomes
available natively everywhere,

964
00:47:47,334 --> 00:47:51,234
our library will get skinnier,

965
00:47:51,234 --> 00:47:56,767
and you won't have to change
your code.

966
00:47:56,767 --> 00:48:00,567
man: One further question is
do we have WSPL available

967
00:48:00,567 --> 00:48:01,701
on the desktop?

968
00:48:01,701 --> 00:48:04,567
I guess...on any browser?

969
00:48:04,567 --> 00:48:10,167
Kroeger: It runs in Android
and Chrome and Safari...

970
00:48:10,167 --> 00:48:13,100
correctly.

971
00:48:13,100 --> 00:48:16,267
man: Should be okay.
Thank you.

972
00:48:36,234 --> 00:48:38,801
Kroeger: More questions?

973
00:48:41,434 --> 00:48:43,701
Oh...

974
00:48:43,701 --> 00:48:47,100
Screen sa--
It wants my password.

975
00:49:00,767 --> 00:49:04,601
Yes, it would be really nice
to have an ORM system.

976
00:49:04,601 --> 00:49:07,100
We actually started
writing one

977
00:49:07,100 --> 00:49:11,300
and never really finished it.

978
00:49:11,300 --> 00:49:14,000
The reason why--I mean,
I was writing it.

979
00:49:14,000 --> 00:49:15,934
And the reason why
I abandoned it was that

980
00:49:15,934 --> 00:49:18,534
it wasn't advancing
other features

981
00:49:18,534 --> 00:49:21,434
that were being asked for
by managers.

982
00:49:21,434 --> 00:49:25,767
And it was not, at the time--

983
00:49:25,767 --> 00:49:27,801
We didn't see a good way
to make it

984
00:49:27,801 --> 00:49:30,534
both sufficiently general
and fast.

985
00:49:30,534 --> 00:49:34,067
Um...

986
00:49:34,067 --> 00:49:36,567
it would be--

987
00:49:36,567 --> 00:49:42,667
Hypothetically it would be nice
to have some kind of, um...

988
00:49:42,667 --> 00:49:47,300
compile time tool
that would read a--

989
00:49:47,300 --> 00:49:49,334
say a JSON object definition,

990
00:49:49,334 --> 00:49:53,701
and would construct
the appropriate SQL.

991
00:49:53,701 --> 00:49:58,767
So that's where thoughts are
with doing ORM for JavaScript.

992
00:50:19,200 --> 00:50:21,968
Well, I think we can all
have coffee early

993
00:50:21,968 --> 00:50:25,501
if there's no more questions.

994
00:50:25,501 --> 00:50:27,834
Going once, going twice.

995
00:50:27,834 --> 00:50:33,901
[applause]

