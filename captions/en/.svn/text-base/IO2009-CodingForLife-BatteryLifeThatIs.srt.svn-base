1
00:00:01,000 --> 00:00:01,467
Jeff Sharkey:
Well, hey, everybody,

2
00:00:01,467 --> 00:00:02,868
thanks for coming
this afternoon.

3
00:00:02,868 --> 00:00:04,367
My name is Jeff Sharkey,

4
00:00:04,367 --> 00:00:06,601
and I've been working on Android
for about a year and a half

5
00:00:06,601 --> 00:00:08,501
outside of the Google team.

6
00:00:08,501 --> 00:00:10,501
And then recently,
about six months ago,

7
00:00:10,501 --> 00:00:12,000
I joined Google,

8
00:00:12,000 --> 00:00:13,667
and I've been working on some
cool stuff in the meantime.

9
00:00:13,667 --> 00:00:15,934
And today we're gonna talk
about battery life.

10
00:00:15,934 --> 00:00:18,400
So you guys got a whole bunch
of really cool devices

11
00:00:18,400 --> 00:00:19,801
this morning.

12
00:00:19,801 --> 00:00:22,434
How many of you still have
charge left on your device?

13
00:00:22,434 --> 00:00:24,267
You still have
some battery life.

14
00:00:24,267 --> 00:00:26,267
Okay, there's still
some hands in the crowd.

15
00:00:26,267 --> 00:00:28,868
You might notice,
as you go through the day,

16
00:00:28,868 --> 00:00:30,434
you'll slowly watch
that battery life go down

17
00:00:30,434 --> 00:00:32,467
further and further,
and then the device will die.

18
00:00:32,467 --> 00:00:35,167
And that's something that
today we're gonna talk about--

19
00:00:35,167 --> 00:00:38,033
you as developers, as you're
writing these applications,

20
00:00:38,033 --> 00:00:40,033
writing third-party
applications,

21
00:00:40,033 --> 00:00:42,701
ways that you can make
that battery last longer...

22
00:00:42,701 --> 00:00:44,267
for your users
that are out on the field,

23
00:00:44,267 --> 00:00:46,067
not just for yourselves.

24
00:00:46,067 --> 00:00:47,834
So just wanted to mention
up front

25
00:00:47,834 --> 00:00:49,467
that as I go through
the talk today,

26
00:00:49,467 --> 00:00:51,067
if you guys have any questions,

27
00:00:51,067 --> 00:00:52,868
if they come to you
during the presentation--

28
00:00:52,868 --> 00:00:54,367
I'm using Google Moderator,

29
00:00:54,367 --> 00:00:56,067
so you should have
received links.

30
00:00:56,067 --> 00:00:57,667
There's links up on
the screen right there.

31
00:00:57,667 --> 00:01:01,801
The haveasec--I don't know
if that goes to the right one.

32
00:01:01,801 --> 00:01:03,868
But this link,
code.google.com,

33
00:01:03,868 --> 00:01:05,901
that'll link you guys
to the Moderator,

34
00:01:05,901 --> 00:01:07,601
and then at the end
of the talk.

35
00:01:07,601 --> 00:01:09,634
There's a couple questions
up there already,

36
00:01:09,634 --> 00:01:10,834
it looks like, on it.

37
00:01:10,834 --> 00:01:11,934
So I'll be switching
back and forth

38
00:01:11,934 --> 00:01:13,367
between the mikes
and the Moderator

39
00:01:13,367 --> 00:01:14,667
at the end of the session.

40
00:01:14,667 --> 00:01:16,801
So just a heads-up--
if you have questions, go ask,

41
00:01:16,801 --> 00:01:18,267
and also vote,
'cause that'll bubble up

42
00:01:18,267 --> 00:01:20,667
the important questions
to the top.

43
00:01:20,667 --> 00:01:23,334
All right, so battery life.
Why does it matter?

44
00:01:23,334 --> 00:01:25,367
Why does it matter
to the users that are out there?

45
00:01:25,367 --> 00:01:27,634
When we think of Android
devices, we typically--

46
00:01:27,634 --> 00:01:29,167
they're mostly phones right now.

47
00:01:29,167 --> 00:01:31,334
And these phones, they might
be on someone's nightstand,

48
00:01:31,334 --> 00:01:34,934
and then they take them out
for the rest of an entire day.

49
00:01:34,934 --> 00:01:37,000
They leave in the morning.
They unplug the device.

50
00:01:37,000 --> 00:01:38,834
And that device
may not see power,

51
00:01:38,834 --> 00:01:40,234
it may not see a charge,

52
00:01:40,234 --> 00:01:42,167
until that person gets home
late that night.

53
00:01:42,167 --> 00:01:44,033
So during the course of the day,

54
00:01:44,033 --> 00:01:47,000
the battery needs to power
the device.

55
00:01:47,000 --> 00:01:48,467
And the risk is

56
00:01:48,467 --> 00:01:51,100
that if the battery
runs out during the day,

57
00:01:51,100 --> 00:01:53,167
the user can't use
the device anymore.

58
00:01:53,167 --> 00:01:55,200
When the battery's gone,
it truly is gone.

59
00:01:55,200 --> 00:01:57,801
It's a sad state of affairs.

60
00:01:57,801 --> 00:02:00,133
So the apps needs to work
together to be good citizens

61
00:02:00,133 --> 00:02:01,868
of the battery
that's on the device,

62
00:02:01,868 --> 00:02:03,267
because you're
all running together.

63
00:02:03,267 --> 00:02:06,400
Your app is running alongside
Gmail and Maps

64
00:02:06,400 --> 00:02:09,200
and a lot of these other apps
on the device.

65
00:02:09,200 --> 00:02:11,567
So you need to work together
with those apps

66
00:02:11,567 --> 00:02:13,801
to be good citizens.

67
00:02:13,801 --> 00:02:15,734
Today I'll be throwing around
a bunch of different numbers,

68
00:02:15,734 --> 00:02:18,100
and I'll be using
two units of measurement.

69
00:02:18,100 --> 00:02:19,901
They're actually SI units.

70
00:02:19,901 --> 00:02:21,801
The first type of measurement

71
00:02:21,801 --> 00:02:23,868
I'll be talking about
is current,

72
00:02:23,868 --> 00:02:26,300
or typically
we think of this in amps,

73
00:02:26,300 --> 00:02:28,534
or milliamps is the unit
I'll be using today.

74
00:02:28,534 --> 00:02:31,868
So if you think--
current is a way of saying

75
00:02:31,868 --> 00:02:34,868
how fast we're consuming
the battery on the device

76
00:02:34,868 --> 00:02:36,667
or the rate of consumption.

77
00:02:36,667 --> 00:02:38,334
So when you're doing
a lot on the device,

78
00:02:38,334 --> 00:02:39,901
let's say you're watching
a YouTube video,

79
00:02:39,901 --> 00:02:42,767
you'll be pulling a lot
of milliamps on the device.

80
00:02:42,767 --> 00:02:44,767
The second number
I'll be mentioning

81
00:02:44,767 --> 00:02:47,567
is milliamp hours,
and that's a capacity.

82
00:02:47,567 --> 00:02:50,901
That's how much storage,
how much battery life

83
00:02:50,901 --> 00:02:52,968
we actually store
in the battery on the device

84
00:02:52,968 --> 00:02:55,000
when it is fully charged.

85
00:02:55,000 --> 00:02:56,767
So just some numbers
for comparison.

86
00:02:56,767 --> 00:02:58,367
If we think of the HTC Dream

87
00:02:58,367 --> 00:03:00,267
or the G1 device
that recently came out

88
00:03:00,267 --> 00:03:01,601
last Octoberish,

89
00:03:01,601 --> 00:03:05,334
it had a battery
of 1,150 milliamp hours.

90
00:03:05,334 --> 00:03:07,334
That was the capacity
that it could hold.

91
00:03:07,334 --> 00:03:09,267
The device that you guys
received today,

92
00:03:09,267 --> 00:03:12,067
the HTC Magic,
has a slightly larger battery,

93
00:03:12,067 --> 00:03:13,834
about 1,350.

94
00:03:13,834 --> 00:03:16,033
And another device that was
also recently announced

95
00:03:16,033 --> 00:03:17,400
in a press release,

96
00:03:17,400 --> 00:03:19,467
a Samsung device
that runs Android,

97
00:03:19,467 --> 00:03:22,601
and its battery
is about 1,500 milliamp hours.

98
00:03:22,601 --> 00:03:25,100
So something to realize between
all three of these devices

99
00:03:25,100 --> 00:03:28,801
is that they roughly have
the same battery--

100
00:03:28,801 --> 00:03:30,868
the same battery capacity.

101
00:03:30,868 --> 00:03:34,534
They're all in the same class.
It's roughly the same.

102
00:03:34,534 --> 00:03:37,300
And this is partially
an industrial design problem.

103
00:03:37,300 --> 00:03:38,868
When you're building a phone,

104
00:03:38,868 --> 00:03:41,000
you want to build something
that fits in someone's pocket.

105
00:03:41,000 --> 00:03:42,467
You don't want to build a device

106
00:03:42,467 --> 00:03:44,601
that they have to carry around
a 12-volt battery with them.

107
00:03:44,601 --> 00:03:46,267
[laughs]
You want to have a device

108
00:03:46,267 --> 00:03:47,868
that fits nicely
in their pocket.

109
00:03:47,868 --> 00:03:50,100
So you only have so much
room for a battery.

110
00:03:50,100 --> 00:03:52,501
And the way the technology
is progressing right now,

111
00:03:52,501 --> 00:03:53,834
we're looking forward to having

112
00:03:53,834 --> 00:03:55,267
better battery life
in the future,

113
00:03:55,267 --> 00:03:57,701
or better battery capacities.

114
00:03:57,701 --> 00:03:59,300
But for the moment,

115
00:03:59,300 --> 00:04:02,133
this is kind of
what we have to deal with.

116
00:04:02,133 --> 00:04:03,934
Just to compare
these capacities,

117
00:04:03,934 --> 00:04:07,100
something like a typical
laptop that you might see,

118
00:04:07,100 --> 00:04:09,033
like a Asus EEE PC,

119
00:04:09,033 --> 00:04:10,934
its battery is about
three or four times the size

120
00:04:10,934 --> 00:04:13,300
of what we're dealing with
on these mobile devices.

121
00:04:13,300 --> 00:04:16,033
It's about 5,800
milliamp hours.

122
00:04:16,033 --> 00:04:18,934
And that's about the same as
if you know a MacBook Pro,

123
00:04:18,934 --> 00:04:21,534
the battery in that's about
5,600 milliamp hours.

124
00:04:21,534 --> 00:04:25,000
So those are the types of
numbers that we're dealing with.

125
00:04:25,000 --> 00:04:28,100
So then we can ask the question,
we have the capacity,

126
00:04:28,100 --> 00:04:30,133
we have
the 1,150 milliamp hours--

127
00:04:30,133 --> 00:04:32,234
where does it all go
through the course of a day

128
00:04:32,234 --> 00:04:34,334
as the user's doing
different tasks?

129
00:04:34,334 --> 00:04:35,801
So this is just an overview.

130
00:04:35,801 --> 00:04:37,501
If we start over
on the left-hand side,

131
00:04:37,501 --> 00:04:39,033
if you have a device,
it's booted,

132
00:04:39,033 --> 00:04:40,467
but the screen's turned off.

133
00:04:40,467 --> 00:04:42,000
It's sitting on the table
completely idle.

134
00:04:42,000 --> 00:04:43,567
And it's in airplane mode.

135
00:04:43,567 --> 00:04:45,701
This means we've turned off
all the radios in the device.

136
00:04:45,701 --> 00:04:48,000
It takes about 2 milliamp hours

137
00:04:48,000 --> 00:04:50,067
or 2 milliamps of current
that it's pulling

138
00:04:50,067 --> 00:04:52,133
just to sit there waiting
for the user to wake it up--

139
00:04:52,133 --> 00:04:55,033
waiting for a user to wake it up
and interact with it.

140
00:04:55,033 --> 00:04:56,901
If we add in one of
the radio connections--

141
00:04:56,901 --> 00:04:59,200
let's say if we have an EDGE
or a 3G connection

142
00:04:59,200 --> 00:05:02,434
just sitting idle--it takes
a slightly little bit more.

143
00:05:02,434 --> 00:05:04,734
It's about 5 milliamps
that the device is pulling

144
00:05:04,734 --> 00:05:06,501
just sitting there idle.

145
00:05:06,501 --> 00:05:08,067
On WiFi,
it costs a little bit more,

146
00:05:08,067 --> 00:05:11,200
about 12 milliamps
of current that it's pulling.

147
00:05:11,200 --> 00:05:14,000
As soon as the user begins
interacting with the device,

148
00:05:14,000 --> 00:05:15,801
this is where
we see the jump.

149
00:05:15,801 --> 00:05:17,767
Just turning on the LCD
on the device

150
00:05:17,767 --> 00:05:19,467
to display something
to the user

151
00:05:19,467 --> 00:05:21,734
ends up taking
90 milliamps of battery.

152
00:05:21,734 --> 00:05:23,534
So anytime the screen is on,

153
00:05:23,534 --> 00:05:25,901
that's the amount of current
that the screen is pulling.

154
00:05:25,901 --> 00:05:28,067
And as soon as we start
adding in things like CPU...

155
00:05:28,067 --> 00:05:30,334
if you're doing 50%
or 100% CPU--

156
00:05:30,334 --> 00:05:33,968
so 100% CPU on top of
the screen already being on,

157
00:05:33,968 --> 00:05:35,767
so this is the blue
specific item--

158
00:05:35,767 --> 00:05:37,467
on top of the screen being
turned on,

159
00:05:37,467 --> 00:05:41,334
100% CPU ends up being
110 milliamps

160
00:05:41,334 --> 00:05:44,033
to run the CPU
at full speed.

161
00:05:44,033 --> 00:05:46,100
Something if you're looking
at writing a game,

162
00:05:46,100 --> 00:05:47,601
running the game sensor,

163
00:05:47,601 --> 00:05:48,868
so the accelerometer
on the device,

164
00:05:48,868 --> 00:05:50,767
this takes something like
80 milliamps

165
00:05:50,767 --> 00:05:52,300
of current
that you're pulling.

166
00:05:52,300 --> 00:05:55,734
If you're trying to get
a GPS fix using the GPS radio,

167
00:05:55,734 --> 00:05:58,367
that ends up taking another
80 or 85 milliamps

168
00:05:58,367 --> 00:06:00,467
that that radio is pulling.

169
00:06:00,467 --> 00:06:02,734
And then finally we get
to the data on the device,

170
00:06:02,734 --> 00:06:04,334
when you have a data radio
turned on

171
00:06:04,334 --> 00:06:06,234
and you're doing data transfer.

172
00:06:06,234 --> 00:06:08,801
So these numbers
are full-bore.

173
00:06:08,801 --> 00:06:11,133
We're transferring as much data
as we possibly can.

174
00:06:11,133 --> 00:06:12,968
So this is--we're stressing
the radio out,

175
00:06:12,968 --> 00:06:15,000
we're doing
lots of data transfer.

176
00:06:15,000 --> 00:06:16,334
So something like this.

177
00:06:16,334 --> 00:06:18,567
The 3G radio is actually
pretty cheap in the device.

178
00:06:18,567 --> 00:06:21,300
It ends up costing
about 150 milliamps

179
00:06:21,300 --> 00:06:24,033
just to run the 3G radio
full-bore

180
00:06:24,033 --> 00:06:26,334
so that you're transferring
a lot of data.

181
00:06:26,334 --> 00:06:27,801
On an EDGE connection,

182
00:06:27,801 --> 00:06:31,267
it costs about 250 milliamps
to run that radio at full-speed.

183
00:06:31,267 --> 00:06:33,400
And then finally, WiFi,
which costs the most.

184
00:06:33,400 --> 00:06:38,534
It's about 275 milliamps
to run that at full-speed.

185
00:06:38,534 --> 00:06:40,400
So now that we know
where it actually goes,

186
00:06:40,400 --> 00:06:41,534
let's compare those numbers.

187
00:06:41,534 --> 00:06:43,100
Let's take a moment
and step back

188
00:06:43,100 --> 00:06:45,133
and think,
do these numbers make sense?

189
00:06:45,133 --> 00:06:48,200
Do these match up with
the real life battery statistics

190
00:06:48,200 --> 00:06:49,534
we're seeing in the field?

191
00:06:49,534 --> 00:06:51,100
So let's take
a couple of examples.

192
00:06:51,100 --> 00:06:52,901
Let's say you're watching
a YouTube video.

193
00:06:52,901 --> 00:06:55,334
So this is something--
we're watching it on 3G.

194
00:06:55,334 --> 00:06:56,801
So we have the 3G radio
spun up.

195
00:06:56,801 --> 00:06:58,667
We're doing a good amount
of data transfer.

196
00:06:58,667 --> 00:07:00,033
We're transferring video.

197
00:07:00,033 --> 00:07:01,400
The CPU's doing a lot of work.

198
00:07:01,400 --> 00:07:02,767
It's decoding the video

199
00:07:02,767 --> 00:07:04,234
and then putting it
on the screen for the user.

200
00:07:04,234 --> 00:07:05,767
And then they have
the LCD on.

201
00:07:05,767 --> 00:07:07,901
So in total,
watching a YouTube video,

202
00:07:07,901 --> 00:07:10,701
it's pulling about
340 milliamps of current.

203
00:07:10,701 --> 00:07:13,434
That's how much current
it's using to show the video.

204
00:07:13,434 --> 00:07:15,734
And so we have those
two units of measurement,

205
00:07:15,734 --> 00:07:18,200
or those two units,

206
00:07:18,200 --> 00:07:20,968
and we can divide it
by the capacity in the device,

207
00:07:20,968 --> 00:07:23,734
and we can figure out how long
the device should last,

208
00:07:23,734 --> 00:07:26,200
the expected life
of the device.

209
00:07:26,200 --> 00:07:27,834
So something playing
a YouTube video,

210
00:07:27,834 --> 00:07:31,033
at 1,150 milliamp hours,
the capacity in the battery

211
00:07:31,033 --> 00:07:34,434
should last us about
3 1/2 hours of actual use,

212
00:07:34,434 --> 00:07:37,234
of the person, if they watched
YouTube video continuously.

213
00:07:37,234 --> 00:07:40,334
Something a little more
typical--browsing the 3G web.

214
00:07:40,334 --> 00:07:41,567
So it's a little bit cheaper.

215
00:07:41,567 --> 00:07:43,067
We're not doing as much
data transfer.

216
00:07:43,067 --> 00:07:44,834
It's about 225 milliamps

217
00:07:44,834 --> 00:07:47,133
or about
five hours of battery life.

218
00:07:47,133 --> 00:07:49,000
So that's if the user's
sitting there

219
00:07:49,000 --> 00:07:52,434
interacting with the device
solid for three or four hours.

220
00:07:52,434 --> 00:07:53,968
A more typical use case

221
00:07:53,968 --> 00:07:55,701
is that they pull it
out of their pocket

222
00:07:55,701 --> 00:07:57,567
maybe once or twice an hour.

223
00:07:57,567 --> 00:07:59,300
They're not interacting
with it very much.

224
00:07:59,300 --> 00:08:00,901
Most of the time
it's in their pocket.

225
00:08:00,901 --> 00:08:02,901
So a typical use case,
we can think of

226
00:08:02,901 --> 00:08:04,467
the device being turned on

227
00:08:04,467 --> 00:08:06,567
about ten minutes
out of every hour.

228
00:08:06,567 --> 00:08:08,767
So we have the device turned on
and doing activities

229
00:08:08,767 --> 00:08:10,167
for about ten minutes,

230
00:08:10,167 --> 00:08:12,133
and the other 50 minutes
of that hour,

231
00:08:12,133 --> 00:08:13,734
the device
is in the person's pocket.

232
00:08:13,734 --> 00:08:14,901
It's asleep.

233
00:08:14,901 --> 00:08:18,000
It's using
very little current.

234
00:08:18,000 --> 00:08:19,601
So if we average that out,

235
00:08:19,601 --> 00:08:22,367
it's about 42 milliamps
on average, over an hour.

236
00:08:22,367 --> 00:08:24,934
So if we do the computation,
that battery life ends up--

237
00:08:24,934 --> 00:08:26,634
the battery life
in that case

238
00:08:26,634 --> 00:08:28,767
ends up being about
32 hours.

239
00:08:28,767 --> 00:08:30,934
And that's fairly typical.

240
00:08:30,934 --> 00:08:32,734
That's usually what we're seeing
from people out in the field

241
00:08:32,734 --> 00:08:34,400
that are using G1 devices.

242
00:08:34,400 --> 00:08:37,400
They usually see a battery life
that lasts them about a day.

243
00:08:37,400 --> 00:08:39,934
So then let's take a look at
the other end of the spectrum.

244
00:08:39,934 --> 00:08:41,100
Let's say we have a device

245
00:08:41,100 --> 00:08:42,767
that's just sitting there
completely idle.

246
00:08:42,767 --> 00:08:44,934
The user isn't interacting
with it at all.

247
00:08:44,934 --> 00:08:48,400
So the number that we measured
earlier was 5 milliamps.

248
00:08:48,400 --> 00:08:50,567
That's the amount of current
that it was pulling.

249
00:08:50,567 --> 00:08:53,000
If we do the math--
the 1,150 milliamp hours,

250
00:08:53,000 --> 00:08:54,534
the capacity of the battery,

251
00:08:54,534 --> 00:08:56,734
should last us
about 9 1/2 days

252
00:08:56,734 --> 00:08:58,267
and even further

253
00:08:58,267 --> 00:08:59,801
if we have the device
in an airplane mode.

254
00:08:59,801 --> 00:09:01,434
So all the radios
are turned off,

255
00:09:01,434 --> 00:09:02,834
we're only pulling
that 2 milliamps,

256
00:09:02,834 --> 00:09:04,467
it should last about
24 days.

257
00:09:04,467 --> 00:09:06,534
Then we can ask the question,

258
00:09:06,534 --> 00:09:08,400
where did
all that battery life go?

259
00:09:08,400 --> 00:09:09,701
What's happening
in between?

260
00:09:09,701 --> 00:09:11,400
What costs the most?

261
00:09:11,400 --> 00:09:12,667
What are we doing
in the background

262
00:09:12,667 --> 00:09:14,534
that's using
all of that battery,

263
00:09:14,534 --> 00:09:16,634
all of that capacity
that the phone could use

264
00:09:16,634 --> 00:09:20,834
to last longer?

265
00:09:24,534 --> 00:09:27,534
So we can ask the question,
what costs the most?

266
00:09:27,534 --> 00:09:29,367
And the first thing
at the top of the list

267
00:09:29,367 --> 00:09:31,167
is waking up in the background,

268
00:09:31,167 --> 00:09:33,501
and this is when the phone
would otherwise be asleep

269
00:09:33,501 --> 00:09:35,033
in your pocket.

270
00:09:35,033 --> 00:09:36,701
You can have background tasks
that wake up

271
00:09:36,701 --> 00:09:39,400
to go check the person's email,
say every 15 or 20 minutes

272
00:09:39,400 --> 00:09:41,601
or every half hour.

273
00:09:41,601 --> 00:09:43,400
Or maybe an incoming email
comes in

274
00:09:43,400 --> 00:09:46,133
and needs to do
some network activity.

275
00:09:46,133 --> 00:09:48,868
Things that the device
wakes up to do in the background

276
00:09:48,868 --> 00:09:50,567
when it would
otherwise be asleep

277
00:09:50,567 --> 00:09:53,601
end up costing a lot
towards battery life.

278
00:09:53,601 --> 00:09:55,467
So let's take
a typical example.

279
00:09:55,467 --> 00:09:58,701
Let's say you're writing
an app that checks RSS feeds

280
00:09:58,701 --> 00:10:00,300
for new incoming posts.

281
00:10:00,300 --> 00:10:02,133
And let's check
every ten minutes.

282
00:10:02,133 --> 00:10:05,033
So this is just an example app
just for the sake of example.

283
00:10:05,033 --> 00:10:06,567
And when it wakes up
in the background,

284
00:10:06,567 --> 00:10:08,100
it probably takes
about eight seconds

285
00:10:08,100 --> 00:10:09,334
to perform a full update.

286
00:10:09,334 --> 00:10:10,434
When you think of it,

287
00:10:10,434 --> 00:10:11,801
we're pulling up
the radio stack,

288
00:10:11,801 --> 00:10:13,167
we're going and we're doing
a DNS request,

289
00:10:13,167 --> 00:10:14,601
doing a network connection,

290
00:10:14,601 --> 00:10:16,868
pulling down the page,
doing parsing on the device.

291
00:10:16,868 --> 00:10:18,300
And then it takes a few seconds

292
00:10:18,300 --> 00:10:19,868
for the device
to settle back down

293
00:10:19,868 --> 00:10:22,934
and fall into
a sleep mode again.

294
00:10:22,934 --> 00:10:25,434
So about eight seconds.

295
00:10:25,434 --> 00:10:27,367
And the battery usage
during that period

296
00:10:27,367 --> 00:10:30,467
is about 300--
let's say 350 milliamps.

297
00:10:30,467 --> 00:10:31,868
We don't have the screen on,

298
00:10:31,868 --> 00:10:34,601
but we're using a lot of data
and a lot of CPU.

299
00:10:34,601 --> 00:10:36,701
So now let's take a look

300
00:10:36,701 --> 00:10:40,534
at what this would cost
during a given hour.

301
00:10:40,534 --> 00:10:42,133
So the idle cost,

302
00:10:42,133 --> 00:10:44,467
if the device was completely
idle for that hour,

303
00:10:44,467 --> 00:10:46,167
it would cost us about
5 milliamp hours.

304
00:10:46,167 --> 00:10:47,634
That's the cost of the device

305
00:10:47,634 --> 00:10:49,133
just sitting there
completely idle.

306
00:10:49,133 --> 00:10:50,767
But as soon as we add in
this application

307
00:10:50,767 --> 00:10:52,567
that's waking up
in the background,

308
00:10:52,567 --> 00:10:54,067
doing these seemingly innocent--

309
00:10:54,067 --> 00:10:56,000
just going out and checking,
checking in our assess feed,

310
00:10:56,000 --> 00:10:58,467
we do the math--
six times every ten minutes,

311
00:10:58,467 --> 00:11:01,000
six times an hour times the
eight seconds for each update,

312
00:11:01,000 --> 00:11:02,868
times the 350 milliamps.

313
00:11:02,868 --> 00:11:04,667
The amount of current
that we're using there

314
00:11:04,667 --> 00:11:06,400
is about 4.6 milliamp hours.

315
00:11:06,400 --> 00:11:10,367
That's the amount that we're
taking for this app to run.

316
00:11:10,367 --> 00:11:12,167
So just this small,
innocent app

317
00:11:12,167 --> 00:11:15,434
is actually cutting
the user's battery life in half.

318
00:11:15,434 --> 00:11:17,567
And that's really something
to realize.

319
00:11:17,567 --> 00:11:19,634
Apps like these are waking up,

320
00:11:19,634 --> 00:11:22,100
and they can start using
a lot of the user's battery

321
00:11:22,100 --> 00:11:23,367
without them even knowing.

322
00:11:23,367 --> 00:11:25,934
They think the device is turned
off and in their pocket.

323
00:11:25,934 --> 00:11:27,601
And another thing to realize

324
00:11:27,601 --> 00:11:29,200
is that these apps waking up,

325
00:11:29,200 --> 00:11:31,567
it's not just your update
that might happen.

326
00:11:31,567 --> 00:11:34,067
On the system,
we have a notion of services

327
00:11:34,067 --> 00:11:35,434
that can only wake up,

328
00:11:35,434 --> 00:11:37,267
that can set alarms
for themselves,

329
00:11:37,267 --> 00:11:39,868
that only wake up when
the device is already awake.

330
00:11:39,868 --> 00:11:43,334
So if the device--if you
force the device awake,

331
00:11:43,334 --> 00:11:45,534
other services may piggyback

332
00:11:45,534 --> 00:11:47,667
on top of your waking up
of the device.

333
00:11:47,667 --> 00:11:51,501
So it actually--
it compounds itself.

334
00:11:51,501 --> 00:11:54,167
Other apps jump on,
and you can cascade a trigger--

335
00:11:54,167 --> 00:11:56,968
or you can trigger a cascade
of several of these updates

336
00:11:56,968 --> 00:11:58,701
all happening
at the same time.

337
00:11:58,701 --> 00:12:00,467
So it might not just be
your eight seconds.

338
00:12:00,467 --> 00:12:02,000
If you wake up
for your eight seconds,

339
00:12:02,000 --> 00:12:04,901
you might end up forcing
the phone awake

340
00:12:04,901 --> 00:12:06,501
for 15 or 20 seconds

341
00:12:06,501 --> 00:12:10,968
as other apps try to pile on
and do their updates as well.

342
00:12:14,634 --> 00:12:16,834
[coughs]

343
00:12:16,834 --> 00:12:18,367
So what else
costs the most?

344
00:12:18,367 --> 00:12:21,367
Another thing that costs a lot
is bulk data transfer.

345
00:12:21,367 --> 00:12:23,834
So we have phones
with data connections.

346
00:12:23,834 --> 00:12:26,400
You can think of them
transferring bulk data.

347
00:12:26,400 --> 00:12:28,534
We have people that are
watching videos on YouTube.

348
00:12:28,534 --> 00:12:30,300
We have people
that are generating content.

349
00:12:30,300 --> 00:12:31,734
They're taking pictures
and videos,

350
00:12:31,734 --> 00:12:33,300
and they want to upload those.

351
00:12:33,300 --> 00:12:35,667
So we have heavy data traffic
in both directions.

352
00:12:35,667 --> 00:12:37,267
And it ends up
that bulk data transfer

353
00:12:37,267 --> 00:12:38,767
can actually cost a lot

354
00:12:38,767 --> 00:12:40,734
towards the life
of a person's battery.

355
00:12:40,734 --> 00:12:43,334
So if we look at three different
types of data connections

356
00:12:43,334 --> 00:12:45,434
that are available
on the phone today,

357
00:12:45,434 --> 00:12:48,634
we have an EDGE connection,
a 3G, and a WiFi connection.

358
00:12:48,634 --> 00:12:51,000
And they all cost roughly
about the same,

359
00:12:51,000 --> 00:12:54,567
anywhere from 210
to 330 milliamps.

360
00:12:54,567 --> 00:12:56,000
Those numbers
are slightly different

361
00:12:56,000 --> 00:12:58,434
'cause we're including CPU
in those numbers

362
00:12:58,434 --> 00:13:00,067
from the numbers
that I mentioned earlier.

363
00:13:00,067 --> 00:13:01,701
That's why
they're slightly different.

364
00:13:01,701 --> 00:13:03,834
So they all cost roughly
in the same ballpark

365
00:13:03,834 --> 00:13:05,067
to run those data connections.

366
00:13:05,067 --> 00:13:06,601
The key differentiator

367
00:13:06,601 --> 00:13:08,501
is that they can transfer
at different rates.

368
00:13:08,501 --> 00:13:10,434
A 3G connection
is a lot more efficient.

369
00:13:10,434 --> 00:13:13,000
It can transfer data a lot
faster than an EDGE connection.

370
00:13:13,000 --> 00:13:14,501
Or even if you're familiar,

371
00:13:14,501 --> 00:13:16,434
there's a notion of
a GPRS connection

372
00:13:16,434 --> 00:13:18,734
which is even slower
than EDGE--

373
00:13:18,734 --> 00:13:20,567
which is
even slower than EDGE,

374
00:13:20,567 --> 00:13:22,868
whereas WiFi can transfer
stuff a lot faster.

375
00:13:22,868 --> 00:13:25,501
So let's take an example
of a 6 megabyte song.

376
00:13:25,501 --> 00:13:27,968
You're writing a music store
application

377
00:13:27,968 --> 00:13:29,434
for a person
to go buy music,

378
00:13:29,434 --> 00:13:31,601
and you need to transfer
6 megabytes down to the phone.

379
00:13:31,601 --> 00:13:33,334
This is just bulk data transfer.

380
00:13:33,334 --> 00:13:35,133
We can do the math,
and we can figure out

381
00:13:35,133 --> 00:13:37,000
how long it would take
in each of those cases.

382
00:13:37,000 --> 00:13:40,334
To do that transfer on EDGE,
it takes about nine minutes.

383
00:13:40,334 --> 00:13:42,234
But to do it on WiFi,
which is a lot faster,

384
00:13:42,234 --> 00:13:46,234
it takes under a minute,
about 46, 48 seconds.

385
00:13:46,234 --> 00:13:48,634
But then, consider
that we have to multiply that

386
00:13:48,634 --> 00:13:52,234
by how much the battery
is being used over that time.

387
00:13:52,234 --> 00:13:54,901
So something like an EDGE
transfer, the nine minutes,

388
00:13:54,901 --> 00:13:57,501
ends up costing us
45 milliamp hours.

389
00:13:57,501 --> 00:14:00,334
That's how much battery we're
using to do that data transfer.

390
00:14:00,334 --> 00:14:03,200
That same data transfer,
that same 6 megabytes

391
00:14:03,200 --> 00:14:05,767
would cost us
an order of magnitude less

392
00:14:05,767 --> 00:14:07,300
if we did it over WiFi,

393
00:14:07,300 --> 00:14:10,067
if we waited around
to get a faster connection.

394
00:14:10,067 --> 00:14:12,901
It costs only less than
5 milliamp hours.

395
00:14:12,901 --> 00:14:16,801
So it's less than 10%
of the original cost.

396
00:14:16,801 --> 00:14:18,534
Other things
that end up costing a lot

397
00:14:18,534 --> 00:14:20,501
are moving between
cells and networks.

398
00:14:20,501 --> 00:14:22,300
So as the phone--
you can think of a phone,

399
00:14:22,300 --> 00:14:24,501
as a person commutes with it
different locations,

400
00:14:24,501 --> 00:14:27,968
the phone radio ramps up
to associate with new cells.

401
00:14:27,968 --> 00:14:30,234
So as I drove here
this morning on a bus,

402
00:14:30,234 --> 00:14:33,067
my phone transferred between
multiple cell towers

403
00:14:33,067 --> 00:14:34,501
as I went along the road,

404
00:14:34,501 --> 00:14:37,501
if you're riding Caltrain
or something like that.

405
00:14:37,501 --> 00:14:40,100
So this is something
we can't avoid,

406
00:14:40,100 --> 00:14:42,634
the radio chipset needs to
wake up and be always associated

407
00:14:42,634 --> 00:14:44,567
so that the user can receive
incoming text

408
00:14:44,567 --> 00:14:46,100
and incoming phone calls.

409
00:14:46,100 --> 00:14:47,901
But on Android,
we also wake up the system

410
00:14:47,901 --> 00:14:49,100
to possibly deal--

411
00:14:49,100 --> 00:14:50,501
Maybe your app,
maybe an app on the system

412
00:14:50,501 --> 00:14:52,634
is interested
when the connectivity changes.

413
00:14:52,634 --> 00:14:54,300
For example,
if you have a photo

414
00:14:54,300 --> 00:14:56,100
that the user
wanted to upload,

415
00:14:56,100 --> 00:14:57,901
you might want to check to see

416
00:14:57,901 --> 00:14:59,567
if the network connection
goes up and down.

417
00:14:59,567 --> 00:15:01,234
So if the network connection
comes back up,

418
00:15:01,234 --> 00:15:02,767
you may want to finish
uploading your video.

419
00:15:02,767 --> 00:15:04,567
So we actually--
the Android operating system

420
00:15:04,567 --> 00:15:07,801
allows us to wake up
applications in the background

421
00:15:07,801 --> 00:15:09,834
using the notion
of broadcast intents.

422
00:15:09,834 --> 00:15:11,133
I'll get into that
a little bit later,

423
00:15:11,133 --> 00:15:13,467
but those actually
cost a lot towards battery,

424
00:15:13,467 --> 00:15:16,100
especially when we're waking up
those applications

425
00:15:16,100 --> 00:15:17,601
and they aren't
going to do anything.

426
00:15:17,601 --> 00:15:19,968
If we wake it up to tell it
network connectivity changed

427
00:15:19,968 --> 00:15:22,567
and it decides,
"I don't need to do anything,"

428
00:15:22,567 --> 00:15:24,767
it can end up costing a lot.

429
00:15:24,767 --> 00:15:27,534
Two other things in the end
that end up costing a lot

430
00:15:27,534 --> 00:15:28,934
are textual data.

431
00:15:28,934 --> 00:15:32,133
So if we're receiving
that RSS feed down from XML,

432
00:15:32,133 --> 00:15:33,701
parsing that on the device

433
00:15:33,701 --> 00:15:35,067
can actually be
really expensive.

434
00:15:35,067 --> 00:15:36,634
We're walking through
the text data,

435
00:15:36,634 --> 00:15:37,868
we're trying to parse it.

436
00:15:37,868 --> 00:15:39,968
You can think of all
the different data formats

437
00:15:39,968 --> 00:15:41,367
that you might have out there,

438
00:15:41,367 --> 00:15:44,167
XML or JSON or even YAML,
Yet Another Markup Language,

439
00:15:44,167 --> 00:15:47,601
which is--its structure
is based on spaces,

440
00:15:47,601 --> 00:15:50,300
so there's a lot of textual data
that it has to parse through.

441
00:15:50,300 --> 00:15:52,434
So parsing through text data
that comes from the web

442
00:15:52,434 --> 00:15:53,868
can be really expensive,

443
00:15:53,868 --> 00:15:55,968
and I'll touch on that
a little bit later

444
00:15:55,968 --> 00:15:57,167
the differences between them.

445
00:15:57,167 --> 00:15:58,567
And finally, another thing

446
00:15:58,567 --> 00:16:00,033
that ends up costing a lot
on the device

447
00:16:00,033 --> 00:16:02,567
is regular expressions,
especially on Android.

448
00:16:02,567 --> 00:16:04,234
So the current virtual
machine that we're using,

449
00:16:04,234 --> 00:16:08,167
the Dalvik VM, doesn't have
just-in-time compiling,

450
00:16:08,167 --> 00:16:11,334
which is a luxury
that a lot of people are used to

451
00:16:11,334 --> 00:16:12,934
from the desktop world.

452
00:16:12,934 --> 00:16:14,634
So in a desktop
virtual machine,

453
00:16:14,634 --> 00:16:16,434
if we run into
a regular expression,

454
00:16:16,434 --> 00:16:19,367
the desktop machine can actually
compile a regular expression

455
00:16:19,367 --> 00:16:23,033
into really fast, tight code
that runs very efficiently.

456
00:16:23,033 --> 00:16:25,534
But on a platform like Android,

457
00:16:25,534 --> 00:16:26,834
the current virtual machine

458
00:16:26,834 --> 00:16:28,501
that doesn't support
just-in-time compiling,

459
00:16:28,501 --> 00:16:29,834
this can actually be
pretty expensive.

460
00:16:29,834 --> 00:16:32,601
It can't optimize that
just yet.

461
00:16:32,601 --> 00:16:35,934
So those are some things
to be aware of.

462
00:16:40,934 --> 00:16:42,367
So then we can ask
the question--

463
00:16:42,367 --> 00:16:44,801
we know what the battery
capacity that we're looking at.

464
00:16:44,801 --> 00:16:46,434
We know what things cost.

465
00:16:46,434 --> 00:16:47,734
And now we know

466
00:16:47,734 --> 00:16:49,367
what things actually
cost a lot on the device.

467
00:16:49,367 --> 00:16:51,501
So how can we do better
as we're developers,

468
00:16:51,501 --> 00:16:53,267
as we're out there
writing apps?

469
00:16:53,267 --> 00:16:55,501
Today I'll be splitting this up
into three separate sections.

470
00:16:55,501 --> 00:16:58,534
We're gonna talk first about
foreground applications.

471
00:16:58,534 --> 00:17:00,934
First we'll talk about
networking,

472
00:17:00,934 --> 00:17:03,968
then foreground apps,
and finally background apps.

473
00:17:03,968 --> 00:17:05,934
So first, networking.

474
00:17:05,934 --> 00:17:07,467
Check the network connection.

475
00:17:07,467 --> 00:17:09,234
So this comes back
to you're about to do

476
00:17:09,234 --> 00:17:11,033
a set of bulk data transfers.

477
00:17:11,033 --> 00:17:12,701
You have that 6 megabyte song

478
00:17:12,701 --> 00:17:14,367
that the user
wants to have downloaded.

479
00:17:14,367 --> 00:17:16,200
Something that you can do
as a developer

480
00:17:16,200 --> 00:17:18,367
is you can check
the current network connection

481
00:17:18,367 --> 00:17:20,434
that the user is on,
that the device is on.

482
00:17:20,434 --> 00:17:21,801
So for example,

483
00:17:21,801 --> 00:17:23,467
if you know you need
to download a lot of data,

484
00:17:23,467 --> 00:17:24,834
maybe you'll hold off
on that transfer

485
00:17:24,834 --> 00:17:27,667
until the user comes into
an area with 3G coverage

486
00:17:27,667 --> 00:17:29,501
or they connect
to a WiFi network.

487
00:17:29,501 --> 00:17:31,734
So this is a quick
code snippet example

488
00:17:31,734 --> 00:17:33,367
that...Android makes it
really easy

489
00:17:33,367 --> 00:17:35,501
to check to see what kind
of network you're on.

490
00:17:35,501 --> 00:17:38,501
So I skipped past it.
It was on the first slide here.

491
00:17:38,501 --> 00:17:40,000
There's a notion
of a connectivity

492
00:17:40,000 --> 00:17:41,467
and a telephony manager

493
00:17:41,467 --> 00:17:44,033
that you can get references to
if you have a context in Java.

494
00:17:44,033 --> 00:17:46,734
So with
the connectivity manager,

495
00:17:46,734 --> 00:17:48,868
we can get an instance
of the current network info,

496
00:17:48,868 --> 00:17:50,501
and that's what
this info object is.

497
00:17:50,501 --> 00:17:51,734
And we can probe it.

498
00:17:51,734 --> 00:17:54,133
We can ask it what type
of network we're on,

499
00:17:54,133 --> 00:17:56,734
that the user is currently on,
what subtype of network.

500
00:17:56,734 --> 00:17:58,400
And then we can do
some pretty quick logic

501
00:17:58,400 --> 00:18:01,234
to check to see if we should
actually perform a transfer.

502
00:18:01,234 --> 00:18:02,767
So in this case,
the first if block

503
00:18:02,767 --> 00:18:05,033
is checking to see
if we're on a network connection

504
00:18:05,033 --> 00:18:06,400
of type WiFi,

505
00:18:06,400 --> 00:18:09,567
and if that's the type
that's currently enabled

506
00:18:09,567 --> 00:18:11,501
and we're connected
to that network, return true.

507
00:18:11,501 --> 00:18:13,400
Let's actually perform
the data transfer,

508
00:18:13,400 --> 00:18:14,400
'cause WiFi's fast.

509
00:18:14,400 --> 00:18:16,000
It'll be cheap.

510
00:18:16,000 --> 00:18:17,901
Otherwise, if we're on
a mobile network...

511
00:18:17,901 --> 00:18:20,234
let's check to see
if we're on a 3G network.

512
00:18:20,234 --> 00:18:22,200
Another name for this
is UMTS.

513
00:18:22,200 --> 00:18:24,434
There's several different
3G technologies,

514
00:18:24,434 --> 00:18:26,634
but this is the one
that we have the constants for

515
00:18:26,634 --> 00:18:28,234
in the platform right now.

516
00:18:28,234 --> 00:18:30,467
And finally, one other thing
that you can do as developers

517
00:18:30,467 --> 00:18:31,767
is you might be smart--

518
00:18:31,767 --> 00:18:34,133
you might check to see
if the user's roaming.

519
00:18:34,133 --> 00:18:36,667
Roaming data can end up
costing users a lot,

520
00:18:36,667 --> 00:18:38,601
so if this is just something
in the background

521
00:18:38,601 --> 00:18:41,667
and you're offering to download
music for the user,

522
00:18:41,667 --> 00:18:43,267
this can end up costing a lot,

523
00:18:43,267 --> 00:18:45,534
especially not only time
and battery-wise,

524
00:18:45,534 --> 00:18:47,033
but monetarily,

525
00:18:47,033 --> 00:18:48,834
when they get their bill
at the end of the month.

526
00:18:48,834 --> 00:18:51,267
So this is just one of those
flags that we can check to see

527
00:18:51,267 --> 00:18:52,834
is the network roaming,

528
00:18:52,834 --> 00:18:56,334
some stuff that we can check
to help our users in the end.

529
00:18:56,334 --> 00:18:58,267
So if that returns true,
we can go ahead

530
00:18:58,267 --> 00:19:00,067
if we're actually connected
to a 3G network

531
00:19:00,067 --> 00:19:01,467
and we're not roaming.

532
00:19:01,467 --> 00:19:03,300
Otherwise,
we can return false.

533
00:19:03,300 --> 00:19:05,167
Some other choices here too.

534
00:19:05,167 --> 00:19:06,767
Instead of
just returning false,

535
00:19:06,767 --> 00:19:09,367
you might choose to involve
the user in the process.

536
00:19:09,367 --> 00:19:12,334
So if the user takes a video
and they wanna upload it online,

537
00:19:12,334 --> 00:19:14,234
if you know that you're
on an EDGE connection,

538
00:19:14,234 --> 00:19:15,901
you might actually
do the math--

539
00:19:15,901 --> 00:19:19,334
do some quick math
in the code to see:

540
00:19:19,334 --> 00:19:22,634
would I be able to transfer
this without killing the device?

541
00:19:22,634 --> 00:19:24,567
Is there enough
battery life left?

542
00:19:24,567 --> 00:19:26,033
And you might involve
the user in the process

543
00:19:26,033 --> 00:19:27,734
and just tell them,
transferring this file--

544
00:19:27,734 --> 00:19:29,567
transferring this raw data
over EDGE--

545
00:19:29,567 --> 00:19:31,234
is gonna cost you a lot.

546
00:19:31,234 --> 00:19:32,834
You might actually lose
your device,

547
00:19:32,834 --> 00:19:34,701
because it would suck
all the battery life

548
00:19:34,701 --> 00:19:36,901
out of your device,
and I may not even finish.

549
00:19:36,901 --> 00:19:38,634
And you might ask the user

550
00:19:38,634 --> 00:19:40,434
if they really want
to go ahead with that.

551
00:19:40,434 --> 00:19:43,467
So instead of just
blanketedly canceling,

552
00:19:43,467 --> 00:19:44,801
you might involve them
with that process

553
00:19:44,801 --> 00:19:46,234
and allow them
to override it,

554
00:19:46,234 --> 00:19:48,067
'cause there's certain
instances where they may

555
00:19:48,067 --> 00:19:50,400
really want photos
to be uploaded right away.

556
00:19:50,400 --> 00:19:51,968
It also allows them
to be aware of--

557
00:19:51,968 --> 00:19:53,234
so if they're on
an EDGE connection

558
00:19:53,234 --> 00:19:54,634
and you inform them,

559
00:19:54,634 --> 00:19:56,901
they might know of
a WiFi hotspot down the street

560
00:19:56,901 --> 00:19:58,300
that they can go connect to.

561
00:19:58,300 --> 00:20:00,300
So involving them
in that process can really--

562
00:20:00,300 --> 00:20:03,267
you're helping them
save battery.

563
00:20:03,267 --> 00:20:05,100
One other thing
that we can check.

564
00:20:05,100 --> 00:20:06,934
So this is jumping back
a slide.

565
00:20:06,934 --> 00:20:10,200
In the Settings app right now,
Settings and Synchronization,

566
00:20:10,200 --> 00:20:11,767
there's a check box in there,

567
00:20:11,767 --> 00:20:13,834
and the user can change
the preference

568
00:20:13,834 --> 00:20:15,501
for using background data.

569
00:20:15,501 --> 00:20:19,901
Right now, all of the Google
services that are on the device

570
00:20:19,901 --> 00:20:21,434
look at that check box,

571
00:20:21,434 --> 00:20:24,000
and that's how they figure out
what the user wants to do

572
00:20:24,000 --> 00:20:26,968
as far as data happening
in the background on the device.

573
00:20:26,968 --> 00:20:29,167
So if the user un-checks
that box,

574
00:20:29,167 --> 00:20:31,200
the Google services
will actually turn off,

575
00:20:31,200 --> 00:20:33,467
and they will only synchronize
if the user goes into the app

576
00:20:33,467 --> 00:20:34,734
and forces it,

577
00:20:34,734 --> 00:20:36,868
or if they come back
and turn on this check box.

578
00:20:36,868 --> 00:20:38,234
So this is something
you as developers

579
00:20:38,234 --> 00:20:39,501
can also run in a check.

580
00:20:39,501 --> 00:20:41,000
If you have
a connectivity manager object,

581
00:20:41,000 --> 00:20:43,000
you can check to see
the state of that flag.

582
00:20:43,000 --> 00:20:44,901
And this is something
that's new in Cupcake.

583
00:20:44,901 --> 00:20:46,634
And I'll be mentioning
a couple of features

584
00:20:46,634 --> 00:20:48,734
that have come out
in the Cupcake

585
00:20:48,734 --> 00:20:50,767
or the 1.5 SDK
that recently came out,

586
00:20:50,767 --> 00:20:52,033
and I'll just indicate them

587
00:20:52,033 --> 00:20:53,334
with a little icon over there
on the right.

588
00:20:53,334 --> 00:20:54,901
So that's just something
to be aware of

589
00:20:54,901 --> 00:20:56,701
as we go through the rest
of the presentation today.

590
00:21:02,834 --> 00:21:04,567
So we talked about...

591
00:21:04,567 --> 00:21:06,734
we talked about
bulk data transfer

592
00:21:06,734 --> 00:21:09,067
involving the user
in that process.

593
00:21:09,067 --> 00:21:11,033
One of the other things
that can cost us a lot

594
00:21:11,033 --> 00:21:13,300
networking-wise
is doing textual data,

595
00:21:13,300 --> 00:21:15,701
is transferring and parsing
that text data.

596
00:21:15,701 --> 00:21:17,868
And as developers, we have
a lot of different choices.

597
00:21:17,868 --> 00:21:19,868
A lot of us have
a favored data format

598
00:21:19,868 --> 00:21:21,701
that we like pushing stuff
across the web.

599
00:21:21,701 --> 00:21:26,234
If you come from a restful
approach of doing web services,

600
00:21:26,234 --> 00:21:28,067
maybe you're used to XML.

601
00:21:28,067 --> 00:21:30,968
Or maybe you wrap your data
in a JSON format.

602
00:21:30,968 --> 00:21:32,934
Or maybe you're used to other
different formats

603
00:21:32,934 --> 00:21:35,234
such as YAML,
Yet Another Markup Language,

604
00:21:35,234 --> 00:21:37,133
or some of
these other formats.

605
00:21:37,133 --> 00:21:40,601
Another popular protocol--
or another popular data format

606
00:21:40,601 --> 00:21:42,334
for passing stuff
across the web

607
00:21:42,334 --> 00:21:44,033
is using a binary format.

608
00:21:44,033 --> 00:21:46,634
So if you're used to
something called ASN.1,

609
00:21:46,634 --> 00:21:48,567
it's a public standard
for parsing,

610
00:21:48,567 --> 00:21:52,200
for packaging and parceling
binary data across the web.

611
00:21:52,200 --> 00:21:54,801
Or something we've developed
here, it's similar.

612
00:21:54,801 --> 00:21:57,100
It's another binary form.
It's called protocol buffers.

613
00:21:57,100 --> 00:21:59,234
It's something that we've
open sourced here at Google.

614
00:21:59,234 --> 00:22:02,000
And so it's a slightly more
efficient way

615
00:22:02,000 --> 00:22:04,000
of packing data
across the network.

616
00:22:04,000 --> 00:22:05,367
So you have
all of these choices

617
00:22:05,367 --> 00:22:06,701
for the different protocols

618
00:22:06,701 --> 00:22:08,100
when communicating
with the device.

619
00:22:08,100 --> 00:22:11,267
So we can ask the question,
which one is the cheapest?

620
00:22:11,267 --> 00:22:12,567
What are the best choices?

621
00:22:12,567 --> 00:22:15,601
So it boils down--
we need to back up a second,

622
00:22:15,601 --> 00:22:17,067
and we need ask ourselves
the question,

623
00:22:17,067 --> 00:22:19,167
what type of parser
are we actually going to use

624
00:22:19,167 --> 00:22:20,534
on the device?

625
00:22:20,534 --> 00:22:23,300
Most parsers fall into
one of two categories.

626
00:22:23,300 --> 00:22:24,801
It's either a tree parser

627
00:22:24,801 --> 00:22:27,234
or an event
or stream-based parser.

628
00:22:27,234 --> 00:22:28,934
So a tree parser
is something,

629
00:22:28,934 --> 00:22:30,534
if you're used to
in the desktop world

630
00:22:30,534 --> 00:22:31,968
of working with a DOM

631
00:22:31,968 --> 00:22:33,400
or the Document Object Model
in a browser,

632
00:22:33,400 --> 00:22:36,000
it parses the entire document
into an in-memory tree

633
00:22:36,000 --> 00:22:37,734
that then you can go
and interact with

634
00:22:37,734 --> 00:22:39,200
and pull data out of.

635
00:22:39,200 --> 00:22:41,000
But that tree can become
really expensive

636
00:22:41,000 --> 00:22:42,334
on a mobile device.

637
00:22:42,334 --> 00:22:43,467
You're building
the entire document

638
00:22:43,467 --> 00:22:44,901
into an in-memory structure.

639
00:22:44,901 --> 00:22:46,200
And maybe you're just going

640
00:22:46,200 --> 00:22:47,767
 and pulling some of the data
out of that tree,

641
00:22:47,767 --> 00:22:49,400
and then you end up
having to dispose it.

642
00:22:49,400 --> 00:22:51,901
It becomes garbage that the
system then has to collect.

643
00:22:51,901 --> 00:22:54,167
It become somewhat wasteful.

644
00:22:54,167 --> 00:22:56,767
So tree parsers can be
pretty wasteful in these cases,

645
00:22:56,767 --> 00:22:59,000
because they're generating
a lot of garbage.

646
00:22:59,000 --> 00:23:00,067
On the flip side,

647
00:23:00,067 --> 00:23:01,801
an event
or a stream-based parser

648
00:23:01,801 --> 00:23:04,501
allows you as a developer
to become directly involved

649
00:23:04,501 --> 00:23:06,200
with the parsing process.

650
00:23:06,200 --> 00:23:08,601
So as the parser
walks along a document,

651
00:23:08,601 --> 00:23:12,167
it might-- it actually has
callbacks to your code

652
00:23:12,167 --> 00:23:14,601
saying "I found the beginning
of a tag or the end of a tag,"

653
00:23:14,601 --> 00:23:16,968
or maybe "I found
a section of text or a number

654
00:23:16,968 --> 00:23:18,467
or an XML attribute."

655
00:23:18,467 --> 00:23:20,734
And it can make these callbacks
for you to handle in your code.

656
00:23:20,734 --> 00:23:22,501
It allows you to become
directly involved

657
00:23:22,501 --> 00:23:23,868
with the parsing process.

658
00:23:23,868 --> 00:23:26,133
The key takeaway there
is to realize

659
00:23:26,133 --> 00:23:28,100
that event
or stream-based parsers

660
00:23:28,100 --> 00:23:31,734
can be a lot more efficient
memory-wise than tree parsers.

661
00:23:31,734 --> 00:23:33,868
So this slide is a comparison
on the device.

662
00:23:33,868 --> 00:23:36,033
Let's say we have
a six-item RSS feed

663
00:23:36,033 --> 00:23:37,567
that we want to pull down
and parse from the web.

664
00:23:37,567 --> 00:23:38,834
And let's look at it

665
00:23:38,834 --> 00:23:40,300
from a number
of different data formats.

666
00:23:40,300 --> 00:23:41,701
Let's choose three.

667
00:23:41,701 --> 00:23:44,133
We have XML or JSON
or protocol buffers,

668
00:23:44,133 --> 00:23:46,067
which is a binary format.

669
00:23:46,067 --> 00:23:47,834
So in this case,
we see on the left

670
00:23:47,834 --> 00:23:50,400
those tree parsers in gray
end up being pretty expensive.

671
00:23:50,400 --> 00:23:51,801
It takes a lot of time

672
00:23:51,801 --> 00:23:53,868
to actually parse and handle
those documents.

673
00:23:53,868 --> 00:23:55,434
But then we see
on the right-hand side

674
00:23:55,434 --> 00:23:58,367
when we're using the event
or stream-based parsers,

675
00:23:58,367 --> 00:24:00,167
it ends up being
a lot cheaper,

676
00:24:00,167 --> 00:24:02,167
especially when we can see
the stair-step effect.

677
00:24:02,167 --> 00:24:05,400
XML is a little bit less
efficient than JSON.

678
00:24:05,400 --> 00:24:07,133
And then protocol buffers,

679
00:24:07,133 --> 00:24:08,868
because it's a binary
data format,

680
00:24:08,868 --> 00:24:10,701
ends up being
pretty efficient.

681
00:24:10,701 --> 00:24:11,968
Ends up being
the most efficient

682
00:24:11,968 --> 00:24:14,701
out of the ones
that we compared here.

683
00:24:14,701 --> 00:24:16,100
So the key takeaway is

684
00:24:16,100 --> 00:24:19,000
use those stream parsers
instead of the tree parsers.

685
00:24:19,000 --> 00:24:20,534
So this is something

686
00:24:20,534 --> 00:24:22,534
if you're using XML pull parser
on the device,

687
00:24:22,534 --> 00:24:25,901
that's one of the good parsers
that you should be using.

688
00:24:25,901 --> 00:24:29,100
Sad to say the JSON object
and the JSON array libraries

689
00:24:29,100 --> 00:24:31,334
that ship with the platform...
they're tree parsers right now.

690
00:24:31,334 --> 00:24:32,701
So it's something
we'd like to find

691
00:24:32,701 --> 00:24:33,868
other libraries to integrate.

692
00:24:33,868 --> 00:24:35,100
So it's something
to be aware of

693
00:24:35,100 --> 00:24:36,968
if you're parsing JSON data
on the device--

694
00:24:36,968 --> 00:24:39,400
the ones that ship with
the framework are tree parsers.

695
00:24:39,400 --> 00:24:41,267
So they're slightly
less efficient.

696
00:24:41,267 --> 00:24:43,701
There's other libraries
that you can use in their place.

697
00:24:43,701 --> 00:24:46,300
For example, the numbers
that I did on the last slide,

698
00:24:46,300 --> 00:24:49,100
I used Jackson,
with is another JSON library

699
00:24:49,100 --> 00:24:52,501
which allows it to parse
as a stream.

700
00:24:52,501 --> 00:24:53,901
So we have text formats,

701
00:24:53,901 --> 00:24:55,501
then we also have
these binary formats,

702
00:24:55,501 --> 00:24:58,267
like protocol buffers
or the ASN.1.

703
00:24:58,267 --> 00:25:00,901
Another benefit to using
the binary formats like that

704
00:25:00,901 --> 00:25:04,367
is that we can incorporate
both text and binary data

705
00:25:04,367 --> 00:25:05,767
in the same request.

706
00:25:05,767 --> 00:25:08,634
And one place this is
actually evident on the platform

707
00:25:08,634 --> 00:25:10,067
is in the Market client.

708
00:25:10,067 --> 00:25:12,267
If you're scrolling through
a list of apps in Market,

709
00:25:12,267 --> 00:25:13,968
you might notice
that all of the sudden

710
00:25:13,968 --> 00:25:15,601
five--four or five icons

711
00:25:15,601 --> 00:25:17,067
of the apps
that you're browsing through

712
00:25:17,067 --> 00:25:18,567
just appear
all of the sudden.

713
00:25:18,567 --> 00:25:20,767
They don't slowly fill in.
You'll see five at once.

714
00:25:20,767 --> 00:25:23,367
And the reason is
we're using protocol buffers

715
00:25:23,367 --> 00:25:25,767
to actually bundle up
multiple requests

716
00:25:25,767 --> 00:25:27,367
into a single request,

717
00:25:27,367 --> 00:25:30,367
and then we return the images
in one bunch to the device.

718
00:25:30,367 --> 00:25:32,767
And this is really helpful
on some mobile networks

719
00:25:32,767 --> 00:25:34,167
that can be laggy,

720
00:25:34,167 --> 00:25:37,067
where you have a lot of latency
between yourself and the server.

721
00:25:37,067 --> 00:25:38,968
So instead of making
an individual request

722
00:25:38,968 --> 00:25:41,534
for each of those assets,
for each of those icons,

723
00:25:41,534 --> 00:25:43,467
we actually wrap that
into a single request,

724
00:25:43,467 --> 00:25:44,767
requesting four or five,

725
00:25:44,767 --> 00:25:46,167
and we get
a larger response back

726
00:25:46,167 --> 00:25:47,567
that then we can parse.

727
00:25:47,567 --> 00:25:50,367
So something like a binary
format like protocol buffers

728
00:25:50,367 --> 00:25:52,400
allows us to pack
even multiple files

729
00:25:52,400 --> 00:25:54,868
into a single request
coming back to the device.

730
00:25:54,868 --> 00:25:58,400
And that can really help you
have fewer round trips

731
00:25:58,400 --> 00:26:00,968
and serve faster
user experience

732
00:26:00,968 --> 00:26:03,968
to people
that are using your apps.

733
00:26:08,434 --> 00:26:10,467
One other way that we can
actually do a good job

734
00:26:10,467 --> 00:26:13,734
on the device as far
as networking is using GZIP.

735
00:26:13,734 --> 00:26:16,033
If you're familiar with
the desktop environment,

736
00:26:16,033 --> 00:26:18,133
some web servers
support the notion

737
00:26:18,133 --> 00:26:21,167
of compressing the data before
they send it to the browser,

738
00:26:21,167 --> 00:26:22,801
and almost all modern browsers,

739
00:26:22,801 --> 00:26:25,701
automatically, when they see
GZIP data coming from a website,

740
00:26:25,701 --> 00:26:27,868
will decompress it
and show it to the user.

741
00:26:27,868 --> 00:26:30,801
So many of you have actually
used this in browsers today,

742
00:26:30,801 --> 00:26:33,400
possibly without realizing
that it's happening

743
00:26:33,400 --> 00:26:34,901
under the hood.

744
00:26:34,901 --> 00:26:37,734
So to back up a second,
GZIP is compressing the data.

745
00:26:37,734 --> 00:26:39,100
The server compresses the data

746
00:26:39,100 --> 00:26:40,834
before it sends it
across the network,

747
00:26:40,834 --> 00:26:43,100
and the device handles it.

748
00:26:43,100 --> 00:26:44,868
So in Android,
the GZIP libraries

749
00:26:44,868 --> 00:26:47,601
that come with the platform
are really efficient.

750
00:26:47,601 --> 00:26:50,634
And that's in part because
they go directly to native code

751
00:26:50,634 --> 00:26:51,868
on the device.

752
00:26:51,868 --> 00:26:54,400
So if you're parsing
a GZIP stream coming in,

753
00:26:54,400 --> 00:26:55,901
if you're decompressing it,

754
00:26:55,901 --> 00:26:57,801
it ends up being
incredibly efficient,

755
00:26:57,801 --> 00:26:59,133
incredibly fast.

756
00:26:59,133 --> 00:27:00,667
So here's a quick example.

757
00:27:00,667 --> 00:27:03,567
If you're using something like
the Apache HTTP client library,

758
00:27:03,567 --> 00:27:05,567
something a lot of us
have used in our code,

759
00:27:05,567 --> 00:27:07,767
the first set of code
should be--

760
00:27:07,767 --> 00:27:10,100
the first couple lines there
should be pretty familiar.

761
00:27:10,100 --> 00:27:11,868
We're making
a get request website

762
00:27:11,868 --> 00:27:13,334
and receiving something back.

763
00:27:13,334 --> 00:27:15,067
But in this case,
if we know, for instance,

764
00:27:15,067 --> 00:27:16,667
that the web server
we're talking to

765
00:27:16,667 --> 00:27:18,701
is going to be sending back
compressed data,

766
00:27:18,701 --> 00:27:20,868
we only need to add
one line of code,

767
00:27:20,868 --> 00:27:23,234
one extra step
to decompress that data.

768
00:27:23,234 --> 00:27:24,534
We take the input stream

769
00:27:24,534 --> 00:27:26,000
that we're receiving
from the site,

770
00:27:26,000 --> 00:27:28,334
and we just wrap it
in a GZIP input stream.

771
00:27:28,334 --> 00:27:30,834
The system on the fly
will decompress the data

772
00:27:30,834 --> 00:27:32,033
coming from the server

773
00:27:32,033 --> 00:27:33,667
and so we can continue
handling it.

774
00:27:33,667 --> 00:27:35,000
So we can pass
that input stream,

775
00:27:35,000 --> 00:27:36,267
the decompressed one,

776
00:27:36,267 --> 00:27:38,667
into one of our data format
parsers earlier

777
00:27:38,667 --> 00:27:41,133
that takes an input stream
into it.

778
00:27:41,133 --> 00:27:43,968
So GZIP on the platform
goes directly to native code,

779
00:27:43,968 --> 00:27:45,801
and it's really cheap.

780
00:27:45,801 --> 00:27:47,734
So we can ask the question,
how cheap is it?

781
00:27:47,734 --> 00:27:49,167
Should I consider using this?

782
00:27:49,167 --> 00:27:50,767
So just for the sake
of an example,

783
00:27:50,767 --> 00:27:52,767
let's say we had
a large RSS feed,

784
00:27:52,767 --> 00:27:54,067
say like a thousand items.

785
00:27:54,067 --> 00:27:56,067
And this is what I did
for this test.

786
00:27:56,067 --> 00:27:58,501
So if we're on a WiFi connection
which is really fast,

787
00:27:58,501 --> 00:28:00,334
it doesn't make
too much of a difference.

788
00:28:00,334 --> 00:28:02,534
We're looking here
at the three bars,

789
00:28:02,534 --> 00:28:05,467
the raw data itself,
so the raw XML,

790
00:28:05,467 --> 00:28:06,868
and then we compressed it

791
00:28:06,868 --> 00:28:08,767
using two levels
of GZIP compression.

792
00:28:08,767 --> 00:28:10,400
Those are
the two blue colors.

793
00:28:10,400 --> 00:28:12,100
And that's just the two levels.

794
00:28:12,100 --> 00:28:13,634
1 is light compression

795
00:28:13,634 --> 00:28:16,167
and 9 is the heaviest
compression available.

796
00:28:16,167 --> 00:28:19,100
So in WiFi, it doesn't make
too much of a difference.

797
00:28:19,100 --> 00:28:21,334
But as soon as we start
going over to a 3G

798
00:28:21,334 --> 00:28:23,901
or an EDGE connection,
we can begin to see

799
00:28:23,901 --> 00:28:26,534
where the value of compressing
the data comes in.

800
00:28:26,534 --> 00:28:28,634
So on a 3G network connection,

801
00:28:28,634 --> 00:28:31,133
just by compressing the data
as it comes across the network,

802
00:28:31,133 --> 00:28:33,167
we end up cutting the transfer
and parsing time,

803
00:28:33,167 --> 00:28:35,100
that total time, in half.

804
00:28:35,100 --> 00:28:36,834
And so it's not just
the parsing time.

805
00:28:36,834 --> 00:28:38,367
Remember
that this is battery time,

806
00:28:38,367 --> 00:28:40,200
because the radio is spun out
that entire time.

807
00:28:40,200 --> 00:28:41,934
The CPU is spun up.
It's waiting for data.

808
00:28:41,934 --> 00:28:43,234
It's parsing it.

809
00:28:43,234 --> 00:28:44,734
So this is the user's
battery life.

810
00:28:44,734 --> 00:28:47,033
We've essentially,
in terms of our application,

811
00:28:47,033 --> 00:28:49,601
we've doubled the user's
battery life on 3G.

812
00:28:49,601 --> 00:28:50,968
And it's even better on EDGE.

813
00:28:50,968 --> 00:28:52,200
EDGE to do this transfer,

814
00:28:52,200 --> 00:28:53,501
to transfer it across
and parse it,

815
00:28:53,501 --> 00:28:55,234
ended up taking over
40 seconds.

816
00:28:55,234 --> 00:28:58,067
But that same data
transferred across the network,

817
00:28:58,067 --> 00:29:00,367
if we GZIP it,
if we compress it,

818
00:29:00,367 --> 00:29:02,100
ends up taking
under ten seconds.

819
00:29:02,100 --> 00:29:04,033
So again,
an order of magnitude,

820
00:29:04,033 --> 00:29:07,167
it's ten times more expensive
to do the raw data.

821
00:29:07,167 --> 00:29:09,234
Another thing
to take away from this slide,

822
00:29:09,234 --> 00:29:11,200
you might wonder how expensive
are the GZIP libraries

823
00:29:11,200 --> 00:29:12,400
on the device.

824
00:29:12,400 --> 00:29:13,834
So we can see that

825
00:29:13,834 --> 00:29:15,434
with the WiFi connection
on the far right,

826
00:29:15,434 --> 00:29:19,701
we're seeing that adding GZIP
doesn't cost us anything.

827
00:29:19,701 --> 00:29:22,033
It doesn't take us longer
to parse the data,

828
00:29:22,033 --> 00:29:24,234
even when we have
a really fast connection.

829
00:29:24,234 --> 00:29:27,000
And then one final thing
to mention about GZIP is

830
00:29:27,000 --> 00:29:29,801
this is really helpful when
you're working with text data.

831
00:29:29,801 --> 00:29:32,234
Text data can be really
well-compressed using GZIP.

832
00:29:32,234 --> 00:29:34,033
If you're doing
binary transfers,

833
00:29:34,033 --> 00:29:36,367
if you're doing images
or video,

834
00:29:36,367 --> 00:29:38,167
those items,
because they're binary data,

835
00:29:38,167 --> 00:29:39,634
don't compress as well.

836
00:29:39,634 --> 00:29:41,601
So experiment with the data
that you're using

837
00:29:41,601 --> 00:29:42,934
to see how well it compresses

838
00:29:42,934 --> 00:29:44,934
to see if this would
actually be an advantage.

839
00:29:44,934 --> 00:29:47,667
For most binary formats,
like the images and video,

840
00:29:47,667 --> 00:29:52,601
it won't actually offer you
very much savings.

841
00:29:55,901 --> 00:29:57,767
Okay, so we talked about
networking.

842
00:29:57,767 --> 00:29:59,501
Another thing
that we can talk about

843
00:29:59,501 --> 00:30:01,634
is foreground applications
that we're interacting with,

844
00:30:01,634 --> 00:30:04,501
that the user interacts with
on the device.

845
00:30:04,501 --> 00:30:07,634
So if you're writing an app,
there's a note of wakelocks

846
00:30:07,634 --> 00:30:10,167
that you can acquire
to keep the device awake.

847
00:30:10,167 --> 00:30:12,767
Let's say, for example, you're
writing a video application

848
00:30:12,767 --> 00:30:15,334
that you want the user
to sit and watch videos in,

849
00:30:15,334 --> 00:30:16,734
something like YouTube.

850
00:30:16,734 --> 00:30:17,934
You can acquire a wakelock,

851
00:30:17,934 --> 00:30:20,467
which forces the device
to stay awake

852
00:30:20,467 --> 00:30:22,067
at least a certain level.

853
00:30:22,067 --> 00:30:25,334
There's multiple levels
of wakelocks in Android.

854
00:30:25,334 --> 00:30:27,501
You could request--
one of the lowest levels

855
00:30:27,501 --> 00:30:30,501
is just one that forces
the CPU to stay on.

856
00:30:30,501 --> 00:30:33,167
So you acquire this lock
that the system knows

857
00:30:33,167 --> 00:30:35,300
someone out there
needs the CPU to be turned on.

858
00:30:35,300 --> 00:30:36,634
And then
when you're finished,

859
00:30:36,634 --> 00:30:38,067
let's say you're parsing
the document,

860
00:30:38,067 --> 00:30:39,601
you can release
that wakelock.

861
00:30:39,601 --> 00:30:42,734
And if the system--if the user
isn't doing anything,

862
00:30:42,734 --> 00:30:44,534
releasing that wakelock
would allow the system

863
00:30:44,534 --> 00:30:46,167
to fall back asleep.

864
00:30:46,167 --> 00:30:47,667
Like I was saying,

865
00:30:47,667 --> 00:30:49,267
there's multiple levels
of these wakelocks.

866
00:30:49,267 --> 00:30:51,033
That's just one
that would keep the CPU on.

867
00:30:51,033 --> 00:30:52,534
We can have other ones that,
for example,

868
00:30:52,534 --> 00:30:53,968
keep the LCD on,

869
00:30:53,968 --> 00:30:56,534
which is very useful for
something playing back video.

870
00:30:56,534 --> 00:30:58,267
We want the screen to stay on

871
00:30:58,267 --> 00:30:59,734
so the user
doesn't have to actively

872
00:30:59,734 --> 00:31:01,467
interact with the screen.

873
00:31:01,467 --> 00:31:03,367
Wakelocks can be really useful

874
00:31:03,367 --> 00:31:05,934
because they allow you,
as developers, power

875
00:31:05,934 --> 00:31:07,467
in keeping the device awake.

876
00:31:07,467 --> 00:31:09,634
But on the flip side, they can
actually be really expensive,

877
00:31:09,634 --> 00:31:11,901
especially
if you forget to release them,

878
00:31:11,901 --> 00:31:15,968
because even though
we're working in the Java...

879
00:31:15,968 --> 00:31:17,534
in a Java world,

880
00:31:17,534 --> 00:31:20,167
wakelocks actually...
the system acquires them,

881
00:31:20,167 --> 00:31:22,033
and it doesn't
garbage collect them.

882
00:31:22,033 --> 00:31:24,400
If you take out a wakelock
and you forget to release it,

883
00:31:24,400 --> 00:31:26,300
the system still thinks
that you're out there,

884
00:31:26,300 --> 00:31:27,501
having acquired it,

885
00:31:27,501 --> 00:31:28,901
and it will keep
the system awake.

886
00:31:28,901 --> 00:31:30,300
So if your code crashes

887
00:31:30,300 --> 00:31:32,801
or if you forget to release
the wakelock,

888
00:31:32,801 --> 00:31:35,501
you might be responsible
for keeping the device awake

889
00:31:35,501 --> 00:31:37,501
for a long period of time

890
00:31:37,501 --> 00:31:39,701
and possibly draining
the user's battery.

891
00:31:39,701 --> 00:31:41,534
If you acquire wakelock
and don't release it,

892
00:31:41,534 --> 00:31:43,868
the system will stay awake
that entire time

893
00:31:43,868 --> 00:31:47,367
and possibly
not allow it to fall asleep.

894
00:31:47,367 --> 00:31:49,367
So if you're worried
about correctness--

895
00:31:49,367 --> 00:31:51,200
'cause I was mentioning
there's these wakelocks;

896
00:31:51,200 --> 00:31:52,501
you have to acquire
and release them--

897
00:31:52,501 --> 00:31:53,901
if you're worried about
the correctness,

898
00:31:53,901 --> 00:31:55,834
of proving that your code
is correct,

899
00:31:55,834 --> 00:31:58,033
that you'll actually
release them at the right time,

900
00:31:58,033 --> 00:32:00,601
there's one of two approaches
you can use.

901
00:32:00,601 --> 00:32:03,901
If you're writing UI
from a user perspective,

902
00:32:03,901 --> 00:32:06,868
you can add one single tag
into your UI,

903
00:32:06,868 --> 00:32:09,667
into any of the layouts,
the Android layouts in XML--

904
00:32:09,667 --> 00:32:12,367
and that's
android:keepScreenOn="true".

905
00:32:12,367 --> 00:32:14,000
Just using that,
if you add that tag

906
00:32:14,000 --> 00:32:15,400
you'll keep the screen on,

907
00:32:15,400 --> 00:32:16,734
and you don't
have to worry about

908
00:32:16,734 --> 00:32:18,000
going and acquiring
wakelocks.

909
00:32:18,000 --> 00:32:19,567
You don't
have to go touch them.

910
00:32:19,567 --> 00:32:20,934
The window manager
in the device

911
00:32:20,934 --> 00:32:23,701
will actually acquire a wakelock
on your behalf

912
00:32:23,701 --> 00:32:25,701
when your application shows,

913
00:32:25,701 --> 00:32:27,033
and then whether you crash

914
00:32:27,033 --> 00:32:28,968
or the user switches
to a different application,

915
00:32:28,968 --> 00:32:30,734
as soon as your activity
goes away,

916
00:32:30,734 --> 00:32:32,434
the system will,
on your behalf,

917
00:32:32,434 --> 00:32:33,868
release that wakelock.

918
00:32:33,868 --> 00:32:36,167
So that can be one way
of guaranteeing the correctness

919
00:32:36,167 --> 00:32:38,334
if you just need
to keep the screen on.

920
00:32:38,334 --> 00:32:40,367
Another way is if you're
acquiring these wakelocks

921
00:32:40,367 --> 00:32:42,567
behind the scene, say,
to keep the CPU awake

922
00:32:42,567 --> 00:32:44,234
while you're performing
some parsing,

923
00:32:44,234 --> 00:32:45,634
you can actually set a limit.

924
00:32:45,634 --> 00:32:47,767
You can say I'd like
to acquire this wakelock

925
00:32:47,767 --> 00:32:50,701
for, at most, 30 seconds,
or for, at most, a minute.

926
00:32:50,701 --> 00:32:52,968
So if you know how long

927
00:32:52,968 --> 00:32:55,434
the worst-case parsing
is going to take,

928
00:32:55,434 --> 00:32:57,634
you can actually use that
when you acquire the wakelock.

929
00:32:57,634 --> 00:33:00,000
So if the system
doesn't hear back from you

930
00:33:00,000 --> 00:33:02,567
by the time
that time-out elapses,

931
00:33:02,567 --> 00:33:04,834
the system will automatically
release the wakelock.

932
00:33:04,834 --> 00:33:07,300
So if you know you're just
parsing an RSS feed image

933
00:33:07,300 --> 00:33:10,100
and it shouldn't take any longer
than 30 seconds,

934
00:33:10,100 --> 00:33:12,801
you can actually
just set that as the time out,

935
00:33:12,801 --> 00:33:14,534
and the system will release it
on your behalf.

936
00:33:14,534 --> 00:33:16,968
So just in case there are
any lagging issues in the code,

937
00:33:16,968 --> 00:33:18,300
any correctness issues,

938
00:33:18,300 --> 00:33:20,634
the system will release it
on your behalf

939
00:33:20,634 --> 00:33:23,367
when the time out passes.

940
00:33:23,367 --> 00:33:27,834
Another way we can help save
battery from a UI perspective

941
00:33:27,834 --> 00:33:31,868
is recycling Java objects,
especially complex ones.

942
00:33:31,868 --> 00:33:36,634
So, yes, on Android,
we have a garbage collector.

943
00:33:36,634 --> 00:33:38,067
So we can create objects,

944
00:33:38,067 --> 00:33:40,000
and then they get garbage
collected at a later date.

945
00:33:40,000 --> 00:33:42,334
But it's usually better
in the long run

946
00:33:42,334 --> 00:33:44,000
if we just create
less garbage.

947
00:33:44,000 --> 00:33:46,801
If we're running in a tight--
say a tight code loop

948
00:33:46,801 --> 00:33:49,601
doing some text operations,

949
00:33:49,601 --> 00:33:51,834
building up a response
to send back to a server

950
00:33:51,834 --> 00:33:53,234
on the other side,

951
00:33:53,234 --> 00:33:57,501
a response to send
to the server...

952
00:33:57,501 --> 00:33:59,701
we can actually
recycle buffers.

953
00:33:59,701 --> 00:34:02,434
If we recycle objects
inside of that tight loop,

954
00:34:02,434 --> 00:34:04,501
we end up creating
less garbage overall.

955
00:34:04,501 --> 00:34:05,801
And there's a couple places

956
00:34:05,801 --> 00:34:07,267
that this shows up
in the system.

957
00:34:07,267 --> 00:34:10,767
One is XmlPullParserFactory,
and this is just an example.

958
00:34:10,767 --> 00:34:15,033
It borrows from the factory
design principle,

959
00:34:15,033 --> 00:34:17,701
and it also keeps
some generic state

960
00:34:17,701 --> 00:34:19,200
for the entire--

961
00:34:19,200 --> 00:34:21,901
for all XML pull parsers
that you might acquire.

962
00:34:21,901 --> 00:34:24,200
And so using
the pull parser factory

963
00:34:24,200 --> 00:34:27,367
allows you to get an instance
of a pull parser as you need it

964
00:34:27,367 --> 00:34:28,767
with very low overhead.

965
00:34:28,767 --> 00:34:31,300
It takes care of recycling--
recycling some of those objects.

966
00:34:31,300 --> 00:34:33,367
The same with BitmapFactory
on the device

967
00:34:33,367 --> 00:34:35,400
if you're acquiring bitmaps
for various things.

968
00:34:35,400 --> 00:34:37,234
Using BitmapFactory
internally,

969
00:34:37,234 --> 00:34:39,567
it keeps a pool
of bitmap objects

970
00:34:39,567 --> 00:34:41,067
that it's prepared
to send to you,

971
00:34:41,067 --> 00:34:43,667
almost pre-warmed,
ready to give to you.

972
00:34:43,667 --> 00:34:45,234
Then when you're done,

973
00:34:45,234 --> 00:34:47,267
you can release them back into
the pool to be recycled.

974
00:34:47,267 --> 00:34:48,868
So some of these things

975
00:34:48,868 --> 00:34:51,534
can really help you recycle
objects in your code.

976
00:34:51,534 --> 00:34:53,234
Two other places
that this can show up--

977
00:34:53,234 --> 00:34:54,734
If you do find yourselves

978
00:34:54,734 --> 00:34:56,400
having to use
regular expressions,

979
00:34:56,400 --> 00:34:58,400
in Java regular expression,

980
00:34:58,400 --> 00:34:59,968
we compile it into a pattern,

981
00:34:59,968 --> 00:35:01,734
an instance
of the pattern class.

982
00:35:01,734 --> 00:35:03,434
And with that pattern class,

983
00:35:03,434 --> 00:35:06,133
we can get a matcher
for a given string.

984
00:35:06,133 --> 00:35:08,634
And one mistake
that I've made in my code before

985
00:35:08,634 --> 00:35:10,834
is that I've acquired
a new matcher object

986
00:35:10,834 --> 00:35:12,133
every single time,

987
00:35:12,133 --> 00:35:13,801
for every single string
that I wanna match

988
00:35:13,801 --> 00:35:15,467
that regular expression
against.

989
00:35:15,467 --> 00:35:17,200
And something I need to
remind myself of

990
00:35:17,200 --> 00:35:20,367
is that I can actually recycle
that matcher object.

991
00:35:20,367 --> 00:35:22,300
I can call a method on it
called reset

992
00:35:22,300 --> 00:35:23,934
and pass it a new string.

993
00:35:23,934 --> 00:35:25,901
So this can be
a lot more efficient.

994
00:35:25,901 --> 00:35:27,167
If you're writing
a tight code loop

995
00:35:27,167 --> 00:35:29,868
where you're parsing
multiple strings,

996
00:35:29,868 --> 00:35:32,667
you can recycle
those matcher objects.

997
00:35:32,667 --> 00:35:34,100
Also in the case,

998
00:35:34,100 --> 00:35:36,033
if you're building strings
for a UI,

999
00:35:36,033 --> 00:35:38,033
you might end up using
something called StringBuilder.

1000
00:35:38,033 --> 00:35:40,200
So remember in Java
that strings are immutable,

1001
00:35:40,200 --> 00:35:42,033
and every time we use
the plus operator

1002
00:35:42,033 --> 00:35:43,667
to concatenate strings
together,

1003
00:35:43,667 --> 00:35:45,634
we're actually acquiring
a new string

1004
00:35:45,634 --> 00:35:47,567
and throwing away
the two old ones.

1005
00:35:47,567 --> 00:35:49,634
So something like StringBuilder

1006
00:35:49,634 --> 00:35:52,667
actually acquires a byte buffer
in the background,

1007
00:35:52,667 --> 00:35:53,934
inside of the object,

1008
00:35:53,934 --> 00:35:56,000
and you can append things
very cheaply to it.

1009
00:35:56,000 --> 00:35:59,467
And you can also recycle those
StringBuilder objects.

1010
00:35:59,467 --> 00:36:01,033
You call setLength,

1011
00:36:01,033 --> 00:36:03,767
and it actually just erases
everything that's in the string,

1012
00:36:03,767 --> 00:36:05,033
the StringBuilder,

1013
00:36:05,033 --> 00:36:07,067
allowing you to build
a brand-new string,

1014
00:36:07,067 --> 00:36:10,334
and you don't have to reallocate
the buffer that's underneath.

1015
00:36:10,334 --> 00:36:12,000
Some of these recycling issues,

1016
00:36:12,000 --> 00:36:13,601
you might find yourselves
working--

1017
00:36:13,601 --> 00:36:15,100
you can create a static object

1018
00:36:15,100 --> 00:36:17,000
that you might borrow
between multiple methods.

1019
00:36:17,000 --> 00:36:19,834
And sometimes that can introduce
synchronization issues

1020
00:36:19,834 --> 00:36:22,634
or correctness,
if two different threads

1021
00:36:22,634 --> 00:36:25,234
are borrowing
the same object in code.

1022
00:36:25,234 --> 00:36:27,834
And this actually is solved--
this can be solved in Android

1023
00:36:27,834 --> 00:36:30,033
because we're using
a single UI thread model.

1024
00:36:30,033 --> 00:36:32,033
If it's UI-driven,
for example,

1025
00:36:32,033 --> 00:36:33,868
if we're recycling
a string builder,

1026
00:36:33,868 --> 00:36:35,267
instead of allocating it,

1027
00:36:35,267 --> 00:36:36,767
let's saying you were
writing a ListView,

1028
00:36:36,767 --> 00:36:38,467
and there's a bindView method

1029
00:36:38,467 --> 00:36:40,234
where we're actually
setting the text

1030
00:36:40,234 --> 00:36:41,767
for the item in the ListView.

1031
00:36:41,767 --> 00:36:43,634
Instead of allocating
a string builder

1032
00:36:43,634 --> 00:36:46,834
inside of each call
of the method,

1033
00:36:46,834 --> 00:36:48,834
we can actually share an object,
a static object,

1034
00:36:48,834 --> 00:36:51,434
inside of something like
that list adaptor.

1035
00:36:51,434 --> 00:36:53,501
So on Android,

1036
00:36:53,501 --> 00:36:55,834
because it's a single
UI thread-based model,

1037
00:36:55,834 --> 00:36:57,834
we know that that code
is only going to ever be called,

1038
00:36:57,834 --> 00:37:00,467
that method is only going
to be called from the UI thread.

1039
00:37:00,467 --> 00:37:02,033
And we can guarantee

1040
00:37:02,033 --> 00:37:05,434
that the synchronization issues
are solved in those cases.

1041
00:37:05,434 --> 00:37:07,067
So it's something to handle
on a case-by-case basis,

1042
00:37:07,067 --> 00:37:10,100
but just to remember that
Android is a single UI thread.

1043
00:37:10,100 --> 00:37:13,501
It can help solve
some synchronization problems.

1044
00:37:13,501 --> 00:37:15,234
I was mentioning ListView.

1045
00:37:15,234 --> 00:37:18,067
ListView actually uses a lot
of recycling strategies.

1046
00:37:18,067 --> 00:37:19,901
If you're interesting
in digging more,

1047
00:37:19,901 --> 00:37:23,133
Romain Guy's talk later--
I believe it's tomorrow--

1048
00:37:23,133 --> 00:37:25,033
he'll be diving into ListView
a lot more

1049
00:37:25,033 --> 00:37:27,000
on some of the recycling
strategies

1050
00:37:27,000 --> 00:37:30,834
that are used in ListView.

1051
00:37:35,033 --> 00:37:37,367
So other ways
with foreground apps

1052
00:37:37,367 --> 00:37:38,834
that we can end up
saving battery.

1053
00:37:38,834 --> 00:37:41,200
A lot of people write
geolocation apps,

1054
00:37:41,200 --> 00:37:43,367
apps that need to know about
the user's location.

1055
00:37:43,367 --> 00:37:45,033
So something you might
want to consider

1056
00:37:45,033 --> 00:37:47,033
is using the coarse
network location.

1057
00:37:47,033 --> 00:37:51,267
So on Android we provide
two different providers

1058
00:37:51,267 --> 00:37:53,300
of the location of the device.

1059
00:37:53,300 --> 00:37:55,767
One is a network provider
and one is GPS

1060
00:37:55,767 --> 00:37:57,701
that the device
also happens to have.

1061
00:37:57,701 --> 00:38:00,434
And it ends up
that using the network provider

1062
00:38:00,434 --> 00:38:01,934
is a lot cheaper.

1063
00:38:01,934 --> 00:38:04,534
So network provider, this is
something Vic was mentioning

1064
00:38:04,534 --> 00:38:06,868
in his keynote earlier today

1065
00:38:06,868 --> 00:38:08,567
is that we might use
nearby cell towers

1066
00:38:08,567 --> 00:38:12,067
and WiFi access points to
triangulate where the user is.

1067
00:38:12,067 --> 00:38:14,667
And that can actually
be really cheap on the device.

1068
00:38:14,667 --> 00:38:16,033
We're just looking
at some sensors,

1069
00:38:16,033 --> 00:38:18,300
pulling in the cell towers
that we see,

1070
00:38:18,300 --> 00:38:20,701
and asking a server
to triangulate on our behalf.

1071
00:38:20,701 --> 00:38:23,701
And that can actually be
a lot cheaper than doing GPS.

1072
00:38:23,701 --> 00:38:27,133
That's because GPS fixes,
getting a fix from satellites,

1073
00:38:27,133 --> 00:38:29,167
the time to fix,
the time it takes us

1074
00:38:29,167 --> 00:38:32,133
to get a fix of our location
from the GPS satellites,

1075
00:38:32,133 --> 00:38:34,234
varies wildly.

1076
00:38:34,234 --> 00:38:36,100
It can be any length of time.

1077
00:38:36,100 --> 00:38:38,267
If you're out in the middle
of an open field,

1078
00:38:38,267 --> 00:38:40,267
the fix may only take
a few seconds.

1079
00:38:40,267 --> 00:38:42,200
But let's say you're in
an indoor environment like this

1080
00:38:42,200 --> 00:38:44,901
here in this conference
here today.

1081
00:38:44,901 --> 00:38:48,968
Your device may look for
GPS satellites,

1082
00:38:48,968 --> 00:38:50,934
and it may never find them.

1083
00:38:50,934 --> 00:38:53,834
We may keep the GPS radio awake
that entire time

1084
00:38:53,834 --> 00:38:55,801
and never actually
get a fix.

1085
00:38:55,801 --> 00:38:57,167
There's a risk of us

1086
00:38:57,167 --> 00:38:59,601
not actually getting
a latitude/longitude.

1087
00:38:59,601 --> 00:39:01,501
So it's something
to be aware of.

1088
00:39:01,501 --> 00:39:03,400
If you're interested
in just rough location,

1089
00:39:03,400 --> 00:39:05,868
if the accuracy
that you're interested in

1090
00:39:05,868 --> 00:39:08,334
is just within a couple
kilometers of where the user is,

1091
00:39:08,334 --> 00:39:10,501
network location
can be a lot cheaper.

1092
00:39:10,501 --> 00:39:12,334
So the numbers here
that we're looking at--

1093
00:39:12,334 --> 00:39:15,634
an average GPS fix
might take about 25 seconds.

1094
00:39:15,634 --> 00:39:17,968
And then we multiply that
times the actual battery

1095
00:39:17,968 --> 00:39:19,334
that's used during that time.

1096
00:39:19,334 --> 00:39:21,667
It ends up costing
about 1 milliamp hour on average

1097
00:39:21,667 --> 00:39:22,901
to get a GPS fix

1098
00:39:22,901 --> 00:39:24,133
whereas getting
a network fix

1099
00:39:24,133 --> 00:39:25,968
is an order
of magnitude cheaper.

1100
00:39:25,968 --> 00:39:28,667
We're just doing a quick,
simple network query

1101
00:39:28,667 --> 00:39:30,234
based on information,

1102
00:39:30,234 --> 00:39:32,868
the cell towers
that we already know about.

1103
00:39:32,868 --> 00:39:34,868
And also you notice
the Cupcake there,

1104
00:39:34,868 --> 00:39:38,367
something that in 1.5 we're
actually using Assisted GPS.

1105
00:39:38,367 --> 00:39:40,067
So when we have a GPS

1106
00:39:40,067 --> 00:39:41,968
and we first bring it up
on the network,

1107
00:39:41,968 --> 00:39:43,834
there's something known
as a cold start.

1108
00:39:43,834 --> 00:39:45,968
So if the user hasn't used
GPS in a while,

1109
00:39:45,968 --> 00:39:49,067
the device has to sit
and listen for the satellites

1110
00:39:49,067 --> 00:39:52,434
to send down an almanac
or a set of information

1111
00:39:52,434 --> 00:39:54,667
describing the movement
of the satellites.

1112
00:39:54,667 --> 00:39:56,667
That actually--
that can happen a lot faster

1113
00:39:56,667 --> 00:40:00,033
if you use something called
AGPS or Assisted GPS

1114
00:40:00,033 --> 00:40:03,334
where, instead of listening
for that almanac data

1115
00:40:03,334 --> 00:40:05,067
over a low bit rate--

1116
00:40:05,067 --> 00:40:07,701
the satellites are transmitting
it at all times,

1117
00:40:07,701 --> 00:40:09,067
but at a very low bit rate--

1118
00:40:09,067 --> 00:40:10,567
instead of waiting
a couple minutes

1119
00:40:10,567 --> 00:40:12,000
to collect that
almanac information,

1120
00:40:12,000 --> 00:40:14,167
AGPS goes to the network.

1121
00:40:14,167 --> 00:40:15,467
It assumes you have
a network connection.

1122
00:40:15,467 --> 00:40:17,334
It can go request
that almanac information

1123
00:40:17,334 --> 00:40:19,901
which allows fixes to happen
a lot faster.

1124
00:40:19,901 --> 00:40:24,701
So that's something
that is shipped in 1.5.

1125
00:40:24,701 --> 00:40:26,834
Some final things to mention
about foreground apps

1126
00:40:26,834 --> 00:40:29,133
is that floating point math
is expensive on the device.

1127
00:40:29,133 --> 00:40:30,667
The current devices
that have shipped

1128
00:40:30,667 --> 00:40:33,767
don't have floating point units
in their CPUs,

1129
00:40:33,767 --> 00:40:35,801
so doing floating point math
is expensive.

1130
00:40:35,801 --> 00:40:37,734
If you worked with Map Ap--

1131
00:40:37,734 --> 00:40:40,534
Map Activity
or Map View on the device,

1132
00:40:40,534 --> 00:40:42,701
you may have noticed
something called GeoPoint.

1133
00:40:42,701 --> 00:40:44,934
And so it's just like
a latitude/longitude,

1134
00:40:44,934 --> 00:40:46,467
which are decimal numbers,

1135
00:40:46,467 --> 00:40:48,701
except it's multiplied
by 10 to the 6.

1136
00:40:48,701 --> 00:40:50,200
We just shifted over
the decimal place.

1137
00:40:50,200 --> 00:40:51,801
So we can treat these
as integers,

1138
00:40:51,801 --> 00:40:53,534
which ends up being
a lot cheaper

1139
00:40:53,534 --> 00:40:55,667
when we're working
on the device.

1140
00:40:55,667 --> 00:40:57,701
And also, if you end up
writing your own views,

1141
00:40:57,701 --> 00:40:59,200
you may need to worry about

1142
00:40:59,200 --> 00:41:00,901
scaling to different densities
of devices.

1143
00:41:00,901 --> 00:41:03,000
A device may have
a higher density screen.

1144
00:41:03,000 --> 00:41:04,634
So you can actually--

1145
00:41:04,634 --> 00:41:06,634
and that density
is expressed in a float.

1146
00:41:06,634 --> 00:41:08,000
So if you're writing
your own views,

1147
00:41:08,000 --> 00:41:09,534
you can pre-cache that.

1148
00:41:09,534 --> 00:41:12,067
If you pre-multiply
that density that's coming in,

1149
00:41:12,067 --> 00:41:13,834
you can often cache
the value

1150
00:41:13,834 --> 00:41:17,100
and end up saving time
in the long run.

1151
00:41:17,100 --> 00:41:18,334
And one final mention.

1152
00:41:18,334 --> 00:41:19,601
If you're looking at using

1153
00:41:19,601 --> 00:41:21,300
the accelerometer
or game sensors,

1154
00:41:21,300 --> 00:41:22,734
there's four different rates,

1155
00:41:22,734 --> 00:41:24,767
four different polling rates
that you can use--

1156
00:41:24,767 --> 00:41:26,767
normal,
UI, game, and fastest.

1157
00:41:26,767 --> 00:41:30,133
They each have their own cost
associated with them.

1158
00:41:30,133 --> 00:41:32,200
Usually, when you're using
the accelerometer,

1159
00:41:32,200 --> 00:41:35,033
the user's playing a game,
so you need it anyway.

1160
00:41:35,033 --> 00:41:36,567
But it's just something
to be aware of,

1161
00:41:36,567 --> 00:41:39,434
that this is the cost
that's added on.

1162
00:41:45,234 --> 00:41:46,868
So we talked about network

1163
00:41:46,868 --> 00:41:48,634
and we talked about
foreground apps.

1164
00:41:48,634 --> 00:41:50,400
And finally,
I'd like to take some time

1165
00:41:50,400 --> 00:41:52,601
to talk about background
applications on the phone

1166
00:41:52,601 --> 00:41:55,501
and how they can do better
managing battery life.

1167
00:41:55,501 --> 00:41:56,767
So first of all,
let's back up

1168
00:41:56,767 --> 00:41:58,300
and talk about services
in general.

1169
00:41:58,300 --> 00:41:59,968
If you come from a UNIX
or a Windows background,

1170
00:41:59,968 --> 00:42:01,367
when we think of a service,

1171
00:42:01,367 --> 00:42:03,100
we think of something
we start in the background

1172
00:42:03,100 --> 00:42:05,501
and it continues to run,
almost like a daemon.

1173
00:42:05,501 --> 00:42:07,367
So it's waiting for
a request to come in.

1174
00:42:07,367 --> 00:42:09,033
It's running at all times.

1175
00:42:09,033 --> 00:42:11,200
And that works really well
in the desktop world.

1176
00:42:11,200 --> 00:42:12,734
but in the mobile world,

1177
00:42:12,734 --> 00:42:14,400
each of those processes running,
each of those services

1178
00:42:14,400 --> 00:42:16,701
has an overhead
associated with it.

1179
00:42:16,701 --> 00:42:18,367
So say, for example,

1180
00:42:18,367 --> 00:42:20,033
some of the devices
that first came out,

1181
00:42:20,033 --> 00:42:22,767
say the HTC Dream device
that came out--

1182
00:42:22,767 --> 00:42:25,000
when the system
finally boots...

1183
00:42:25,000 --> 00:42:27,701
so we think we have
an amount of RAM on the system,

1184
00:42:27,701 --> 00:42:29,167
and the system boots.

1185
00:42:29,167 --> 00:42:30,934
We have an amount of RAM
that's reserved for the kernel

1186
00:42:30,934 --> 00:42:32,234
and then we have some RAM

1187
00:42:32,234 --> 00:42:33,701
that's reserved for
the Android framework.

1188
00:42:33,701 --> 00:42:35,434
And when the device
finally finishes booting,

1189
00:42:35,434 --> 00:42:39,133
we have roughly about
30 to 40 megabytes of actual RAM

1190
00:42:39,133 --> 00:42:41,601
that applications--
that foreground applications

1191
00:42:41,601 --> 00:42:45,200
and background apps
on the device can make use of.

1192
00:42:45,200 --> 00:42:47,968
And something to be aware of--
that each process on the device,

1193
00:42:47,968 --> 00:42:49,834
even if you're running
a lightweight service,

1194
00:42:49,834 --> 00:42:52,734
takes somewhere around
2 megabytes of overhead

1195
00:42:52,734 --> 00:42:54,467
just to start that
application,

1196
00:42:54,467 --> 00:42:57,300
and that's just the foundation
of starting your app.

1197
00:42:57,300 --> 00:42:59,667
If you're doing other things
on top of that,

1198
00:42:59,667 --> 00:43:03,167
that's even more RAM
that you end up using.

1199
00:43:03,167 --> 00:43:05,267
And then finally,
if you have a service

1200
00:43:05,267 --> 00:43:07,200
that's running
in the background constantly,

1201
00:43:07,200 --> 00:43:09,067
the system
will actually kill you.

1202
00:43:09,067 --> 00:43:11,534
If the user is doing
some foreground task

1203
00:43:11,534 --> 00:43:13,200
say like using the browser

1204
00:43:13,200 --> 00:43:15,000
and the browser needs
more memory,

1205
00:43:15,000 --> 00:43:16,667
it will go through
and kill off

1206
00:43:16,667 --> 00:43:18,267
some of these background
services.

1207
00:43:18,267 --> 00:43:20,267
And it will try restarting you
at a later time

1208
00:43:20,267 --> 00:43:21,734
so you can continue
whatever work you were doing

1209
00:43:21,734 --> 00:43:23,100
in the background.

1210
00:43:23,100 --> 00:43:24,734
But again, that overhead
having to kill you

1211
00:43:24,734 --> 00:43:26,701
and then come back
and restart you

1212
00:43:26,701 --> 00:43:28,601
can really add up over time.

1213
00:43:28,601 --> 00:43:30,300
Okay, so we asked the question,

1214
00:43:30,300 --> 00:43:32,234
if we can't have
the service running

1215
00:43:32,234 --> 00:43:33,734
at all times in the background,

1216
00:43:33,734 --> 00:43:35,400
if we can't use a daemon model

1217
00:43:35,400 --> 00:43:37,067
that works really well
on the desktop,

1218
00:43:37,067 --> 00:43:39,000
how should we write services?

1219
00:43:39,000 --> 00:43:40,901
There's two primary methods
that we can use.

1220
00:43:40,901 --> 00:43:43,100
One is if you have a point
in the future,

1221
00:43:43,100 --> 00:43:44,434
have a time in the future

1222
00:43:44,434 --> 00:43:45,734
that you know you need
to wake up--

1223
00:43:45,734 --> 00:43:47,367
say you're performing
an RSS feed update

1224
00:43:47,367 --> 00:43:49,734
every 15 minutes
or half an hour--

1225
00:43:49,734 --> 00:43:52,000
you can set an alarm
for the system to wake you up

1226
00:43:52,000 --> 00:43:53,634
at that point in the future.

1227
00:43:53,634 --> 00:43:56,300
And another method
is using a broadcast receiver,

1228
00:43:56,300 --> 00:43:58,033
so it allows you
to be event-driven.

1229
00:43:58,033 --> 00:44:00,601
So if the user moves between
network connections--

1230
00:44:00,601 --> 00:44:02,300
for example,
if they're on an EDGE network

1231
00:44:02,300 --> 00:44:03,968
and they transfer to a 3G,

1232
00:44:03,968 --> 00:44:06,000
if they all of the sudden
get a 3G connection,

1233
00:44:06,000 --> 00:44:07,300
on broadcast intents--

1234
00:44:07,300 --> 00:44:09,367
the system sends out
broadcast intents

1235
00:44:09,367 --> 00:44:12,601
that anyone interested
can pick up on and handle.

1236
00:44:12,601 --> 00:44:13,968
So those are just two--

1237
00:44:13,968 --> 00:44:15,467
I'll jump into those more
in detail--

1238
00:44:15,467 --> 00:44:17,501
but those are
two of the methods

1239
00:44:17,501 --> 00:44:19,501
that you should use
as writing services.

1240
00:44:19,501 --> 00:44:20,868
And a final note is,
once you handle--

1241
00:44:20,868 --> 00:44:22,501
if your service is woken up

1242
00:44:22,501 --> 00:44:24,100
and you handle
one of these events,

1243
00:44:24,100 --> 00:44:27,467
make sure to call stopSelf
if you're writing the service

1244
00:44:27,467 --> 00:44:29,100
which tells the system
that you're finished

1245
00:44:29,100 --> 00:44:30,501
with whatever work
you were doing,

1246
00:44:30,501 --> 00:44:32,501
and the system
can kill your process.

1247
00:44:32,501 --> 00:44:34,000
It's free to kill your process.

1248
00:44:34,000 --> 00:44:38,100
So remember to stopSelf whenever
you're done processing data.

1249
00:44:38,100 --> 00:44:39,501
So first, let's jump into
those two types,

1250
00:44:39,501 --> 00:44:40,901
using AlarmManager,

1251
00:44:40,901 --> 00:44:43,901
and then later we'll talk about
the broadcast intents.

1252
00:44:43,901 --> 00:44:45,901
So first AlarmManager.

1253
00:44:45,901 --> 00:44:47,734
If you have a point in time
in the future

1254
00:44:47,734 --> 00:44:49,200
that you know you'd like
to wake up,

1255
00:44:49,200 --> 00:44:53,501
you can have the system wake
you up to perform that action.

1256
00:44:53,501 --> 00:44:56,100
So this--it allows you
to set a time, a specific time

1257
00:44:56,100 --> 00:45:01,167
using the notion of an RTC
or a real-time clock.

1258
00:45:01,167 --> 00:45:02,367
So if you're familiar with

1259
00:45:02,367 --> 00:45:04,567
the concept of UNIX time
on Android,

1260
00:45:04,567 --> 00:45:07,167
the RTC is the number
of seconds--

1261
00:45:07,167 --> 00:45:11,167
the number of milliseconds
since the epoch, back in 1970.

1262
00:45:11,167 --> 00:45:12,767
So you can specify
an exact time

1263
00:45:12,767 --> 00:45:14,567
that you'd like the system
to wake you up

1264
00:45:14,567 --> 00:45:17,133
to perform some action
in the future.

1265
00:45:17,133 --> 00:45:19,100
You can also specify--
you can add in a flag.

1266
00:45:19,100 --> 00:45:20,467
So here at the bottom,

1267
00:45:20,467 --> 00:45:22,567
we're using
the AlarmManager.RTC flag.

1268
00:45:22,567 --> 00:45:24,200
There's other flags
that we can use.

1269
00:45:24,200 --> 00:45:26,267
We can use RTC_WAKEUP,

1270
00:45:26,267 --> 00:45:28,767
and what that does,
that forces the device awake.

1271
00:45:28,767 --> 00:45:31,133
So if we get to that point
in time

1272
00:45:31,133 --> 00:45:33,167
and we absolutely need
the device to wake up--

1273
00:45:33,167 --> 00:45:34,968
Let's say, for example,
we're writing an alarm clock.

1274
00:45:34,968 --> 00:45:38,234
We need to wake up and tell
the user to get out of bed.

1275
00:45:38,234 --> 00:45:40,767
We want to wake the device up
if it's sleeping,

1276
00:45:40,767 --> 00:45:42,367
so we should use
a wake-up flag.

1277
00:45:42,367 --> 00:45:44,000
Otherwise,
if we don't use that,

1278
00:45:44,000 --> 00:45:46,767
the service will only start
at that point in the future

1279
00:45:46,767 --> 00:45:48,367
if the system is already awake,

1280
00:45:48,367 --> 00:45:50,100
if it's awake
handling other things

1281
00:45:50,100 --> 00:45:54,400
on behalf of the user.

1282
00:45:54,400 --> 00:45:56,200
So another thing
we introduced in Cupcake--

1283
00:45:56,200 --> 00:45:58,267
we have the notion
of repeating alarms.

1284
00:45:58,267 --> 00:45:59,534
We can set an alarm.

1285
00:45:59,534 --> 00:46:01,000
Say you wanted
to update your RSS feed

1286
00:46:01,000 --> 00:46:02,834
or you have a Twitter feed

1287
00:46:02,834 --> 00:46:04,834
that you want to update
every 15 minutes or so.

1288
00:46:04,834 --> 00:46:07,968
Currently, right now, the old
approach in the 1.1 SDK,

1289
00:46:07,968 --> 00:46:09,934
you set a repeating alarm
and you set an interval.

1290
00:46:09,934 --> 00:46:11,434
You set 15 minutes,

1291
00:46:11,434 --> 00:46:13,534
and the system would actually
set those alarms.

1292
00:46:13,534 --> 00:46:14,801
So here on the left-hand side,

1293
00:46:14,801 --> 00:46:16,701
this is an example
of what it used to look like.

1294
00:46:16,701 --> 00:46:17,934
Let's say you had a Twitter

1295
00:46:17,934 --> 00:46:19,501
and a news app
and a mail application

1296
00:46:19,501 --> 00:46:21,000
that all wanted to wake up,

1297
00:46:21,000 --> 00:46:22,734
say every half hour,
in this case.

1298
00:46:22,734 --> 00:46:26,100
So we would run into
the worst-case circumstance

1299
00:46:26,100 --> 00:46:28,067
where the Twitter application
would wake up,

1300
00:46:28,067 --> 00:46:29,734
and then the system would
fall back asleep,

1301
00:46:29,734 --> 00:46:32,000
go into an idle state
for about ten minutes.

1302
00:46:32,000 --> 00:46:34,601
And then the news application
would wake the device up

1303
00:46:34,601 --> 00:46:35,934
and do an update

1304
00:46:35,934 --> 00:46:37,934
and then fall back asleep
for another ten minutes.

1305
00:46:37,934 --> 00:46:39,734
And then the mail application--

1306
00:46:39,734 --> 00:46:41,334
you can see how
that's the worst case,

1307
00:46:41,334 --> 00:46:43,400
all of these being spread out
across time.

1308
00:46:43,400 --> 00:46:46,167
And the overhead associated
with waking up the system

1309
00:46:46,167 --> 00:46:47,934
each time to go do
network activity

1310
00:46:47,934 --> 00:46:50,734
and falling back asleep,
there's all that extra overhead.

1311
00:46:50,734 --> 00:46:53,834
So something we introduced
in 1.5 is the notion--

1312
00:46:53,834 --> 00:46:56,901
AlarmManager has a new method
called setinexactRepeating

1313
00:46:56,901 --> 00:46:58,701
which allows you
as a developer,

1314
00:46:58,701 --> 00:47:00,567
if you're willing
to be flexible

1315
00:47:00,567 --> 00:47:02,801
with the time interval
that you're woken up with,

1316
00:47:02,801 --> 00:47:05,834
if you say, I'm okay with being
woken up every 30 minutes-ish,

1317
00:47:05,834 --> 00:47:08,434
if you're okay
being adjusted around,

1318
00:47:08,434 --> 00:47:10,968
the system will offer
to bin you together.

1319
00:47:10,968 --> 00:47:12,934
It will bin you together
with anyone else

1320
00:47:12,934 --> 00:47:14,834
that's interested in updating
at the same interval.

1321
00:47:14,834 --> 00:47:16,634
So in this case,
those three applications

1322
00:47:16,634 --> 00:47:18,534
that they use
setinexactRepeating,

1323
00:47:18,534 --> 00:47:19,801
the system would group them
all together.

1324
00:47:19,801 --> 00:47:21,167
It would look and compare

1325
00:47:21,167 --> 00:47:23,701
and group everyone together
to do one single update.

1326
00:47:23,701 --> 00:47:26,200
It would wake up the device,
perform all three updates,

1327
00:47:26,200 --> 00:47:28,200
and then fall asleep
for an entire half hour

1328
00:47:28,200 --> 00:47:29,934
until the next set
of updates happened.

1329
00:47:29,934 --> 00:47:32,601
So that's something to be
aware of in the 1.5 SDK

1330
00:47:32,601 --> 00:47:36,834
if you're looking to do
some things in the background.

1331
00:47:36,834 --> 00:47:39,601
[coughs]

1332
00:47:39,601 --> 00:47:41,834
Okay, so that covers
AlarmManager.

1333
00:47:41,834 --> 00:47:44,801
One of the other methods that
you can wake up from a service

1334
00:47:44,801 --> 00:47:46,467
or wake your service up
is using the notion

1335
00:47:46,467 --> 00:47:47,834
of broadcast intents.

1336
00:47:47,834 --> 00:47:50,501
so the system--
here's just a couple examples

1337
00:47:50,501 --> 00:47:52,767
that can be really useful
for developers.

1338
00:47:52,767 --> 00:47:54,534
For example,
if the times aren't changed,

1339
00:47:54,534 --> 00:47:56,501
if you're writing an application
that wakes the person up,

1340
00:47:56,501 --> 00:47:57,934
maybe you're interested
in that

1341
00:47:57,934 --> 00:47:59,434
or if you have
a calendar application.

1342
00:47:59,434 --> 00:48:01,734
The second one is probably
one of the most important--

1343
00:48:01,734 --> 00:48:03,000
ConnectivityManager.

1344
00:48:03,000 --> 00:48:04,601
Something happened
with the network connection.

1345
00:48:04,601 --> 00:48:06,501
We changed.
We were on EDGE before.

1346
00:48:06,501 --> 00:48:07,968
Now we're connected to WiFi,

1347
00:48:07,968 --> 00:48:10,033
or maybe we lost network
connection all together.

1348
00:48:10,033 --> 00:48:11,667
Or maybe we didn't have
network connection,

1349
00:48:11,667 --> 00:48:13,934
and now we're connected
to WiFi.

1350
00:48:13,934 --> 00:48:15,767
 That broadcast intent,

1351
00:48:15,767 --> 00:48:18,701
that ConnectivityManager.
Connectivity_Action

1352
00:48:18,701 --> 00:48:20,000
is sent out by the system

1353
00:48:20,000 --> 00:48:22,567
every time
the network state changes.

1354
00:48:22,567 --> 00:48:24,400
So that's something
you can listen for.

1355
00:48:24,400 --> 00:48:25,701
The same if you--

1356
00:48:25,701 --> 00:48:27,167
Let's say you're holding
a cache on the device,

1357
00:48:27,167 --> 00:48:29,067
and you're interested when
the device storage is low.

1358
00:48:29,067 --> 00:48:30,734
Maybe you have a cache
that you can clean out

1359
00:48:30,734 --> 00:48:32,100
to help make room
for the user.

1360
00:48:32,100 --> 00:48:33,667
You can listen
for that broadcast.

1361
00:48:33,667 --> 00:48:35,234
Or if you're doing
some background tasks,

1362
00:48:35,234 --> 00:48:37,601
you can listen for
the battery low broadcast.

1363
00:48:37,601 --> 00:48:39,534
So the system
will send this out

1364
00:48:39,534 --> 00:48:42,400
at the same time that it shows
the notification to the user

1365
00:48:42,400 --> 00:48:45,234
that they have 15%
of their battery left.

1366
00:48:45,234 --> 00:48:47,100
If you're doing
some background tasks,

1367
00:48:47,100 --> 00:48:49,300
you might fall asleep
during this period

1368
00:48:49,300 --> 00:48:51,434
and wake yourself up
maybe a day later

1369
00:48:51,434 --> 00:48:53,234
when you might have
more battery.

1370
00:48:53,234 --> 00:48:56,767
So you could use that
to cancel some background tasks.

1371
00:48:56,767 --> 00:48:59,067
So this is
one quick code snippet

1372
00:48:59,067 --> 00:49:00,868
about how you'd register
for these.

1373
00:49:00,868 --> 00:49:02,400
So just like we have
an activity

1374
00:49:02,400 --> 00:49:05,167
or in our service definition
in our Android manifest,

1375
00:49:05,167 --> 00:49:06,400
we define a receiver

1376
00:49:06,400 --> 00:49:08,334
and then an intent filter
that matches

1377
00:49:08,334 --> 00:49:12,033
any of those intents
that we're interested in.

1378
00:49:12,033 --> 00:49:14,200
So part of the issue
is that ConnectivityManager

1379
00:49:14,200 --> 00:49:16,133
actually happens a lot
on the device.

1380
00:49:16,133 --> 00:49:17,634
As I was mentioning,

1381
00:49:17,634 --> 00:49:19,467
if these were moving between
EDGE and WiFi,

1382
00:49:19,467 --> 00:49:20,968
every single one
of those actions

1383
00:49:20,968 --> 00:49:23,000
will wake up your service
because you've told the system

1384
00:49:23,000 --> 00:49:24,901
that you're interested
in that update.

1385
00:49:24,901 --> 00:49:26,567
It will wake you up every time.

1386
00:49:26,567 --> 00:49:27,834
And the risk is that--

1387
00:49:27,834 --> 00:49:29,701
let's say you're writing
an application

1388
00:49:29,701 --> 00:49:32,868
that uploads video,
say to YouTube,

1389
00:49:32,868 --> 00:49:34,501
on behalf of the user.

1390
00:49:34,501 --> 00:49:36,634
If you register
for this broadcast,

1391
00:49:36,634 --> 00:49:38,834
the risk
is that most of the time,

1392
00:49:38,834 --> 00:49:41,868
the user isn't going to have
a video waiting in the queue

1393
00:49:41,868 --> 00:49:43,000
to upload.

1394
00:49:43,000 --> 00:49:45,300
They might not have
anything to do.

1395
00:49:45,300 --> 00:49:48,434
So your process, your server,
your service that you're writing

1396
00:49:48,434 --> 00:49:49,767
will be woken up

1397
00:49:49,767 --> 00:49:51,667
for every one of these
connectivity change events,

1398
00:49:51,667 --> 00:49:53,534
even when you don't have
anything to do.

1399
00:49:53,534 --> 00:49:55,901
And that can cause
a lot of overhead.

1400
00:49:55,901 --> 00:49:57,701
So one way to solve that

1401
00:49:57,701 --> 00:49:59,234
is actually
enabling and disabling

1402
00:49:59,234 --> 00:50:00,801
those manifest elements.

1403
00:50:00,801 --> 00:50:02,467
So we define
the manifest element

1404
00:50:02,467 --> 00:50:03,801
using that receiver tag.

1405
00:50:03,801 --> 00:50:05,601
We can programmatically,
at run-time,

1406
00:50:05,601 --> 00:50:07,133
enable and disable it,

1407
00:50:07,133 --> 00:50:10,467
so we can get those broadcast
intents when we need them,

1408
00:50:10,467 --> 00:50:11,701
when we need to know
about them,

1409
00:50:11,701 --> 00:50:12,901
and we can turn them off

1410
00:50:12,901 --> 00:50:15,067
when we know we wouldn't
be doing anything.

1411
00:50:15,067 --> 00:50:16,534
So something like this--

1412
00:50:16,534 --> 00:50:17,901
this is a code example
at the top here.

1413
00:50:17,901 --> 00:50:19,734
We're starting with
enabled="false."

1414
00:50:19,734 --> 00:50:22,801
We're not gonna receive
any of those broadcast actions.

1415
00:50:22,801 --> 00:50:24,501
Then in the code later on,

1416
00:50:24,501 --> 00:50:27,133
let's say the user has a video
that they're ready to upload.

1417
00:50:27,133 --> 00:50:28,667
In that code,

1418
00:50:28,667 --> 00:50:30,634
we can actually grab a copy
of the package manager

1419
00:50:30,634 --> 00:50:34,067
and find the component name
for our broadcast receiver.

1420
00:50:34,067 --> 00:50:35,868
And we can dynamically
enable it

1421
00:50:35,868 --> 00:50:39,234
so that we start receiving
those broadcast intents

1422
00:50:39,234 --> 00:50:41,000
so that as we're uploading
the video,

1423
00:50:41,000 --> 00:50:43,601
we watch to see as the user
changes between WiFi

1424
00:50:43,601 --> 00:50:46,634
to EDGE to 3G so that
we can handle it correctly.

1425
00:50:46,634 --> 00:50:49,367
And then, the same code
works in the inverse case.

1426
00:50:49,367 --> 00:50:50,868
Once we've finished uploading
everything

1427
00:50:50,868 --> 00:50:52,200
on behalf of the user,

1428
00:50:52,200 --> 00:50:54,467
we can go and disable
this manifest element again

1429
00:50:54,467 --> 00:50:56,601
because we don't have anything
left in our upload queue,

1430
00:50:56,601 --> 00:50:59,234
and we would just be
using system resources

1431
00:50:59,234 --> 00:51:01,767
when we don't have anything
to upload.

1432
00:51:01,767 --> 00:51:05,501
So this can really help us
be more efficient.

1433
00:51:05,501 --> 00:51:07,534
Another thing that we can do
is, actually,

1434
00:51:07,534 --> 00:51:09,133
we can check
the battery state.

1435
00:51:09,133 --> 00:51:11,334
And this is a little bit
of a tricky code example.

1436
00:51:11,334 --> 00:51:14,167
You can check to see the battery
percentage that's left.

1437
00:51:14,167 --> 00:51:17,000
The system sends out
a broadcast intent,

1438
00:51:17,000 --> 00:51:19,234
a sticky broadcast
that sticks around

1439
00:51:19,234 --> 00:51:21,901
that you can catch that has
the current battery level,

1440
00:51:21,901 --> 00:51:24,234
say it'd be like 40% or 45%.

1441
00:51:24,234 --> 00:51:26,834
And so you might be interested
in getting that exact number

1442
00:51:26,834 --> 00:51:28,601
so that you could do
some calculations.

1443
00:51:28,601 --> 00:51:29,901
So if the user's on EDGE

1444
00:51:29,901 --> 00:51:31,434
and they have more than
60% battery,

1445
00:51:31,434 --> 00:51:33,567
maybe it's okay, and you wanna
go ahead with that.

1446
00:51:33,567 --> 00:51:35,200
So this is a quick code snippet

1447
00:51:35,200 --> 00:51:38,133
that would explain
how to go grab that broadcast.

1448
00:51:38,133 --> 00:51:39,901
It's a little bit hard
to explain,

1449
00:51:39,901 --> 00:51:41,801
and we're running
a little short on time,

1450
00:51:41,801 --> 00:51:43,701
so we'll skip it for now.

1451
00:51:43,701 --> 00:51:46,467
Okay, so we talked about
how we as developers

1452
00:51:46,467 --> 00:51:48,801
can save battery,
both in terms of network,

1453
00:51:48,801 --> 00:51:50,968
foreground apps,
and background apps.

1454
00:51:50,968 --> 00:51:53,100
So now let's talk about
what's beyond 1.5,

1455
00:51:53,100 --> 00:51:54,100
beyond Cupcake.

1456
00:51:54,100 --> 00:51:56,434
What's coming next?

1457
00:51:56,434 --> 00:51:57,968
So here I'd like to show
an example.

1458
00:51:57,968 --> 00:52:00,801
This is actually in SpareParts
on Cupcake.

1459
00:52:00,801 --> 00:52:02,567
It's not on your phones
that you got today,

1460
00:52:02,567 --> 00:52:04,033
because those are
user builds.

1461
00:52:04,033 --> 00:52:06,634
If you go home, you should
be able t flash your phones,

1462
00:52:06,634 --> 00:52:08,767
re-flash your phones
with an engineering build

1463
00:52:08,767 --> 00:52:10,200
which will give you root,

1464
00:52:10,200 --> 00:52:12,767
and it will start collecting
battery statistics.

1465
00:52:12,767 --> 00:52:14,901
So this is an example
of what that screen looks like.

1466
00:52:14,901 --> 00:52:18,334
The system is actually
keeping track in 1.5 now

1467
00:52:18,334 --> 00:52:20,467
of each of the applications
and how much they're doing

1468
00:52:20,467 --> 00:52:22,801
with respect to various
pieces on the system.

1469
00:52:22,801 --> 00:52:24,934
In this case, we're looking
at how much network activity

1470
00:52:24,934 --> 00:52:26,701
each of the apps,
and we're tabulating,

1471
00:52:26,701 --> 00:52:28,267
we're keeping these statistics.

1472
00:52:28,267 --> 00:52:30,601
So it's something
that's not exposed just yet,

1473
00:52:30,601 --> 00:52:32,701
but in future versions
down the road,

1474
00:52:32,701 --> 00:52:35,267
this is something we'd like
to expose to end users.

1475
00:52:35,267 --> 00:52:36,767
So they know, for instance,

1476
00:52:36,767 --> 00:52:39,367
that "My device's battery
doesn't last very long.

1477
00:52:39,367 --> 00:52:40,834
What can I do about it?"

1478
00:52:40,834 --> 00:52:42,267
So this will be an answer.

1479
00:52:42,267 --> 00:52:44,000
This will be a place
that they can go

1480
00:52:44,000 --> 00:52:46,067
and actually check to see
who on their phone--

1481
00:52:46,067 --> 00:52:48,033
which applications
are using battery.

1482
00:52:48,033 --> 00:52:49,601
So this is something
that you guys can use

1483
00:52:49,601 --> 00:52:51,334
as you're working and
debugging your applications,

1484
00:52:51,334 --> 00:52:53,000
but it's also motivation.

1485
00:52:53,000 --> 00:52:54,567
It's also motivation
to be aware

1486
00:52:54,567 --> 00:52:56,534
that users will be watching
in the future,

1487
00:52:56,534 --> 00:52:58,934
and they'll be able to see
which apps are using battery.

1488
00:52:58,934 --> 00:53:00,701
And they'll actually
uninstall you,

1489
00:53:00,701 --> 00:53:02,634
and then you won't be around.

1490
00:53:02,634 --> 00:53:04,534
So one thing to keep in mind,
if you're writing apps,

1491
00:53:04,534 --> 00:53:06,868
give your users flexibility.

1492
00:53:06,868 --> 00:53:10,467
Say, for example, you're writing
a stock ticker application.

1493
00:53:10,467 --> 00:53:12,434
Some of your users
may only be interested

1494
00:53:12,434 --> 00:53:14,601
in getting updates
once or twice a day.

1495
00:53:14,601 --> 00:53:16,634
But other users
may be really interested

1496
00:53:16,634 --> 00:53:18,434
and want updates
every five minutes.

1497
00:53:18,434 --> 00:53:22,033
So giving your users flexibility
on how much they want to update

1498
00:53:22,033 --> 00:53:24,234
will make them less likely
to uninstall you.

1499
00:53:24,234 --> 00:53:25,634
Because they have a choice.

1500
00:53:25,634 --> 00:53:27,501
They have some control
over the amount of battery

1501
00:53:27,501 --> 00:53:29,100
that your application is using

1502
00:53:29,100 --> 00:53:32,968
if they can change preferences
inside of your app.

1503
00:53:32,968 --> 00:53:34,567
So some overall takeaways

1504
00:53:34,567 --> 00:53:36,300
about everything
we talked about today.

1505
00:53:36,300 --> 00:53:38,834
First of all,
use an efficient data parser.

1506
00:53:38,834 --> 00:53:42,400
Use one of those event
or pull-base parsers

1507
00:53:42,400 --> 00:53:44,467
instead of a tree parser.

1508
00:53:44,467 --> 00:53:46,734
Also use GZIP
to compress text data

1509
00:53:46,734 --> 00:53:49,334
if you're sending a lot of
textual data to the phone

1510
00:53:49,334 --> 00:53:52,300
so that you can save
network and CPU resources.

1511
00:53:52,300 --> 00:53:55,100
Services that sleep or poll
are bad.

1512
00:53:55,100 --> 00:53:58,400
So don't use the daemon
approach from the desktop.

1513
00:53:58,400 --> 00:54:00,234
Instead, be event-driven.

1514
00:54:00,234 --> 00:54:02,501
Set alarms for yourself
to wake up in the future

1515
00:54:02,501 --> 00:54:04,534
and respond
to broadcast intents.

1516
00:54:04,534 --> 00:54:06,267
Also disable
those manifest elements.

1517
00:54:06,267 --> 00:54:07,968
If you're interested
in those broadcasts,

1518
00:54:07,968 --> 00:54:09,834
disable them
when you wouldn't do anything.

1519
00:54:09,834 --> 00:54:11,400
If the system
is just going to wake you up

1520
00:54:11,400 --> 00:54:13,067
to look and decide

1521
00:54:13,067 --> 00:54:15,334
that you're going to fall
back asleep again, disable it.

1522
00:54:15,334 --> 00:54:17,634
Disable those manifest elements
in those cases.

1523
00:54:17,634 --> 00:54:19,701
Also, wake up along
with everyone else.

1524
00:54:19,701 --> 00:54:22,968
That's the set inexact alarms
repeating alarms.

1525
00:54:22,968 --> 00:54:25,067
Also wait for a better network
or battery

1526
00:54:25,067 --> 00:54:26,701
before you do bulk transfers,

1527
00:54:26,701 --> 00:54:29,000
and possibly involve
the user in that process

1528
00:54:29,000 --> 00:54:31,767
so that they know they can
go find WiFi somewhere to--

1529
00:54:31,767 --> 00:54:33,501
if it's going to affect
their battery life.

1530
00:54:33,501 --> 00:54:35,367
And finally,
give choices to the user

1531
00:54:35,367 --> 00:54:37,300
about the background behavior
of your apps.

1532
00:54:37,300 --> 00:54:38,934
It'll allow them to--

1533
00:54:38,934 --> 00:54:41,033
you'll be much more friendly
towards users,

1534
00:54:41,033 --> 00:54:43,567
because they have choices,
they have a choice now

1535
00:54:43,567 --> 00:54:46,901
between how much battery
you're using in the background.

1536
00:54:46,901 --> 00:54:48,901
So with that, that's about
all I had to talk about

1537
00:54:48,901 --> 00:54:50,234
about battery life.

1538
00:54:50,234 --> 00:54:51,400
It looks like we have just over

1539
00:54:51,400 --> 00:54:53,434
five, six minutes left
for questions.

1540
00:54:53,434 --> 00:54:55,467
So I'm gonna switch over
to Google Moderator,

1541
00:54:55,467 --> 00:54:57,634
and then also feel free
to come up to the microphones

1542
00:54:57,634 --> 00:54:59,067
to ask any of your questions.

1543
00:54:59,067 --> 00:55:01,634
Then we'll alternate
back and forth

1544
00:55:01,634 --> 00:55:04,667
between everything.

1545
00:55:06,701 --> 00:55:08,467
Okay, so first question
on Moderator.

1546
00:55:08,467 --> 00:55:10,200
Someone asked, "What happened
to the GoogleIO apps?

1547
00:55:10,200 --> 00:55:11,601
I can't find it on market!"

1548
00:55:11,601 --> 00:55:13,400
So over the weekend,
a couple friends and I

1549
00:55:13,400 --> 00:55:15,467
wrote an application for
the schedule for the conference,

1550
00:55:15,467 --> 00:55:17,133
and you can find it on market.

1551
00:55:17,133 --> 00:55:19,400
You can only get it
on Cupcake devices.

1552
00:55:19,400 --> 00:55:22,601
If you go to market and just
search for IO as a single word,

1553
00:55:22,601 --> 00:55:25,734
you should be able
to find it.

1554
00:55:25,734 --> 00:55:28,434
Let's take a live question
over here on the left.

1555
00:55:28,434 --> 00:55:29,734
man: Yeah, real quick.

1556
00:55:29,734 --> 00:55:31,167
You didn't mention
the overhead involved

1557
00:55:31,167 --> 00:55:33,067
with UDP transmissions.

1558
00:55:33,067 --> 00:55:34,567
How does that compare?

1559
00:55:34,567 --> 00:55:36,200
Sharkey: Okay.
That's a good question.

1560
00:55:36,200 --> 00:55:38,968
So, right, there's a little
more overhead TCP connections

1561
00:55:38,968 --> 00:55:40,968
'cause we need to build up
the entire transaction.

1562
00:55:40,968 --> 00:55:44,100
There's a syn-ack process
that happens between both ends.

1563
00:55:44,100 --> 00:55:45,968
So there's more latency
involved.

1564
00:55:45,968 --> 00:55:48,000
So there's a little more
setup time there.

1565
00:55:48,000 --> 00:55:52,300
I would expect the UDP...
UDP is cheaper,

1566
00:55:52,300 --> 00:55:53,767
but when you think about it,

1567
00:55:53,767 --> 00:55:55,334
the devices are running
on mobile networks

1568
00:55:55,334 --> 00:55:57,434
that are definitely
not as reliable,

1569
00:55:57,434 --> 00:55:59,267
so UDP doesn't give you
any guarantees

1570
00:55:59,267 --> 00:56:01,234
that your message actually got
to the other end.

1571
00:56:01,234 --> 00:56:03,701
So most cases,
you do wanna use TCP

1572
00:56:03,701 --> 00:56:05,534
just because you'll have
that guarantee

1573
00:56:05,534 --> 00:56:07,000
that it made it across
the mobile network,

1574
00:56:07,000 --> 00:56:08,234
which might be flaky.

1575
00:56:08,234 --> 00:56:10,434
So UDP might offer you
some savings,

1576
00:56:10,434 --> 00:56:11,834
but I'd say in the long run,

1577
00:56:11,834 --> 00:56:14,567
you're probably gonna want
to go with TCP.

1578
00:56:14,567 --> 00:56:16,434
Let's take a question
over on the right.

1579
00:56:16,434 --> 00:56:18,133
man: Me?
Sharkey: Yeah, yeah.

1580
00:56:18,133 --> 00:56:19,901
man: What about screen
brightness?

1581
00:56:19,901 --> 00:56:21,601
How does that affect
the battery?

1582
00:56:21,601 --> 00:56:23,701
Sharkey: So I took a peek
at that,

1583
00:56:23,701 --> 00:56:25,567
so there's the 0% brightness
on the screen.

1584
00:56:25,567 --> 00:56:28,067
You can turn it all the way
down so it's very, very dim.

1585
00:56:28,067 --> 00:56:31,834
It ended up still taking
quite a bit of battery.

1586
00:56:31,834 --> 00:56:33,234
I think it was about
70 milliamps

1587
00:56:33,234 --> 00:56:34,467
at the lowest brightness.

1588
00:56:34,467 --> 00:56:35,634
And part of that was because

1589
00:56:35,634 --> 00:56:37,434
we're actually driving
the entire LCD.

1590
00:56:37,434 --> 00:56:39,834
We have that refresh rate
of up to 60 hertz

1591
00:56:39,834 --> 00:56:41,033
that we're pushing pixels,

1592
00:56:41,033 --> 00:56:43,000
so there was a lot of cost
with that.

1593
00:56:43,000 --> 00:56:44,501
And it was a little higher.

1594
00:56:44,501 --> 00:56:47,234
I think it was about 100, 110
if we had it at 100% brightness.

1595
00:56:47,234 --> 00:56:50,601
So roughly in that ballpark.

1596
00:56:50,601 --> 00:56:52,334
So the sweet spot
that the device--

1597
00:56:52,334 --> 00:56:54,133
someone asked the question
in the crowd,

1598
00:56:54,133 --> 00:56:56,667
what is the sweet spot
for the display brightness?

1599
00:56:56,667 --> 00:56:58,667
And the default one
that ships with the device

1600
00:56:58,667 --> 00:57:00,300
that most users
don't change it from,

1601
00:57:00,300 --> 00:57:02,701
that's the number
that I mentioned there,

1602
00:57:02,701 --> 00:57:05,701
which is about 90 milliamps
that it ends up costing.

1603
00:57:05,701 --> 00:57:07,534
That's right in the middle
of the road.

1604
00:57:07,534 --> 00:57:09,567
Let's take a couple questions
from the Moderator,

1605
00:57:09,567 --> 00:57:11,667
Someone asked, "Are there any
battery profiling tools

1606
00:57:11,667 --> 00:57:13,100
out there?"

1607
00:57:13,100 --> 00:57:15,133
And the short answer is,
sadly, no, there isn't.

1608
00:57:15,133 --> 00:57:17,734
However, there's
a direct correlation

1609
00:57:17,734 --> 00:57:20,901
between how much processing,
how much CPU you're using

1610
00:57:20,901 --> 00:57:23,234
and the impact
on battery life.

1611
00:57:23,234 --> 00:57:26,868
So if you're using tools--
so if you're using TraceView,

1612
00:57:26,868 --> 00:57:29,334
which is one of the tools
that's distributed with the SDK

1613
00:57:29,334 --> 00:57:31,901
to look at the amount of time
that your code is running,

1614
00:57:31,901 --> 00:57:33,534
it allows you to do
method level tracing

1615
00:57:33,534 --> 00:57:35,334
to see how many times
methods are called

1616
00:57:35,334 --> 00:57:37,033
and how much time overall
your app is taking

1617
00:57:37,033 --> 00:57:38,434
for certain operations.

1618
00:57:38,434 --> 00:57:40,834
If you're using TraceView,
that's a good indicator

1619
00:57:40,834 --> 00:57:43,167
of how much battery you're using
on the other side.

1620
00:57:43,167 --> 00:57:45,601
So, sad to say, there aren't
any direct profiling tools

1621
00:57:45,601 --> 00:57:48,767
kind of because
measuring milliamps

1622
00:57:48,767 --> 00:57:51,467
is somewhat
of an electronic black art.

1623
00:57:51,467 --> 00:57:52,901
You can't do it in software.

1624
00:57:52,901 --> 00:57:55,634
You actually need specific
hardware to directly measure it.

1625
00:57:55,634 --> 00:57:58,267
Take one more question
from Moderator.

1626
00:57:58,267 --> 00:58:00,701
"How can you customize the power
management features of Android

1627
00:58:00,701 --> 00:58:03,000
to enable more power modes?"

1628
00:58:03,000 --> 00:58:06,534
So this is actually--
the base Android system

1629
00:58:06,534 --> 00:58:08,501
doesn't come with very much
profile management,

1630
00:58:08,501 --> 00:58:10,434
but this is a place we've
actually seen in the Market.

1631
00:58:10,434 --> 00:58:12,601
Several apps have stepped up
to the challenge

1632
00:58:12,601 --> 00:58:14,801
and written apps
that help the user

1633
00:58:14,801 --> 00:58:16,200
manage their battery life.

1634
00:58:16,200 --> 00:58:17,667
So, for example,

1635
00:58:17,667 --> 00:58:19,601
Locale was one of the winners
of the first ADC

1636
00:58:19,601 --> 00:58:22,434
which allows you to change
your network preferences

1637
00:58:22,434 --> 00:58:25,400
to turn on WiFi when it sees
that you're getting near home

1638
00:58:25,400 --> 00:58:27,200
and to turn Bluetooth off

1639
00:58:27,200 --> 00:58:28,801
when you start getting
on the train,

1640
00:58:28,801 --> 00:58:31,367
'cause you wanna listen to music
on your Bluetooth headset.

1641
00:58:31,367 --> 00:58:34,234
So there's apps out there--
as of right now,

1642
00:58:34,234 --> 00:58:35,334
I don't think
there's any plans

1643
00:58:35,334 --> 00:58:36,834
of including that
in the platform.

1644
00:58:36,834 --> 00:58:38,767
I think it's a niche
that third-party apps

1645
00:58:38,767 --> 00:58:41,033
have filled very well.

1646
00:58:41,033 --> 00:58:42,567
Let's take a question
from the right.

1647
00:58:42,567 --> 00:58:46,434
man: I actually have
a question that's quite long.

1648
00:58:46,434 --> 00:58:50,567
So one is--can you go back
to the slides of the sensor,

1649
00:58:50,567 --> 00:58:52,400
the gaming side?

1650
00:58:52,400 --> 00:58:56,167
So, uh...and how you
calculate--yes.

1651
00:58:56,167 --> 00:58:58,367
How you calculated 10 milliamps.

1652
00:58:58,367 --> 00:59:00,267
Actually, accelerometer itself

1653
00:59:00,267 --> 00:59:03,400
only consume less than
half milliamps.

1654
00:59:03,400 --> 00:59:06,033
And what is like a--
Sharkey: Right, right.

1655
00:59:06,033 --> 00:59:07,367
Okay, so that's a good question.

1656
00:59:07,367 --> 00:59:09,267
He's asking, the actual
sensor in the device uses--

1657
00:59:09,267 --> 00:59:11,067
is very little power,

1658
00:59:11,067 --> 00:59:12,934
the accelerometer in the device,
the hardware,

1659
00:59:12,934 --> 00:59:14,934
the piece of hardware
that measures the accelerometer.

1660
00:59:14,934 --> 00:59:16,834
That device
uses very little power,

1661
00:59:16,834 --> 00:59:18,234
only a couple milliamps.

1662
00:59:18,234 --> 00:59:19,667
The overhead
that we're seeing here,

1663
00:59:19,667 --> 00:59:21,300
the cost between
these polling rates,

1664
00:59:21,300 --> 00:59:24,734
is because the device
is shipping that information,

1665
00:59:24,734 --> 00:59:26,767
those details,
the accelerometer,

1666
00:59:26,767 --> 00:59:29,534
the actual measurements,
up into Java code.

1667
00:59:29,534 --> 00:59:31,567
And that's where we start
to see the overhead.

1668
00:59:31,567 --> 00:59:33,334
We have to marshal that
into the Java environment.

1669
00:59:33,334 --> 00:59:34,968
And that's where we see
the overhead.

1670
00:59:34,968 --> 00:59:37,334
That's where we start seeing
this battery life.

1671
00:59:37,334 --> 00:59:38,767
So these battery measurements

1672
00:59:38,767 --> 00:59:41,167
aren't strictly the cost
of running the accelerometer.

1673
00:59:41,167 --> 00:59:43,601
They're the overhead of actually
having to pass that information

1674
00:59:43,601 --> 00:59:45,400
back up into the Java world.

1675
00:59:45,400 --> 00:59:50,534
man: Along that, so how you
think we can reduce that

1676
00:59:50,534 --> 00:59:53,100
by like interrupt driven by--

1677
00:59:53,100 --> 00:59:56,267
interrupt
for orientation detection

1678
00:59:56,267 --> 00:59:58,300
and you can reduce
the traffic?

1679
00:59:58,300 --> 01:00:00,734
Sharkey: Okay, so this--
man: So because...

1680
01:00:00,734 --> 01:00:04,534
I think the sensor manager
in the Android

1681
01:00:04,534 --> 01:00:06,067
do not take interrupt.

1682
01:00:06,067 --> 01:00:08,501
Sharkey: Okay, right now
the sensor manager's

1683
01:00:08,501 --> 01:00:10,033
just available from Java code,

1684
01:00:10,033 --> 01:00:12,634
so we're stuck with
this overhead right now.

1685
01:00:12,634 --> 01:00:14,434
With some of the other stuff

1686
01:00:14,434 --> 01:00:17,033
that Dan Morrill was covering
this morning,

1687
01:00:17,033 --> 01:00:18,868
talking about writing
native code,

1688
01:00:18,868 --> 01:00:21,067
I don't know if there's efforts

1689
01:00:21,067 --> 01:00:23,300
to have sensor manager available
in native code,

1690
01:00:23,300 --> 01:00:25,367
but that would actually help
save some of this overhead.

1691
01:00:25,367 --> 01:00:26,734
If you're writing C++ code

1692
01:00:26,734 --> 01:00:28,234
that can look directly
at the sensor values,

1693
01:00:28,234 --> 01:00:30,234
you can really help
save some battery.

1694
01:00:30,234 --> 01:00:32,234
You don't have the overhead
of going all the way up to Java.

1695
01:00:32,234 --> 01:00:33,734
Again, it's something
I'm not aware of

1696
01:00:33,734 --> 01:00:35,234
that people are working on
right now,

1697
01:00:35,234 --> 01:00:37,801
but it definitely would help
in the long run

1698
01:00:37,801 --> 01:00:39,634
for game developers.

1699
01:00:39,634 --> 01:00:41,868
Let's take a couple more
questions from Moderator,

1700
01:00:41,868 --> 01:00:44,467
'cause these are the ones
that you guys have voted up

1701
01:00:44,467 --> 01:00:46,067
over the course of the talk.

1702
01:00:46,067 --> 01:00:47,667
Okay, someone asked
the question,

1703
01:00:47,667 --> 01:00:50,100
"What is the rule of thumb
for employing caching of data

1704
01:00:50,100 --> 01:00:51,901
"to avoid repeated data
transmissions

1705
01:00:51,901 --> 01:00:53,934
and, consequently,
draining the battery?"

1706
01:00:53,934 --> 01:00:55,634
I have about ten seconds left,

1707
01:00:55,634 --> 01:00:58,334
so I'll quickly try to answer
this question.

1708
01:00:58,334 --> 01:00:59,901
So on the device,

1709
01:00:59,901 --> 01:01:02,667
probably the best place
to store a data cache

1710
01:01:02,667 --> 01:01:04,334
is on the SD card.

1711
01:01:04,334 --> 01:01:06,467
When you store it
in the internal directory,

1712
01:01:06,467 --> 01:01:08,100
internal structure for your app,

1713
01:01:08,100 --> 01:01:09,767
you're actually counting
against the space

1714
01:01:09,767 --> 01:01:12,367
that the user could be
installing other apps into.

1715
01:01:12,367 --> 01:01:15,334
So it's probably best
to use the SD card.

1716
01:01:15,334 --> 01:01:16,968
You can also check
the SD card state

1717
01:01:16,968 --> 01:01:19,634
using the environment object
in Java.

1718
01:01:19,634 --> 01:01:22,968
With that, I think we're
about half a minute past time.

1719
01:01:22,968 --> 01:01:24,367
I'd be happy to talk
with any of you guys.

1720
01:01:24,367 --> 01:01:26,701
If you have questions
afterwards, come up and talk.

1721
01:01:26,701 --> 01:01:28,467
Thanks for your time.

1722
01:01:28,467 --> 01:01:31,400
[applause]

