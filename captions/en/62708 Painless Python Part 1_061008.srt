1
00:00:03,000 --> 00:00:04,968
Martelli:
When you typically

2
00:00:04,968 --> 00:00:07,601
are trying things out,

3
00:00:07,601 --> 00:00:09,734
you want to see results
for what you're doing.

4
00:00:09,734 --> 00:00:11,200
How do you see results?

5
00:00:11,200 --> 00:00:12,968
Well, the--

6
00:00:12,968 --> 00:00:15,367
If you're working
at the interactive shell,

7
00:00:15,367 --> 00:00:17,467
then any expression you do

8
00:00:17,467 --> 00:00:19,801
which has a value
that is not none,

9
00:00:19,801 --> 00:00:22,067
it will be
represented for you

10
00:00:22,067 --> 00:00:23,467
on the screen.

11
00:00:23,467 --> 00:00:26,801
That is only useful
when you're trying things out.

12
00:00:26,801 --> 00:00:28,701
When you're doing a program

13
00:00:28,701 --> 00:00:31,067
but want to get
some extra output,

14
00:00:31,067 --> 00:00:32,267
like for debugging

15
00:00:32,267 --> 00:00:33,667
or understanding
what's going on,

16
00:00:33,667 --> 00:00:36,267
there's a statement
called "print."

17
00:00:36,267 --> 00:00:37,534
Very elementary.

18
00:00:37,534 --> 00:00:40,501
It just puts the strings
into standard I/O.

19
00:00:40,501 --> 00:00:43,334
You can use commas
to print multiple values.

20
00:00:43,334 --> 00:00:46,501
And it will put spaces
between the values

21
00:00:46,501 --> 00:00:48,200
and a new line at the end.

22
00:00:48,200 --> 00:00:49,868
In real program, of course,

23
00:00:49,868 --> 00:00:53,100
the way you do an output
is very, very different.

24
00:00:53,100 --> 00:00:55,000
An excellent way to do output,

25
00:00:55,000 --> 00:00:57,167
and very encouraged
in Google opinion,

26
00:00:57,167 --> 00:00:59,767
is the logging package
of the Python standard library,

27
00:00:59,767 --> 00:01:03,167
which basically
lets you log information

28
00:01:03,167 --> 00:01:04,501
at different levels.

29
00:01:04,501 --> 00:01:06,667
So you can tell the system,

30
00:01:06,667 --> 00:01:08,033
"This is for debugging."

31
00:01:08,033 --> 00:01:09,434
"This is for retrieve."

32
00:01:09,434 --> 00:01:11,067
"This is a warning."
"This is an error."

33
00:01:11,067 --> 00:01:12,701
"This is a fatal error."

34
00:01:12,701 --> 00:01:14,334
So you can be selective

35
00:01:14,334 --> 00:01:17,567
on what it is
that you're getting displayed.

36
00:01:17,567 --> 00:01:20,400
If you're writing
a web application,

37
00:01:20,400 --> 00:01:22,667
the typical way
you'll be seeing results

38
00:01:22,667 --> 00:01:27,767
is by adding string
to some HTML response object.

39
00:01:27,767 --> 00:01:30,033
If you're doing
a GUI application,

40
00:01:30,033 --> 00:01:31,634
then there will be
GUI widgets

41
00:01:31,634 --> 00:01:33,267
with their own methods
and so on.

42
00:01:33,267 --> 00:01:35,834
So I'm not going to focus
on any of these.

43
00:01:35,834 --> 00:01:37,868
I'm just going to use
print occasionally

44
00:01:37,868 --> 00:01:43,367
to show you what is the result
that you're going to get.

45
00:01:43,367 --> 00:01:46,467
And here's finally
some trivial examples.

46
00:01:46,467 --> 00:01:48,400
Python has the world record

47
00:01:48,400 --> 00:01:50,901
for the shortest
"Hello, world" program,

48
00:01:50,901 --> 00:01:53,033
the most classic program
in the world.

49
00:01:53,033 --> 00:01:54,467
You just have to use "print"

50
00:01:54,467 --> 00:01:56,133
to get to standard output

51
00:01:56,133 --> 00:01:57,400
and a string in quotes,

52
00:01:57,400 --> 00:01:58,801
and that's all
there is to it.

53
00:01:58,801 --> 00:02:00,400
Let's do some assignment.

54
00:02:00,400 --> 00:02:01,734
"X = 23"

55
00:02:01,734 --> 00:02:04,200
means X from now on
until further notice

56
00:02:04,200 --> 00:02:07,000
is bound to the number 23.

57
00:02:07,000 --> 00:02:08,667
So if you print X right now,

58
00:02:08,667 --> 00:02:11,601
it emits
on standard output 23.

59
00:02:11,601 --> 00:02:14,000
If you now say
"X = foo,"

60
00:02:14,000 --> 00:02:16,467
then whatever X
was referring to,

61
00:02:16,467 --> 00:02:18,133
X doesn't refer to anymore.

62
00:02:18,133 --> 00:02:20,334
Maybe somebody else does.
X doesn't care.

63
00:02:20,334 --> 00:02:23,667
The name X from now on
refers to the string "foo."

64
00:02:23,667 --> 00:02:26,501
And I'm deliberately using
objects of different types,

65
00:02:26,501 --> 00:02:27,834
like a number and a string,

66
00:02:27,834 --> 00:02:29,934
to point out
that the name X per se

67
00:02:29,934 --> 00:02:31,801
is totally at your disposal

68
00:02:31,801 --> 00:02:34,100
to refer to anything you want.

69
00:02:34,100 --> 00:02:35,501
What it is referring to

70
00:02:35,501 --> 00:02:37,367
depends on what
you last assigned to it.

71
00:02:37,367 --> 00:02:39,767
So now "print X"
emits "foo."

72
00:02:39,767 --> 00:02:42,067
And you can also
remove the binding.

73
00:02:42,067 --> 00:02:43,234
That's rarely done.

74
00:02:43,234 --> 00:02:45,100
But if you want,
you can "del X."

75
00:02:45,100 --> 00:02:47,067
This means from now on

76
00:02:47,067 --> 00:02:49,400
the name X doesn't refer
to anything anymore.

77
00:02:49,400 --> 00:02:51,634
Like if I'd never
assigned anything to it.

78
00:02:51,634 --> 00:02:55,133
So if you now print X,
that's an error.

79
00:02:55,133 --> 00:02:57,334
It raises an exception,
as we'll see

80
00:02:57,334 --> 00:03:00,601
because X doesn't refer
to anything.

81
00:03:00,601 --> 00:03:03,100
Well, what if you want X
to still be around

82
00:03:03,100 --> 00:03:04,934
but not refer to anything?

83
00:03:04,934 --> 00:03:06,434
Well, let's do it with Y.

84
00:03:06,434 --> 00:03:08,367
That's what
you use "none" for.

85
00:03:08,367 --> 00:03:11,267
"Y = none"
is different from "del Y."

86
00:03:11,267 --> 00:03:13,434
It means
"Y refers to something."

87
00:03:13,434 --> 00:03:14,767
"What?"
"Nothing."

88
00:03:14,767 --> 00:03:16,234
I know, it's a bit--

89
00:03:16,234 --> 00:03:18,000
So if you print Y,

90
00:03:18,000 --> 00:03:20,334
instead of an error,
you get "none."

91
00:03:20,334 --> 00:03:23,000
If you ever see a lot
of "none" in your output,

92
00:03:23,000 --> 00:03:24,501
you're probably
doing something wrong,

93
00:03:24,501 --> 00:03:26,133
but that's a good hint.

94
00:03:26,133 --> 00:03:29,000
Okay, so there are

95
00:03:29,000 --> 00:03:31,133
some pretty obvious
similarities

96
00:03:31,133 --> 00:03:33,501
between Python and Java.

97
00:03:33,501 --> 00:03:36,367
First of all,
in the implementation level,

98
00:03:36,367 --> 00:03:38,734
although there are variants
in both cases,

99
00:03:38,734 --> 00:03:42,534
they are both typically
compiled to bytecode.

100
00:03:42,534 --> 00:03:46,000
Python compiles implicitly.

101
00:03:46,000 --> 00:03:49,067
It's like it's got
a make engine built in.

102
00:03:49,067 --> 00:03:50,801
But the typical result

103
00:03:50,801 --> 00:03:53,634
is that a virtual machine,
or interpreter if you will,

104
00:03:53,634 --> 00:03:56,834
will execute in a controlled
importable way

105
00:03:56,834 --> 00:04:00,033
the bytecodes produced
by the compiler,

106
00:04:00,033 --> 00:04:02,367
explicit or implicit
as it may be.

107
00:04:02,367 --> 00:04:03,701
In both languages,

108
00:04:03,701 --> 00:04:05,868
everything inherits
from object,

109
00:04:05,868 --> 00:04:09,033
except it's spelled
with a lowercase O in Python.

110
00:04:09,033 --> 00:04:12,100
That's hardly
a deep difference.

111
00:04:12,100 --> 00:04:14,667
In Python, everything
is a first-class object.

112
00:04:14,667 --> 00:04:18,667
So in Java,
a method or a class per se

113
00:04:18,667 --> 00:04:20,767
does not constitute
an object.

114
00:04:20,767 --> 00:04:22,133
In Python, it does.

115
00:04:22,133 --> 00:04:24,100
There is nothing
that is just

116
00:04:24,100 --> 00:04:26,300
a compile time construct

117
00:04:26,300 --> 00:04:29,767
and doesn't have
an object responding to it.

118
00:04:29,767 --> 00:04:33,968
Same for numbers
and so on.

119
00:04:33,968 --> 00:04:36,300
Commonality,
a very deep, important,

120
00:04:36,300 --> 00:04:39,133
absolutely crucial commonality
between Java and Python,

121
00:04:39,133 --> 00:04:41,367
they both uniform
object reference semantics.

122
00:04:41,367 --> 00:04:45,667
In other languages,
such as C++ or C,

123
00:04:45,667 --> 00:04:47,834
when you say "A = B,"

124
00:04:47,834 --> 00:04:50,033
this means
a lot of bits from B

125
00:04:50,033 --> 00:04:52,734
are going to be copied over
into A.

126
00:04:52,734 --> 00:04:55,067
There's a copy implied.

127
00:04:55,067 --> 00:04:56,100
In Java or Python,

128
00:04:56,100 --> 00:04:57,734
when you write "A = B,"

129
00:04:57,734 --> 00:04:59,033
it means from now on

130
00:04:59,033 --> 00:05:01,400
A refers to exactly
the same object

131
00:05:01,400 --> 00:05:03,601
as B referred to
at that time.

132
00:05:03,601 --> 00:05:06,167
So everything,
and this goes for assignment,

133
00:05:06,167 --> 00:05:08,501
it goes for argument-passing,
goes for return values,

134
00:05:08,501 --> 00:05:13,200
everything is about
having names refer to objects

135
00:05:13,200 --> 00:05:15,701
as opposed
to having names

136
00:05:15,701 --> 00:05:19,734
be boxes with bits in them.

137
00:05:19,734 --> 00:05:23,300
Both languages
have garbage collection.

138
00:05:23,300 --> 00:05:25,801
The classic
Python implementation

139
00:05:25,801 --> 00:05:28,467
tries hard to collect garbage

140
00:05:28,467 --> 00:05:31,200
much more proactively
than Java.

141
00:05:31,200 --> 00:05:33,133
It doesn't wait
to collect garbage

142
00:05:33,133 --> 00:05:35,734
until there's
a lot of garbage around.

143
00:05:35,734 --> 00:05:39,734
It tries to collect garbage
as soon as it possible can,

144
00:05:39,734 --> 00:05:42,901
basically to save
the run time memory

145
00:05:42,901 --> 00:05:45,334
from going to waste.

146
00:05:45,334 --> 00:05:48,467
Other implementations of Python,
however, don't do that.

147
00:05:48,467 --> 00:05:51,601
A lot of what is in common
between Java and Python

148
00:05:51,601 --> 00:05:54,601
are stuff outside
the language proper.

149
00:05:54,601 --> 00:05:56,267
That's why I call them
"marginalia,"

150
00:05:56,267 --> 00:05:58,501
but very important
to your everyday use.

151
00:05:58,501 --> 00:06:01,367
Both have huge
standard libraries.

152
00:06:01,367 --> 00:06:04,834
Both have enormous amounts
of third-party packages

153
00:06:04,834 --> 00:06:06,868
and tools available.

154
00:06:06,868 --> 00:06:08,501
Both let you do
introspection,

155
00:06:08,501 --> 00:06:10,467
serialization,
threading,

156
00:06:10,467 --> 00:06:13,033
all as part
of the standard libraries.

157
00:06:13,033 --> 00:06:15,300
So if you're coming
from Java,

158
00:06:15,300 --> 00:06:18,000
you'll have to learn
all the different ways

159
00:06:18,000 --> 00:06:20,267
you can do those things
in CPython,

160
00:06:20,267 --> 00:06:22,534
but the fact
that you can do them

161
00:06:22,534 --> 00:06:24,968
is very much in common.

162
00:06:24,968 --> 00:06:27,300
Now if you're coming
from C++ instead,

163
00:06:27,300 --> 00:06:28,534
what's similar?

164
00:06:28,534 --> 00:06:30,667
Well, they're
both multi-paradigm.

165
00:06:30,667 --> 00:06:32,834
Java basically tries
to force you

166
00:06:32,834 --> 00:06:34,501
into object-oriented
programming.

167
00:06:34,501 --> 00:06:37,267
Python and C++
are happy if you do OOP,

168
00:06:37,267 --> 00:06:40,100
but if you want to do
procedural programming

169
00:06:40,100 --> 00:06:41,601
or generic programming

170
00:06:41,601 --> 00:06:43,567
or a little bit
of functioning programming,

171
00:06:43,567 --> 00:06:46,834
they'll happily
adjust to that.

172
00:06:46,834 --> 00:06:49,534
Both languages
have multiple inheritance.

173
00:06:49,534 --> 00:06:53,200
So you don't have to force
everything into a single tree.

174
00:06:53,200 --> 00:06:55,534
You can use
any directed or cyclic graph

175
00:06:55,534 --> 00:06:57,634
with caution
in both languages.

176
00:06:57,634 --> 00:06:59,601
You can do
operator overloading.

177
00:06:59,601 --> 00:07:03,133
The one thing that many
C++ programmer

178
00:07:03,133 --> 00:07:04,667
think they can do

179
00:07:04,667 --> 00:07:07,501
because they can do in C++
and they cannot do in Python

180
00:07:07,501 --> 00:07:09,868
is to overload the assignment.

181
00:07:09,868 --> 00:07:12,434
In Python,
assignment has exactly

182
00:07:12,434 --> 00:07:14,300
the Java semantics always.

183
00:07:14,300 --> 00:07:16,934
It's always
an object reference.

184
00:07:16,934 --> 00:07:19,133
There is no way
for you to redefine

185
00:07:19,133 --> 00:07:20,934
what assignment means.

186
00:07:20,934 --> 00:07:23,400
Assignment is not
an operator in Python.

187
00:07:23,400 --> 00:07:26,334
Everything else
that you can do in C++

188
00:07:26,334 --> 00:07:30,868
and a lot of operators
that are not operators in C++

189
00:07:30,868 --> 00:07:34,334
you can redefine in Python.

190
00:07:34,334 --> 00:07:38,901
If you're very used to doing
generic programming in C++,

191
00:07:38,901 --> 00:07:42,601
you know what signature based
polymorphism is.

192
00:07:42,601 --> 00:07:45,501
In C++ it's also spelled
"templates."

193
00:07:45,501 --> 00:07:47,667
Basically in Python
everything you're writing

194
00:07:47,667 --> 00:07:50,567
is always a template
implicitly,

195
00:07:50,567 --> 00:07:52,267
without any effort
on your part.

196
00:07:52,267 --> 00:07:53,701
Very nice index.

197
00:07:53,701 --> 00:07:56,267
So if you think
in terms of signatures,

198
00:07:56,267 --> 00:07:59,434
Python supports signatures
implicitly.

199
00:07:59,434 --> 00:08:01,167
Similarity--

200
00:08:01,167 --> 00:08:05,200
The marginal similarity
between C++ and Python

201
00:08:05,200 --> 00:08:07,801
is that both offer
abundant choices,

202
00:08:07,801 --> 00:08:10,400
maybe even too many,
for just about everything

203
00:08:10,400 --> 00:08:13,434
that's not an absolutely
core issue.

204
00:08:13,434 --> 00:08:15,534
What GUI you want to use?

205
00:08:15,534 --> 00:08:17,834
Basically any.

206
00:08:17,834 --> 00:08:20,501
Web, other networking,
databases,

207
00:08:20,501 --> 00:08:23,100
inter-program communication,
distributed processing.

208
00:08:23,100 --> 00:08:26,734
The languages don't come
with a pre-bound solution.

209
00:08:26,734 --> 00:08:28,267
You have to choose.

210
00:08:28,267 --> 00:08:30,534
There's a huge possibility
of choices,

211
00:08:30,534 --> 00:08:32,534
but sometimes
it can be penalizing

212
00:08:32,534 --> 00:08:35,667
to have too many choices.

213
00:08:35,667 --> 00:08:39,467
Now some people get surprised
when I point out

214
00:08:39,467 --> 00:08:42,267
that Python
is the one language

215
00:08:42,267 --> 00:08:44,667
that is most close to C.

216
00:08:44,667 --> 00:08:46,200
Of course the syntax
is different,

217
00:08:46,200 --> 00:08:48,701
but we know syntax
is only skin deep.

218
00:08:48,701 --> 00:08:50,334
What is similar?

219
00:08:50,334 --> 00:08:52,667
It's the spirit
of the language.

220
00:08:52,667 --> 00:08:54,667
And we can tell
because the spirit of C

221
00:08:54,667 --> 00:08:59,300
is officially acknowledged
as a part of the C Standard.

222
00:08:59,300 --> 00:09:03,367
It's in the rationale
of the ISO C Standard.

223
00:09:03,367 --> 00:09:07,667
And the spirit of C
consists of five principles.

224
00:09:07,667 --> 00:09:09,767
Trust the programmer.

225
00:09:09,767 --> 00:09:12,634
That's point one
of the spirit of C.

226
00:09:12,634 --> 00:09:15,901
Don't try to second-guess
the programmer.

227
00:09:15,901 --> 00:09:17,400
Trust him.

228
00:09:17,400 --> 00:09:20,100
C does that.
Python does that.

229
00:09:20,100 --> 00:09:22,734
C++ and Java do not.

230
00:09:22,734 --> 00:09:26,133
They try to make sure

231
00:09:26,133 --> 00:09:28,701
the programmer doesn't
get out of the sandbox.

232
00:09:28,701 --> 00:09:31,968
You know, private,
protected, and things.

233
00:09:31,968 --> 00:09:33,634
Don't stop the programmer

234
00:09:33,634 --> 00:09:35,300
from doing
what needs to be done.

235
00:09:35,300 --> 00:09:37,501
That's basically
a follow on from point one.

236
00:09:37,501 --> 00:09:39,801
Keep the language
small and simple.

237
00:09:39,801 --> 00:09:42,400
Don't add keywords
that are only needed

238
00:09:42,400 --> 00:09:44,534
because you don't trust
the programmers,

239
00:09:44,534 --> 00:09:46,200
like private.

240
00:09:46,200 --> 00:09:48,968
Provide only one way
to do an operation.

241
00:09:48,968 --> 00:09:52,133
This is something that C++
violates pretty badly

242
00:09:52,133 --> 00:09:55,033
because it always
provides more than one way

243
00:09:55,033 --> 00:09:57,067
because you can always
do things the C way

244
00:09:57,067 --> 00:09:59,300
or you can do them
the object-oriented way

245
00:09:59,300 --> 00:10:00,634
or you can do them
the generic way.

246
00:10:00,634 --> 00:10:02,934
So there's typically
three ways to do anything.

247
00:10:02,934 --> 00:10:06,367
In C philosophically
and Python philosophically,

248
00:10:06,367 --> 00:10:07,801
there should be only one way.

249
00:10:07,801 --> 00:10:10,067
And then the one bit

250
00:10:10,067 --> 00:10:13,667
where Python
doesn't really match C,

251
00:10:13,667 --> 00:10:17,801
the fifth most important
principle of C is be fast.

252
00:10:17,801 --> 00:10:20,901
Python cares more about
programmer productivity

253
00:10:20,901 --> 00:10:22,367
than raw speed.

254
00:10:22,367 --> 00:10:25,300
So it's only
about 50% there.

255
00:10:25,300 --> 00:10:27,200
It's got some very fast way
to do things,

256
00:10:27,200 --> 00:10:32,667
but it always privileges
programmer productivity instead.

257
00:10:32,667 --> 00:10:37,434
While C has
its own spirit

258
00:10:37,434 --> 00:10:39,234
encoded in the standard,

259
00:10:39,234 --> 00:10:40,968
Python doesn't have
an official standard,

260
00:10:40,968 --> 00:10:43,234
but if you type
"import this"

261
00:10:43,234 --> 00:10:45,501
at any interactive
Python prompt,

262
00:10:45,501 --> 00:10:49,000
you'll get the equivalent--
the Zen of Python.

263
00:10:49,000 --> 00:10:52,067
And this
is the one principle--

264
00:10:52,067 --> 00:10:53,901
This is the way,
for example,

265
00:10:53,901 --> 00:10:55,667
in which Python expresses

266
00:10:55,667 --> 00:10:58,934
the only one way
to perform an operation.

267
00:10:58,934 --> 00:11:00,200
It's a bit more verbose.

268
00:11:00,200 --> 00:11:02,200
There should be one,

269
00:11:02,200 --> 00:11:04,834
and preferably only one way
to do it.

270
00:11:04,834 --> 00:11:09,434
So it's more clear
in the Python formulation

271
00:11:09,434 --> 00:11:12,267
that this is an objective,
a target,

272
00:11:12,267 --> 00:11:13,801
a stretch goal.

273
00:11:13,801 --> 00:11:15,567
It's not something
we can actually do.

274
00:11:15,567 --> 00:11:17,968
Nobody's going to stop you
from saying,

275
00:11:17,968 --> 00:11:19,701
"Two plus three
or three plus two,"

276
00:11:19,701 --> 00:11:21,501
which are two ways to perform
the same operation

277
00:11:21,501 --> 00:11:23,334
in a trivial sense.

278
00:11:23,334 --> 00:11:26,234
It would make the language
more complicated

279
00:11:26,234 --> 00:11:28,267
to try and forbid it.

280
00:11:28,267 --> 00:11:30,567
So now that we've seen
similarities

281
00:11:30,567 --> 00:11:33,167
of Python to some languages
you might be familiar with,

282
00:11:33,167 --> 00:11:34,501
let's see--

283
00:11:34,501 --> 00:11:36,100
So what's different?

284
00:11:36,100 --> 00:11:38,100
If this is in common,
this is in common,

285
00:11:38,100 --> 00:11:39,367
this is in common,

286
00:11:39,367 --> 00:11:41,434
what is not in common
with any of them?

287
00:11:41,434 --> 00:11:43,734
Well, there's two points.

288
00:11:43,734 --> 00:11:48,234
First of all, Python has
very spare syntax,

289
00:11:48,234 --> 00:11:51,000
no ornamentation.

290
00:11:51,000 --> 00:11:53,067
It applies,
Tufte's principle,

291
00:11:53,067 --> 00:11:54,767
no wasted pixels.

292
00:11:54,767 --> 00:11:56,734
If you don't know
who Edward Tufte is,

293
00:11:56,734 --> 00:12:01,334
I suggest you should
buy his masterpiece.

294
00:12:01,334 --> 00:12:02,834
He's got several books out,

295
00:12:02,834 --> 00:12:05,934
but "The Visual Display
of Quantitative Information"

296
00:12:05,934 --> 00:12:07,734
is an immortal masterpiece.

297
00:12:07,734 --> 00:12:11,267
It's a book on how do we
display information graphically?

298
00:12:11,267 --> 00:12:14,767
And the core principle
is every pixel is precious.

299
00:12:14,767 --> 00:12:18,501
Don't put a pixel there unless
it communicates information.

300
00:12:18,501 --> 00:12:21,267
So for example,

301
00:12:21,267 --> 00:12:25,834
why does Python respect
Tufte's principle?

302
00:12:25,834 --> 00:12:29,968
Well, you don't put braces
or begin and end keywords

303
00:12:29,968 --> 00:12:31,367
around a block.

304
00:12:31,367 --> 00:12:32,667
You just indent it.

305
00:12:32,667 --> 00:12:34,400
Don't waste any pixel.

306
00:12:34,400 --> 00:12:36,033
You don't put parenthesis

307
00:12:36,033 --> 00:12:37,767
around a condition
in an "if" or "while."

308
00:12:37,767 --> 00:12:38,901
Why should you?

309
00:12:38,901 --> 00:12:40,167
You just write it

310
00:12:40,167 --> 00:12:42,667
like "if, space,
condition, colon."

311
00:12:42,667 --> 00:12:43,834
That's it.

312
00:12:43,834 --> 00:12:45,834
No parenthesis.
No wasted pixels.

313
00:12:45,834 --> 00:12:48,968
In general, Python
doesn't like punctuation.

314
00:12:48,968 --> 00:12:51,267
It uses
very spare punctuation

315
00:12:51,267 --> 00:12:56,367
and prefers to go
for keywords instead.

316
00:12:56,367 --> 00:12:58,567
And then there's the semantics.

317
00:12:58,567 --> 00:13:01,033
Of course syntax
is what strikes you first,

318
00:13:01,033 --> 00:13:06,033
but deep down the semantics
are much more important.

319
00:13:06,033 --> 00:13:08,834
Python typing is strong
but dynamic.

320
00:13:08,834 --> 00:13:10,534
That is it's strong.

321
00:13:10,534 --> 00:13:12,033
It's stronger than C
for example.

322
00:13:12,033 --> 00:13:13,434
You cannot say,

323
00:13:13,434 --> 00:13:15,734
"Take these bits
which used to be this type

324
00:13:15,734 --> 00:13:19,167
and make believe they're
this other type instead."

325
00:13:19,167 --> 00:13:22,400
With a cast,
you cannot do that.

326
00:13:22,400 --> 00:13:24,567
An object has integrity.

327
00:13:24,567 --> 00:13:27,701
It's very strong typing.

328
00:13:27,701 --> 00:13:31,133
About as strong as Java,
I would say, or a bit more.

329
00:13:31,133 --> 00:13:33,200
But names have no types.

330
00:13:33,200 --> 00:13:34,601
A name is a name
is a name.

331
00:13:34,601 --> 00:13:36,167
The object has a type,

332
00:13:36,167 --> 00:13:37,801
and the name
refers to the object.

333
00:13:37,801 --> 00:13:39,734
So at any given time,

334
00:13:39,734 --> 00:13:41,767
the name will be referring
to something with a type

335
00:13:41,767 --> 00:13:45,033
but will not have
any type itself.

336
00:13:45,033 --> 00:13:47,901
And this is also
known as "duck typing."

337
00:13:47,901 --> 00:13:49,901
That is,
if it walks like a duck

338
00:13:49,901 --> 00:13:52,367
and quacks like a duck,
it's a duck.

339
00:13:52,367 --> 00:13:54,234
That is not necessarily
the case.

340
00:13:54,234 --> 00:13:57,400
A few years ago a species
that had been identified

341
00:13:57,400 --> 00:13:59,734
as a duck sometimes
in memorial

342
00:13:59,734 --> 00:14:02,701
was actually revealed
by DNA analysis to be a goose,

343
00:14:02,701 --> 00:14:05,934
A goose that had evolved
to basically

344
00:14:05,934 --> 00:14:10,434
live in exactly the same
ecological niches as ducks have

345
00:14:10,434 --> 00:14:11,968
in other the places.

346
00:14:11,968 --> 00:14:14,334
I'm told it even
tasted like duck

347
00:14:14,334 --> 00:14:16,667
if you cooked it.

348
00:14:16,667 --> 00:14:19,267
Well, so it's not necessarily
true that it is a duck,

349
00:14:19,267 --> 00:14:21,667
but it's very true that
you could treat it as a duck

350
00:14:21,667 --> 00:14:25,300
for just about every purpose
in your life.

351
00:14:25,300 --> 00:14:27,701
There's no declarations.

352
00:14:27,701 --> 00:14:30,000
Declarations
are great for lovers.

353
00:14:30,000 --> 00:14:32,868
I want to make
a love declaration to my wife.

354
00:14:32,868 --> 00:14:37,133
But in life,
what you want is action,

355
00:14:37,133 --> 00:14:39,400
not empty words,
not declarations.

356
00:14:39,400 --> 00:14:42,567
You want statements,
actions.

357
00:14:42,567 --> 00:14:44,267
And that's
what Python gives you.

358
00:14:44,267 --> 00:14:46,367
Everything is a statement.

359
00:14:46,367 --> 00:14:48,300
Everything
is a first-class object.

360
00:14:48,300 --> 00:14:51,234
No need to distinguish,
is a function an object?

361
00:14:51,234 --> 00:14:53,167
Is a class an object?
Yes.

362
00:14:53,167 --> 00:14:55,100
A module is an object,
a package is an object.

363
00:14:55,100 --> 00:14:57,400
Everything is an object.

364
00:14:57,400 --> 00:15:00,000
The focus in Python

365
00:15:00,000 --> 00:15:01,901
is always
on the very high level,

366
00:15:01,901 --> 00:15:03,634
on the programmer
productivity.

367
00:15:03,634 --> 00:15:07,167
How does a programmer
think about his problem?

368
00:15:07,167 --> 00:15:11,534
We do try to support
bit twiddling at lower levels,

369
00:15:11,534 --> 00:15:13,701
but that's
a second-order of priority,

370
00:15:13,701 --> 00:15:15,467
while in seen particular

371
00:15:15,467 --> 00:15:17,434
it's very much
the top priority

372
00:15:17,434 --> 00:15:20,033
to support the way
the machine works.

373
00:15:20,033 --> 00:15:21,968
So about duck typing again,

374
00:15:21,968 --> 00:15:24,734
this is an alternative
interpretation

375
00:15:24,734 --> 00:15:27,000
of the expression
"duck typing,"

376
00:15:27,000 --> 00:15:28,801
which would be connected

377
00:15:28,801 --> 00:15:30,901
with not having to do
the typing yourself

378
00:15:30,901 --> 00:15:32,834
but training a duck
to do it for you.

379
00:15:32,834 --> 00:15:34,067
I think it would take

380
00:15:34,067 --> 00:15:35,634
quite a while
to train the duck,

381
00:15:35,634 --> 00:15:37,267
but if you can make it

382
00:15:37,267 --> 00:15:40,133
that should certainly improve
your productivity.

383
00:15:40,133 --> 00:15:41,667
Back to technical issues.

384
00:15:41,667 --> 00:15:43,033
Flow control,

385
00:15:43,033 --> 00:15:46,100
there's basically
four flow control statement--

386
00:15:46,100 --> 00:15:48,601
if, while, for, and with.

387
00:15:48,601 --> 00:15:52,033
You're probably familiar
with "if" and "while."

388
00:15:52,033 --> 00:15:54,367
And this "for"
is more equivalent

389
00:15:54,367 --> 00:15:57,434
to the "for each"
of Java.

390
00:15:57,434 --> 00:16:00,400
But, um,
what you should notice

391
00:16:00,400 --> 00:16:04,000
is instead of going
"else if,"

392
00:16:04,000 --> 00:16:06,167
there's an "elif,"
collapsed "elif,"

393
00:16:06,167 --> 00:16:07,968
that you can have
in an "if"

394
00:16:07,968 --> 00:16:09,667
and the optional "else."

395
00:16:09,667 --> 00:16:12,334
Loops, beside
the "break" and "continue,"

396
00:16:12,334 --> 00:16:14,567
just like in C and so on,

397
00:16:14,567 --> 00:16:16,067
also have an optional "else."

398
00:16:16,067 --> 00:16:18,734
That's somewhat unusual
in programming languages.

399
00:16:18,734 --> 00:16:20,934
The point is the "else" branch

400
00:16:20,934 --> 00:16:23,467
gets executed
if the "while" loop

401
00:16:23,467 --> 00:16:24,934
terminates naturally,

402
00:16:24,934 --> 00:16:26,567
not by a break.

403
00:16:26,567 --> 00:16:29,000
That is very handy sometimes.

404
00:16:29,000 --> 00:16:31,868
And the "for" has exactly
the same features.

405
00:16:31,868 --> 00:16:33,767
Now, "with"
is a relatively new statement,

406
00:16:33,767 --> 00:16:36,667
so if you want to use it
in 2.5,

407
00:16:36,667 --> 00:16:40,701
you will require
an import from the future.

408
00:16:40,701 --> 00:16:44,100
That's how we express
changes in Python

409
00:16:44,100 --> 00:16:47,200
that are not 100%
backwards compatible.

410
00:16:47,200 --> 00:16:50,000
We require the programmer

411
00:16:50,000 --> 00:16:52,667
to import them
from the future.

412
00:16:52,667 --> 00:16:55,868
That's because "with"
has become a keyword

413
00:16:55,868 --> 00:16:57,267
with this feature.

414
00:16:57,267 --> 00:16:59,267
We'll deal with that

415
00:16:59,267 --> 00:17:01,767
when we treat exception.

416
00:17:01,767 --> 00:17:03,367
But it's a very important--

417
00:17:03,367 --> 00:17:07,801
It's a very important
new control statement.

418
00:17:07,801 --> 00:17:09,534
So then we have data.

419
00:17:09,534 --> 00:17:11,767
We have simple types
and container types

420
00:17:11,767 --> 00:17:13,367
that are built in.

421
00:17:13,367 --> 00:17:15,601
Simple types
are all immutable,

422
00:17:15,601 --> 00:17:17,834
that is the number 23
is the number 23

423
00:17:17,834 --> 00:17:19,300
is the number 23,

424
00:17:19,300 --> 00:17:21,200
and it will never
be any other number.

425
00:17:21,200 --> 00:17:23,133
The name that you're using

426
00:17:23,133 --> 00:17:24,734
at some point
to refer to 23,

427
00:17:24,734 --> 00:17:26,801
you can use later
to refer to 24.

428
00:17:26,801 --> 00:17:29,501
That doesn't mean
you've changed the number.

429
00:17:29,501 --> 00:17:32,968
The mathematicians
would never approve.

430
00:17:32,968 --> 00:17:34,300
Uh, one thing I should notice

431
00:17:34,300 --> 00:17:36,167
is that Python
has complex numbers,

432
00:17:36,167 --> 00:17:37,834
which is very unusual
these days.

433
00:17:37,834 --> 00:17:39,901
It used to be standard.

434
00:17:39,901 --> 00:17:42,667
That's maybe part of why
Python is so popular

435
00:17:42,667 --> 00:17:45,334
for scientific computing
as well,

436
00:17:45,334 --> 00:17:46,934
'cause it's got
complex numbers,

437
00:17:46,934 --> 00:17:48,334
which are very handy
in some kind

438
00:17:48,334 --> 00:17:50,200
of technical
and scientific computing.

439
00:17:50,200 --> 00:17:52,200
And it's got
the star, star operator,

440
00:17:52,200 --> 00:17:53,634
which is a raise to power,

441
00:17:53,634 --> 00:17:56,133
which is also
extremely handy.

442
00:17:56,133 --> 00:17:58,300
Um, and then strings.

443
00:17:58,300 --> 00:18:00,868
Unfortunately two kinds,
plain and Unicode.

444
00:18:00,868 --> 00:18:02,767
I say "unfortunately"
because, well,

445
00:18:02,767 --> 00:18:05,868
it's better than only having
the plain strings like Ruby.

446
00:18:05,868 --> 00:18:07,701
But it's definitely inferior

447
00:18:07,701 --> 00:18:10,634
to only having
the Unicode strings like Java

448
00:18:10,634 --> 00:18:12,601
because these days

449
00:18:12,601 --> 00:18:15,067
we all want to have
internationalized stuff.

450
00:18:15,067 --> 00:18:17,601
This means you should
support Unicode.

451
00:18:17,601 --> 00:18:19,234
This is a big simplification

452
00:18:19,234 --> 00:18:20,901
that we're doing
in Python three,

453
00:18:20,901 --> 00:18:22,501
which is now in alpha.

454
00:18:22,501 --> 00:18:24,100
It's gonna be
in beta soon.

455
00:18:24,100 --> 00:18:25,767
Removing the distinction

456
00:18:25,767 --> 00:18:29,367
and only having Unicode strings
just like Java.

457
00:18:29,367 --> 00:18:32,400
You can concatenate,
repeat, format.

458
00:18:32,400 --> 00:18:36,367
Format is like
a "printf" in C.

459
00:18:36,367 --> 00:18:38,934
It's a very rich language.

460
00:18:38,934 --> 00:18:41,467
And they're
immutable sequences.

461
00:18:41,467 --> 00:18:44,300
So you can take the length.

462
00:18:44,300 --> 00:18:46,000
You can use brackets
to index or slice.

463
00:18:46,000 --> 00:18:48,701
You can do a "for" loop.

464
00:18:48,701 --> 00:18:50,634
And just like in Java script,

465
00:18:50,634 --> 00:18:53,300
each item in a string
is a character

466
00:18:53,300 --> 00:18:54,834
but there's
no character types,

467
00:18:54,834 --> 00:18:57,200
so each character
is a length-one string.

468
00:18:57,200 --> 00:18:59,033
Take care about that.

469
00:18:59,033 --> 00:19:02,033
And of course there's
a huge amount of methods.

470
00:19:02,033 --> 00:19:04,100
How do you find out
all the methods

471
00:19:04,100 --> 00:19:06,000
that you can use
on a Python string?

472
00:19:06,000 --> 00:19:08,868
Well, this is how you discover
a method on anything.

473
00:19:08,868 --> 00:19:11,267
You do the,
at the interactive prompt,

474
00:19:11,267 --> 00:19:13,100
dir, D-I-R,

475
00:19:13,100 --> 00:19:15,200
of the object
you are interested in.

476
00:19:15,200 --> 00:19:17,434
In this case,
quote, something, quote.

477
00:19:17,434 --> 00:19:20,934
And you get
a huge list of names

478
00:19:20,934 --> 00:19:23,501
of all the attributes,
including methods,

479
00:19:23,501 --> 00:19:25,033
of that object.

480
00:19:25,033 --> 00:19:26,501
You will notice
that a lot of them

481
00:19:26,501 --> 00:19:28,367
have two underscores
before and after.

482
00:19:28,367 --> 00:19:30,367
We'll come back to that
in the second part.

483
00:19:30,367 --> 00:19:32,133
And others
are just identifiers,

484
00:19:32,133 --> 00:19:34,200
like "center."

485
00:19:34,200 --> 00:19:35,868
So now you ask yourself,

486
00:19:35,868 --> 00:19:37,300
so what's that "center" thing?

487
00:19:37,300 --> 00:19:40,067
And this
is where help comes.

488
00:19:40,067 --> 00:19:43,634
You can "help,
open paren,

489
00:19:43,634 --> 00:19:44,901
something you want
help about."

490
00:19:44,901 --> 00:19:46,634
Note that is not center.

491
00:19:46,634 --> 00:19:48,701
It's "some string, dot, center."

492
00:19:48,701 --> 00:19:51,434
Because you want
the attribute or method

493
00:19:51,434 --> 00:19:53,501
center of a string,

494
00:19:53,501 --> 00:19:54,968
not of some other object.

495
00:19:54,968 --> 00:19:56,868
So you have to say that.

496
00:19:56,868 --> 00:19:59,000
And this is what it tells you.

497
00:19:59,000 --> 00:20:00,834
It's return string

498
00:20:00,834 --> 00:20:03,033
centered in a string
of a certain length,

499
00:20:03,033 --> 00:20:04,868
padded in a certain way.

500
00:20:04,868 --> 00:20:09,000
Once you've found out
the basic guidance,

501
00:20:09,000 --> 00:20:11,000
well, then you experiment.

502
00:20:11,000 --> 00:20:13,634
That's what the interactive
interpreter is from.

503
00:20:13,634 --> 00:20:16,968
You try "center"
with a fill character

504
00:20:16,968 --> 00:20:18,968
that's more visible,
like a plus.

505
00:20:18,968 --> 00:20:21,567
And yes, "ciao"
in a field of ten

506
00:20:21,567 --> 00:20:23,801
is "three plusses,
ciao, three plusses."

507
00:20:23,801 --> 00:20:25,601
In field of three,
does it truncate?

508
00:20:25,601 --> 00:20:27,634
No, it leaves it alone.

509
00:20:27,634 --> 00:20:29,701
What if the field is odd?

510
00:20:29,701 --> 00:20:32,701
Well, the extra one goes
at the beginning and so on.

511
00:20:32,701 --> 00:20:36,133
You don't find all of these
finely detailed in "help."

512
00:20:36,133 --> 00:20:38,234
You do find them
in "Python in a Nutshell,"

513
00:20:38,234 --> 00:20:39,567
plug, plug.

514
00:20:39,567 --> 00:20:41,434
But you don't need it

515
00:20:41,434 --> 00:20:44,100
because you can always
find them out interactively,

516
00:20:44,100 --> 00:20:45,601
experimentally.

517
00:20:45,601 --> 00:20:47,234
And that's a great way
to learn things

518
00:20:47,234 --> 00:20:48,868
because you actually
try them out.

519
00:20:48,868 --> 00:20:50,167
Learn by doing.

520
00:20:50,167 --> 00:20:52,067
And then we have
container types.

521
00:20:52,067 --> 00:20:53,934
Container types
include tuple,

522
00:20:53,934 --> 00:20:55,501
which are immutable sequences,

523
00:20:55,501 --> 00:20:57,634
and lists,
which are mutable sequences.

524
00:20:57,634 --> 00:20:59,601
They're typically denoted
with parenthesis

525
00:20:59,601 --> 00:21:01,701
versus square brackets.

526
00:21:01,701 --> 00:21:03,434
You also need a comma here,

527
00:21:03,434 --> 00:21:05,434
otherwise "(23)."

528
00:21:05,434 --> 00:21:07,634
would just be
the number 23

529
00:21:07,634 --> 00:21:10,701
because the parenthesis
are used in expressions as well.

530
00:21:10,701 --> 00:21:12,734
You don't need,
although you could have,

531
00:21:12,734 --> 00:21:14,334
an extra comma here.

532
00:21:14,334 --> 00:21:16,334
And then we have
set in frozenzet,

533
00:21:16,334 --> 00:21:19,167
which are mutable
and immutable

534
00:21:19,167 --> 00:21:21,234
simple hash tables,

535
00:21:21,234 --> 00:21:23,334
just collections of stuff.

536
00:21:23,334 --> 00:21:25,367
And then you have the dict,
or dictionary,

537
00:21:25,367 --> 00:21:29,367
which is a map from key
to value by a hash table.

538
00:21:29,367 --> 00:21:31,567
And all containers
have a length,

539
00:21:31,567 --> 00:21:33,100
number of items in them.

540
00:21:33,100 --> 00:21:34,834
You can loop
on each of them.

541
00:21:34,834 --> 00:21:37,901
And you can check if something
is part of the container,

542
00:21:37,901 --> 00:21:39,400
membership testing.

543
00:21:39,400 --> 00:21:41,033
Typically every container

544
00:21:41,033 --> 00:21:42,901
has many, many, many,
many methods.

545
00:21:42,901 --> 00:21:45,000
And in case of sets,
also some operators

546
00:21:45,000 --> 00:21:49,000
'cause you can do union
and intersection of sets.

547
00:21:49,000 --> 00:21:50,501
Sequences in particular

548
00:21:50,501 --> 00:21:52,834
are lists and tuples
as well as strings.

549
00:21:52,834 --> 00:21:55,601
You can multiply
by an integer,

550
00:21:55,601 --> 00:21:58,234
meaning repeat them
a certain number of times.

551
00:21:58,234 --> 00:22:00,300
And you can concatenate.

552
00:22:00,300 --> 00:22:03,234
You can concatenate
two sequences of the same type.

553
00:22:03,234 --> 00:22:06,467
You can index by writing
the index in brackets.

554
00:22:06,467 --> 00:22:08,667
You can slice by writing,

555
00:22:08,667 --> 00:22:11,501
"start, colon, end"

556
00:22:11,501 --> 00:22:15,634
and possibly
a third colon step or stride.

557
00:22:15,634 --> 00:22:20,100
That is, for example,
ciao of 2 is A.

558
00:22:20,100 --> 00:22:21,901
Indexes always start
from zero,

559
00:22:21,901 --> 00:22:23,834
so C, I, A.

560
00:22:23,834 --> 00:22:27,567
Third one instead of two.

561
00:22:27,567 --> 00:22:31,067
Ciao three to one
by minus one.

562
00:22:31,067 --> 00:22:33,567
So you start at the three,
which is the O

563
00:22:33,567 --> 00:22:35,100
and go backwards,

564
00:22:35,100 --> 00:22:37,467
because we've got
the minus on the stride,

565
00:22:37,467 --> 00:22:40,534
until you hit
one excluded.

566
00:22:40,534 --> 00:22:42,767
The end is always excluded.

567
00:22:42,767 --> 00:22:45,300
If you've read
Andrew Koenig's masterpiece

568
00:22:45,300 --> 00:22:47,100
"C Traps and Pitfalls"--

569
00:22:47,100 --> 00:22:48,734
If you haven't,
you should,

570
00:22:48,734 --> 00:22:50,400
whatever language
you're programming in.

571
00:22:50,400 --> 00:22:52,467
And if you have,

572
00:22:52,467 --> 00:22:54,567
you will remember
the chapters he devotes

573
00:22:54,567 --> 00:22:56,601
to explaining why every loop

574
00:22:56,601 --> 00:22:59,300
should be start included
and excluded.

575
00:22:59,300 --> 00:23:04,300
And Python uses
it very widely.

576
00:23:04,300 --> 00:23:06,667
Now, lists
are mutable sequences.

577
00:23:06,667 --> 00:23:07,868
Strings are immutable.

578
00:23:07,868 --> 00:23:10,100
They're built in.

579
00:23:10,100 --> 00:23:11,400
But lists are mutable,

580
00:23:11,400 --> 00:23:15,434
meaning you can assign
to an index or a slice.

581
00:23:15,434 --> 00:23:16,934
Assigning to an indexing

582
00:23:16,934 --> 00:23:19,067
just means
whatever was there before,

583
00:23:19,067 --> 00:23:20,801
now there is another thing.

584
00:23:20,801 --> 00:23:22,133
It's like assigning
to a name.

585
00:23:22,133 --> 00:23:23,601
Assigning to a slice

586
00:23:23,601 --> 00:23:25,801
can make the string longer--

587
00:23:25,801 --> 00:23:27,701
sorry, the list longer
or shorter

588
00:23:27,701 --> 00:23:30,267
because you can assign
to a slice

589
00:23:30,267 --> 00:23:32,167
a longer list
than the slice

590
00:23:32,167 --> 00:23:33,767
or a shorter list
than the slice.

591
00:23:33,767 --> 00:23:38,934
And things will smoothly
change to suit you.

592
00:23:38,934 --> 00:23:41,567
Dictionaries and sets
are not sequences.

593
00:23:41,567 --> 00:23:43,701
There is no intrinsic order.

594
00:23:43,701 --> 00:23:45,601
As I mentioned,
they're hash tables.

595
00:23:45,601 --> 00:23:47,267
So they're in whatever order

596
00:23:47,267 --> 00:23:49,567
is nice for retrieval.

597
00:23:49,567 --> 00:23:52,501
So there is no slicing

598
00:23:52,501 --> 00:23:54,567
because there
is no way to say,

599
00:23:54,567 --> 00:23:56,200
"What's the first
or the second?"

600
00:23:56,200 --> 00:23:57,567
And so on.

601
00:23:57,567 --> 00:23:58,901
You can iterate,

602
00:23:58,901 --> 00:24:00,634
and you will be
given the items

603
00:24:00,634 --> 00:24:03,734
in a random-looking order.

604
00:24:03,734 --> 00:24:06,267
There's a method
to this madness,

605
00:24:06,267 --> 00:24:08,167
but it's the hash function

606
00:24:08,167 --> 00:24:11,067
so it's far from transparent.

607
00:24:11,067 --> 00:24:13,100
More about containers.

608
00:24:13,100 --> 00:24:16,567
Containers have methods
that can be classified

609
00:24:16,567 --> 00:24:21,400
in two general roles--
mutating and non-mutating.

610
00:24:21,400 --> 00:24:24,067
A mutating method
typically does its work

611
00:24:24,067 --> 00:24:26,267
by altering the container,

612
00:24:26,267 --> 00:24:29,033
inserting something,
removing something.

613
00:24:29,033 --> 00:24:30,467
And typically
it returns "none"

614
00:24:30,467 --> 00:24:34,501
because there is no natural
result for that.

615
00:24:34,501 --> 00:24:39,467
For example, the append
method of list,

616
00:24:39,467 --> 00:24:40,968
add one at the end.

617
00:24:40,968 --> 00:24:46,400
The add method of sets
one more item.

618
00:24:46,400 --> 00:24:48,567
The update
method of dictionary

619
00:24:48,567 --> 00:24:51,901
merge another dictionary
into this one.

620
00:24:51,901 --> 00:24:53,467
They will all return "none"

621
00:24:53,467 --> 00:24:58,133
and change the specific object
in which you're calling them.

622
00:24:58,133 --> 00:25:01,534
A few mutating methods
have a natural result

623
00:25:01,534 --> 00:25:03,033
and therefore return it.

624
00:25:03,033 --> 00:25:05,200
For example, "pop" removes
typically the last,

625
00:25:05,200 --> 00:25:07,734
but you can tell it which one,

626
00:25:07,734 --> 00:25:12,267
element of a list
and gives it back to you.

627
00:25:12,267 --> 00:25:16,267
"Pop" in a dictionary
removes an arbitrary item

628
00:25:16,267 --> 00:25:18,501
and gives it back to you.

629
00:25:18,501 --> 00:25:20,701
Setdefault on dictionary,
that's a bit more complicated.

630
00:25:20,701 --> 00:25:22,267
We'll see an example later.

631
00:25:22,267 --> 00:25:24,300
But again,
it has a return.

632
00:25:24,300 --> 00:25:26,033
And then there's
non-mutating methods

633
00:25:26,033 --> 00:25:28,734
that, like, necessarily
return a result

634
00:25:28,734 --> 00:25:31,033
because they don't
do any changes.

635
00:25:31,033 --> 00:25:33,200
Um, sets have a variant

636
00:25:33,200 --> 00:25:35,567
which only supports
the non-mutating method,

637
00:25:35,567 --> 00:25:37,601
the frozenset.

638
00:25:37,601 --> 00:25:39,234
Dictionary doesn't,

639
00:25:39,234 --> 00:25:42,300
but it has another variant
in module collections,

640
00:25:42,300 --> 00:25:44,167
which we'll see
in examples later,

641
00:25:44,167 --> 00:25:46,467
which has a default value.

642
00:25:46,467 --> 00:25:49,367
Other important containers
in the collections module

643
00:25:49,367 --> 00:25:50,968
include
the doubled ended queue,

644
00:25:50,968 --> 00:25:54,000
which basically
is like a list

645
00:25:54,000 --> 00:25:55,834
but internally
organized differently

646
00:25:55,834 --> 00:25:59,868
so it's just as fast
to access from either end

647
00:25:59,868 --> 00:26:02,567
and rotate.

648
00:26:02,567 --> 00:26:05,100
We don't have
a priority queue

649
00:26:05,100 --> 00:26:06,567
or heap type.

650
00:26:06,567 --> 00:26:08,067
We only have functions

651
00:26:08,067 --> 00:26:11,601
that treat a list
as a priority queue.

652
00:26:11,601 --> 00:26:13,901
Not sure if you're
familiar with heaps,

653
00:26:13,901 --> 00:26:18,133
but suppose we,
for some reason, like we're--

654
00:26:18,133 --> 00:26:20,067
For fanatic Java programmers
and things,

655
00:26:20,067 --> 00:26:22,100
everything should be wrapped
in a class.

656
00:26:22,100 --> 00:26:24,834
We want to make
a priority type.

657
00:26:24,834 --> 00:26:26,133
How do we do that?

658
00:26:26,133 --> 00:26:28,000
Well, rushing far ahead
to things we'll see

659
00:26:28,000 --> 00:26:31,133
in the second half,
such as classes and methods

660
00:26:31,133 --> 00:26:32,400
and modules.

661
00:26:32,400 --> 00:26:35,100
Well, first of all
we import the "heapq" module,

662
00:26:35,100 --> 00:26:37,167
which gives us
all the functions we need.

663
00:26:37,167 --> 00:26:40,934
And then we basically
write a class called "heap"

664
00:26:40,934 --> 00:26:43,133
and everything get explicitly
from object

665
00:26:43,133 --> 00:26:44,834
with all the methods
we want.

666
00:26:44,834 --> 00:26:47,167
Some of them start and end
with double underscores.

667
00:26:47,167 --> 00:26:49,000
Those are special methods

668
00:26:49,000 --> 00:26:51,367
which have very special roles.

669
00:26:51,367 --> 00:26:53,634
Other just identifiers.

670
00:26:53,634 --> 00:26:56,434
You will notice "self"

671
00:26:56,434 --> 00:27:00,868
as the first parameter
of each and every method.

672
00:27:00,868 --> 00:27:02,801
That means
that the object itself

673
00:27:02,801 --> 00:27:04,300
in which the method
has been called.

674
00:27:04,300 --> 00:27:06,167
Some are others.

675
00:27:06,167 --> 00:27:07,868
So, for example,

676
00:27:07,868 --> 00:27:10,901
we first thing we need to do
is get some content,

677
00:27:10,901 --> 00:27:13,601
make it into a list,
assign it as a variable,

678
00:27:13,601 --> 00:27:17,000
and make sure it is a heap.

679
00:27:17,000 --> 00:27:18,934
To make sure that a list
is a heap,

680
00:27:18,934 --> 00:27:20,801
"heapq.heapify"

681
00:27:20,801 --> 00:27:23,868
basically does whatever
permutation is needed.

682
00:27:23,868 --> 00:27:28,234
And then this makes available
the "push" and "pop" function,

683
00:27:28,234 --> 00:27:30,167
which keep the heap property,

684
00:27:30,167 --> 00:27:31,968
the priority heap property,

685
00:27:31,968 --> 00:27:33,767
adding and removing an item.

686
00:27:33,767 --> 00:27:35,901
And the replace,

687
00:27:35,901 --> 00:27:38,167
which does
heap push and a pop.

688
00:27:38,167 --> 00:27:39,601
So it takes the previous stop

689
00:27:39,601 --> 00:27:41,701
and puts something else
in its place,

690
00:27:41,701 --> 00:27:43,033
maintaining the heap property.

691
00:27:43,033 --> 00:27:45,367
And this basically
would be the hard work.

692
00:27:45,367 --> 00:27:47,667
And we just need to call
the functions

693
00:27:47,667 --> 00:27:49,367
"heappush," "heappop,"
and "heapreplace,"

694
00:27:49,367 --> 00:27:52,434
provided by
the "heapq" module.

695
00:27:52,434 --> 00:27:54,634
And then
we have some special--

696
00:27:54,634 --> 00:27:56,834
Okay, "_init_"

697
00:27:56,834 --> 00:27:58,567
is the initializer.

698
00:27:58,567 --> 00:28:01,767
So what's the content,
what's the initial content

699
00:28:01,767 --> 00:28:03,567
of this thing.

700
00:28:03,567 --> 00:28:06,767
"_len_" is how do I
compute the length

701
00:28:06,767 --> 00:28:08,267
of this container?

702
00:28:08,267 --> 00:28:09,834
In disguise, I simply--

703
00:28:09,834 --> 00:28:12,467
It's the same as the length
of the list it's using.

704
00:28:12,467 --> 00:28:14,934
How do I iterate
in this containing?

705
00:28:14,934 --> 00:28:17,367
Same as you iterate
on the list it's using.

706
00:28:17,367 --> 00:28:19,534
How do I represent
this container?

707
00:28:19,534 --> 00:28:21,501
In this case,
I'm representing it

708
00:28:21,501 --> 00:28:24,968
as "heap, open paren,
its contents."

709
00:28:24,968 --> 00:28:27,133
So representation
of its contents.

710
00:28:27,133 --> 00:28:29,400
So I could add many more
special methods,

711
00:28:29,400 --> 00:28:33,801
but basically all I'm doing
is delegating properly.

712
00:28:33,801 --> 00:28:35,934
The special method
I'm calling

713
00:28:35,934 --> 00:28:40,200
has underscores
before and behind.

714
00:28:40,200 --> 00:28:42,334
And I'm delegating
appropriately

715
00:28:42,334 --> 00:28:44,033
to a built-in function

716
00:28:44,033 --> 00:28:46,767
that will internally invoke
the special method

717
00:28:46,767 --> 00:28:49,801
on this other list.

718
00:28:49,801 --> 00:28:52,801
I also have truthiness.

719
00:28:52,801 --> 00:28:56,100
Comparisons, tests,
and truth-like value.

720
00:28:56,100 --> 00:28:58,367
I can do
all the normal comparisons.

721
00:28:58,367 --> 00:29:01,334
You will have to be away
of the distinction

722
00:29:01,334 --> 00:29:04,133
between equality
and identity.

723
00:29:04,133 --> 00:29:06,634
It's spelled "two equals"
versus "is"

724
00:29:06,634 --> 00:29:09,834
as opposed to three equals
as in other languages.

725
00:29:09,834 --> 00:29:11,667
Orders of course.

726
00:29:11,667 --> 00:29:15,367
Membership is also considered
an elementary comparison.

727
00:29:15,367 --> 00:29:17,367
And you can chain comparisons.

728
00:29:17,367 --> 00:29:19,167
That's pretty special
to Python.

729
00:29:19,167 --> 00:29:23,868
So the expression
"3 < = X < 9"

730
00:29:23,868 --> 00:29:26,367
means exactly
what it should obviously mean.

731
00:29:26,367 --> 00:29:28,501
X is at the same time

732
00:29:28,501 --> 00:29:31,000
greater or equal three
and less than nine.

733
00:29:31,000 --> 00:29:34,000
It goes left to right.

734
00:29:34,000 --> 00:29:36,400
So like in Java script,

735
00:29:36,400 --> 00:29:38,133
the falsy concept

736
00:29:38,133 --> 00:29:39,934
applies to any number
that's zero,

737
00:29:39,934 --> 00:29:43,367
an empty string, none,
and empty container,

738
00:29:43,367 --> 00:29:45,467
and the special value False

739
00:29:45,467 --> 00:29:47,267
with an uppercase F here,

740
00:29:47,267 --> 00:29:51,167
which is the same thing
as the bool of zero.

741
00:29:51,167 --> 00:29:52,634
And everything else is true.

742
00:29:52,634 --> 00:29:54,367
That's a very optimistic
view of life.

743
00:29:54,367 --> 00:29:55,968
It's mostly everything true

744
00:29:55,968 --> 00:29:58,667
except some very few
special objects

745
00:29:58,667 --> 00:30:01,067
specifically identified
as false.

746
00:30:01,067 --> 00:30:03,100
And then
there's some operator

747
00:30:03,100 --> 00:30:04,801
like "and," "or," "not."

748
00:30:04,801 --> 00:30:06,167
We all spell them out.

749
00:30:06,167 --> 00:30:08,334
Remember, we don't
really like punctuation.

750
00:30:08,334 --> 00:30:12,100
So what you would spell
as "&&" in C,

751
00:30:12,100 --> 00:30:15,400
you'll spell "A-N-D"
in Python.

752
00:30:15,400 --> 00:30:17,234
But the semantics
are the same.

753
00:30:17,234 --> 00:30:20,467
And then if you want to do
on more than two at a time,

754
00:30:20,467 --> 00:30:22,334
you can use "any" and "all"

755
00:30:22,334 --> 00:30:24,834
to return
a Boolean value.

756
00:30:24,834 --> 00:30:27,400
So we'll see some examples.

757
00:30:27,400 --> 00:30:29,901
Okay, exceptions,
kind of like in Java.

758
00:30:29,901 --> 00:30:34,133
Accept that some anomalies
that are not really errors

759
00:30:34,133 --> 00:30:36,367
should also
raise an exception.

760
00:30:36,367 --> 00:30:39,334
And you can also raise them
explicitly with "raise."

761
00:30:39,334 --> 00:30:41,434
When you raise an exception,

762
00:30:41,434 --> 00:30:43,267
assuming nothing
is catching it,

763
00:30:43,267 --> 00:30:45,267
it keeps going
along the call stack

764
00:30:45,267 --> 00:30:47,300
killing functions
as it goes.

765
00:30:47,300 --> 00:30:50,901
It's kind of scary,
horror, movie-like image.

766
00:30:50,901 --> 00:30:52,234
And if it goes all the way,

767
00:30:52,234 --> 00:30:57,868
the whole program,
the whole world gets destroyed.

768
00:30:57,868 --> 00:30:59,934
Um, "try/except,"

769
00:30:59,934 --> 00:31:02,067
as opposed to "try/catch"
as in other languages,

770
00:31:02,067 --> 00:31:06,701
is how you make sure
that anything happening,

771
00:31:06,701 --> 00:31:09,667
any exception raised
in the try clause,

772
00:31:09,667 --> 00:31:15,167
is handled
in the proper way.

773
00:31:15,167 --> 00:31:17,267
"Try/final" is exactly
like in Java,

774
00:31:17,267 --> 00:31:19,501
but is whatever exception

775
00:31:19,501 --> 00:31:21,934
or non-exception
is happening in the try

776
00:31:21,934 --> 00:31:25,234
make sure that at the very end
you do this and that.

777
00:31:25,234 --> 00:31:28,200
And then we have
the new "with" statement.

778
00:31:28,200 --> 00:31:30,367
I'm particularly
fond of it.

779
00:31:30,367 --> 00:31:32,601
It implements an idiom

780
00:31:32,601 --> 00:31:35,567
which is very familiar
to C++ programmers--

781
00:31:35,567 --> 00:31:41,200
resource acquisition
is initialization,

782
00:31:41,200 --> 00:31:43,901
which is misspelled here.

783
00:31:43,901 --> 00:31:46,300
It's R-A-I-I.

784
00:31:46,300 --> 00:31:48,767
Or "as initialization"
instead of "is"

785
00:31:48,767 --> 00:31:50,400
works just as well

786
00:31:50,400 --> 00:31:53,067
as saves me from admitting
to a misspelling.

787
00:31:53,067 --> 00:31:58,167
So since it makes with,
W-I-T-H, into a keyword,

788
00:31:58,167 --> 00:32:01,901
to make sure we don't break
compatibility with the past,

789
00:32:01,901 --> 00:32:04,667
it's only enabled it
at the very top of the module

790
00:32:04,667 --> 00:32:08,901
you start with "from future
import with statement."

791
00:32:08,901 --> 00:32:13,367
And future has underscores
below before and after

792
00:32:13,367 --> 00:32:18,667
just to make sure it's
obviously a very special case.

793
00:32:18,667 --> 00:32:21,033
So if you do that,

794
00:32:21,033 --> 00:32:25,801
you can, um, make sure

795
00:32:25,801 --> 00:32:28,434
that something is initialized

796
00:32:28,434 --> 00:32:30,701
at the start of a block

797
00:32:30,701 --> 00:32:33,601
and properly finalized
when that block's exit.

798
00:32:33,601 --> 00:32:35,367
No matter how it exits.

799
00:32:35,367 --> 00:32:38,033
So it's syntactically
very elegant

800
00:32:38,033 --> 00:32:43,367
but semantically just like
a try/finally.

801
00:32:43,367 --> 00:32:46,234
The nice thing
is that the finalizer

802
00:32:46,234 --> 00:32:49,534
is something that you can code
once and for all.

803
00:32:49,534 --> 00:32:52,634
In C++ you do it
as a destructor.

804
00:32:52,634 --> 00:32:57,133
In Python we want
to distinguish two cases

805
00:32:57,133 --> 00:33:00,067
or let it distinguish
two cases.

806
00:33:00,067 --> 00:33:02,267
Is the object being finalized

807
00:33:02,267 --> 00:33:04,734
after a normal termination?

808
00:33:04,734 --> 00:33:08,934
Or is it being finalized
after an exception propagates?

809
00:33:08,934 --> 00:33:10,767
C++ doesn't
let you distinguish.

810
00:33:10,767 --> 00:33:12,734
A destructor is a destructor
is a destructor.

811
00:33:12,734 --> 00:33:15,467
You have to resort
to horrid tricks.

812
00:33:15,467 --> 00:33:18,133
But it's obvious that
you do want to distinguish.

813
00:33:18,133 --> 00:33:20,968
Consider a transaction
in a database.

814
00:33:20,968 --> 00:33:22,634
Well, you want to know
whether the transaction

815
00:33:22,634 --> 00:33:24,901
is done correctly
or incorrectly,

816
00:33:24,901 --> 00:33:28,067
'cause in one case
you do end work and commit

817
00:33:28,067 --> 00:33:30,434
and in the other one
you want to roll back, okay?

818
00:33:30,434 --> 00:33:33,400
You can't do that
with RAAI in C++,

819
00:33:33,400 --> 00:33:34,567
but you can in Python

820
00:33:34,567 --> 00:33:37,467
because the exit special method

821
00:33:37,467 --> 00:33:40,133
gets stalled whether
an exception has occurred.

822
00:33:40,133 --> 00:33:44,534
So let me give some examples.

823
00:33:44,534 --> 00:33:46,868
This is the most simple one.

824
00:33:46,868 --> 00:33:51,000
With open some file
as F.

825
00:33:51,000 --> 00:33:53,067
Use F as you will.

826
00:33:53,067 --> 00:33:54,868
In this case,
I'm looping over the file,

827
00:33:54,868 --> 00:33:56,300
so I'm getting a line
at a time

828
00:33:56,300 --> 00:33:58,567
and printing
the third character,

829
00:33:58,567 --> 00:34:00,534
actually the fourth one.

830
00:34:00,534 --> 00:34:03,868
Suppose this either
ends normally

831
00:34:03,868 --> 00:34:05,801
because the file is done

832
00:34:05,801 --> 00:34:07,767
or it raises an exception

833
00:34:07,767 --> 00:34:09,601
because there's a line
that's too short.

834
00:34:09,601 --> 00:34:12,934
So a line of three
is out of bounds indexing.

835
00:34:12,934 --> 00:34:17,334
No matter what,
F gets closed

836
00:34:17,334 --> 00:34:19,834
at the end of this block.

837
00:34:19,834 --> 00:34:21,167
Similarly,

838
00:34:21,167 --> 00:34:24,133
say you have a lock somewhere
in a threading system,

839
00:34:24,133 --> 00:34:26,868
"with the lock do something"

840
00:34:26,868 --> 00:34:28,801
means the lock gets acquired

841
00:34:28,801 --> 00:34:31,734
before the critical section
is entered

842
00:34:31,734 --> 00:34:34,534
and will always get released
as soon as this is done

843
00:34:34,534 --> 00:34:37,968
no matter whether
it's smooth or not.

844
00:34:37,968 --> 00:34:39,801
And this one--

845
00:34:39,801 --> 00:34:42,601
The "contextlib"
is a method that is a module

846
00:34:42,601 --> 00:34:45,100
from the central library
that gives you all kind of tools

847
00:34:45,100 --> 00:34:46,801
to do these kind of things.

848
00:34:46,801 --> 00:34:48,534
But it's basically--

849
00:34:48,534 --> 00:34:50,934
"Closing" makes sure

850
00:34:50,934 --> 00:34:54,634
that the close is called
at the end of the block.

851
00:34:54,634 --> 00:34:57,000
So you do a connection
to a database

852
00:34:57,000 --> 00:34:58,501
and open a cursor.

853
00:34:58,501 --> 00:35:00,067
And make sure
the cursor is closed

854
00:35:00,067 --> 00:35:03,601
and the database connection
is closed.

855
00:35:03,601 --> 00:35:06,767
So one peculiarity
of Python

856
00:35:06,767 --> 00:35:10,067
is we love to have
a simple statement,

857
00:35:10,067 --> 00:35:11,701
a high level statement,

858
00:35:11,701 --> 00:35:14,334
explaining terms
of lower level ones.

859
00:35:14,334 --> 00:35:16,801
So this is what "for" means.

860
00:35:16,801 --> 00:35:19,467
It means make
an iterator and loop,

861
00:35:19,467 --> 00:35:21,834
calling the next method
of the iterator

862
00:35:21,834 --> 00:35:24,400
until a stop iteration
exception,

863
00:35:24,400 --> 00:35:26,701
in this case terminate.

864
00:35:26,701 --> 00:35:30,100
We also have syntax
to use this as expression,

865
00:35:30,100 --> 00:35:32,934
as a simple expression
like that.

866
00:35:32,934 --> 00:35:35,434
A certain expression
for everything

867
00:35:35,434 --> 00:35:38,067
in a certain iterable
with optional clauses.

868
00:35:38,067 --> 00:35:39,767
Or if you use brackets,

869
00:35:39,767 --> 00:35:41,300
then you make a list
out of it,

870
00:35:41,300 --> 00:35:43,667
and it's called
"the list comprehension."

871
00:35:43,667 --> 00:35:48,534
And let me give some example
of using general expressions

872
00:35:48,534 --> 00:35:51,067
with accumulators,

873
00:35:51,067 --> 00:35:53,534
that is function that can
take any number of items

874
00:35:53,534 --> 00:35:56,000
and basically
process them all.

875
00:35:56,000 --> 00:35:58,167
One of the simplest
is "sum".

876
00:35:58,167 --> 00:36:00,968
Give sum any collection
of numbers,

877
00:36:00,968 --> 00:36:03,767
it will just sum them all
and return the sum.

878
00:36:03,767 --> 00:36:06,367
So how do we know
how many items

879
00:36:06,367 --> 00:36:08,634
say of any generic
type of class?

880
00:36:08,634 --> 00:36:10,434
It may not support
the length.

881
00:36:10,434 --> 00:36:13,734
Well, we sum one
for everything in the item.

882
00:36:13,734 --> 00:36:15,267
So we basically count.

883
00:36:15,267 --> 00:36:16,934
It's as simple as that.

884
00:36:16,934 --> 00:36:20,767
And then we can call it
on the generic expression.

885
00:36:20,767 --> 00:36:21,934
See?

886
00:36:21,934 --> 00:36:24,868
Every X in the range
from zero--

887
00:36:24,868 --> 00:36:26,501
0 included
from 99 excluded,

888
00:36:26,501 --> 00:36:27,734
which equal--

889
00:36:27,734 --> 00:36:31,434
which module five
equals itself, module seven.

890
00:36:31,434 --> 00:36:32,767
Very simple.

891
00:36:32,767 --> 00:36:34,434
Other accumulators,

892
00:36:34,434 --> 00:36:36,300
"any," I mentioned it before.

893
00:36:36,300 --> 00:36:38,767
Is any X greater than five

894
00:36:38,767 --> 00:36:40,501
among the Xs?

895
00:36:40,501 --> 00:36:43,133
See how natural this is.

896
00:36:43,133 --> 00:36:48,133
Our all(X > Y> Z)
for X, Y, Z.

897
00:36:48,133 --> 00:36:52,400
"Zip" is for parallel iteration
along containers.

898
00:36:52,400 --> 00:36:53,801
It actually makes a list.

899
00:36:53,801 --> 00:36:57,234
So you can use
the itertools,

900
00:36:57,234 --> 00:36:59,968
which gives you
an iterator zip, "izip."

901
00:36:59,968 --> 00:37:02,567
And in this case,
it must be the same context.

902
00:37:02,567 --> 00:37:04,667
Other example, "max."

903
00:37:04,667 --> 00:37:08,467
What's the highest index
at which

904
00:37:08,467 --> 00:37:10,234
there is a positive number?

905
00:37:10,234 --> 00:37:12,434
"Enumerate" given a sequence,

906
00:37:12,434 --> 00:37:15,567
gives you the index, item,
index, item, index, item.

907
00:37:15,567 --> 00:37:17,334
So you loop on index
and item

908
00:37:17,334 --> 00:37:19,567
and take the highest I

909
00:37:19,567 --> 00:37:25,067
for which X is greater
than zero.

910
00:37:25,067 --> 00:37:31,133
And this takes us
to halfway point.

911
00:37:31,133 --> 00:37:34,934
So we do have
three minutes and 51 seconds

912
00:37:34,934 --> 00:37:37,033
before formal break.

913
00:37:37,033 --> 00:37:39,300
So if there's any questions

914
00:37:39,300 --> 00:37:41,601
that you'd rather ask now

915
00:37:41,601 --> 00:37:43,133
rather than an hour from now,

916
00:37:43,133 --> 00:37:48,067
please go to the mike
and we'll do that.

917
00:37:48,067 --> 00:37:50,334
Well, if there's
no question,

918
00:37:50,334 --> 00:37:52,601
I can take a short break.

919
00:37:52,601 --> 00:37:54,534
[applause]

