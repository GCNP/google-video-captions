1
00:00:00,667 --> 00:00:01,801
Lee: Hi, I'm Jacob Lee.

2
00:00:01,801 --> 00:00:05,534
I'm with the Google Code Open
Source Project hosting team,

3
00:00:05,534 --> 00:00:07,501
and I'm going to be talking

4
00:00:07,501 --> 00:00:10,334
about the Mercurial distributed
version control system

5
00:00:10,334 --> 00:00:15,434
and how we got it to run
on Google infrastructure.

6
00:00:15,434 --> 00:00:17,467
A point of administravia,

7
00:00:17,467 --> 00:00:20,767
this is sort of a--we are
officially launching this

8
00:00:20,767 --> 00:00:22,334
to the public today.

9
00:00:22,334 --> 00:00:23,667
Actually,
as of several hours ago,

10
00:00:23,667 --> 00:00:25,000
so you can go create projects,

11
00:00:25,000 --> 00:00:27,234
but after my talk.

12
00:00:27,234 --> 00:00:31,901
And if you're tempted
to vanish, say, during Q&A,

13
00:00:31,901 --> 00:00:34,534
I would at least lurk
in the back until the end,

14
00:00:34,534 --> 00:00:35,901
because we have T-shirts.

15
00:00:35,901 --> 00:00:40,667
So if you want one,
I'd stick around.

16
00:00:40,667 --> 00:00:42,000
That's a great sound.

17
00:00:42,000 --> 00:00:46,133
All right, so I'm going
to first talk a little bit

18
00:00:46,133 --> 00:00:48,167
about project hosting,
and then a lot

19
00:00:48,167 --> 00:00:51,634
about how Mercurial
is implemented,

20
00:00:51,634 --> 00:00:54,300
and then about
our implementation.

21
00:00:54,300 --> 00:00:58,601
So let's first time warp
way back to the distant past

22
00:00:58,601 --> 00:01:02,968
where we still maintained source
code in giant card catalogs.

23
00:01:02,968 --> 00:01:08,567
This is July 2006
at OSCON,

24
00:01:08,567 --> 00:01:12,200
three years ago
when we first announced

25
00:01:12,200 --> 00:01:14,567
Google code project hosting
to the public.

26
00:01:14,567 --> 00:01:21,300
At that time, Subversion 1.0
was about two years old.

27
00:01:21,300 --> 00:01:24,334
One of the earliest distributed
version control systems,

28
00:01:24,334 --> 00:01:27,067
Monotone,
was a year older than that.

29
00:01:27,067 --> 00:01:31,067
Git and Mercurial were,
more or less, sort of brand-new.

30
00:01:31,067 --> 00:01:36,267
CVS was widely used, and I guess
now we're dating ourselves well,

31
00:01:36,267 --> 00:01:39,067
and maybe several months
before that, back in February,

32
00:01:39,067 --> 00:01:41,701
Sourceforge had just announced
Subversion support

33
00:01:41,701 --> 00:01:45,434
to add to its offering
of CVS.

34
00:01:45,434 --> 00:01:47,834
And we came
into that environment

35
00:01:47,834 --> 00:01:52,667
with the goal of using
our unique assets,

36
00:01:52,667 --> 00:01:55,167
which is Google infrastructure,

37
00:01:55,167 --> 00:02:00,467
to provide rock-solid
and scalable Subversion hosting,

38
00:02:00,467 --> 00:02:03,834
and thereby provide a platform
for collaboration

39
00:02:03,834 --> 00:02:05,901
on open source projects.

40
00:02:05,901 --> 00:02:12,133
And nowadays, well, there's
lots of options out there

41
00:02:12,133 --> 00:02:15,434
for new and existing
open source projects.

42
00:02:15,434 --> 00:02:21,601
Google Code now has 200,000
or so, give or take, projects

43
00:02:21,601 --> 00:02:23,701
and several million
unique visitors per day.

44
00:02:23,701 --> 00:02:26,100
Sourceforge has expanded
their offerings.

45
00:02:26,100 --> 00:02:27,801
They have shell accounts

46
00:02:27,801 --> 00:02:30,234
and several distributed version
control systems

47
00:02:30,234 --> 00:02:32,400
and, you know,
hosted Trac instances

48
00:02:32,400 --> 00:02:33,801
and cool things like that.

49
00:02:33,801 --> 00:02:37,000
And there are new players
like GitHub and Bitbucket,

50
00:02:37,000 --> 00:02:38,367
which are specialized

51
00:02:38,367 --> 00:02:39,868
for a particular
version control system

52
00:02:39,868 --> 00:02:42,501
and provide a well-integrated
social experience

53
00:02:42,501 --> 00:02:45,567
on top of that,
and that's all really great.

54
00:02:45,567 --> 00:02:48,968
And we're happy
that there are so many choices

55
00:02:48,968 --> 00:02:50,400
for projects out there.

56
00:02:50,400 --> 00:02:53,801
But we still think
that Google is well-positioned

57
00:02:53,801 --> 00:03:00,634
to support and support well
these newly prominent features

58
00:03:00,634 --> 00:03:02,501
of distributed version control.

59
00:03:02,501 --> 00:03:07,167
So with that, about a month
ago, we started offering

60
00:03:07,167 --> 00:03:11,334
Mercurial support to about
50 or so trusted testers--

61
00:03:11,334 --> 00:03:16,334
brave volunteers--and now
it is open to the public.

62
00:03:16,334 --> 00:03:18,467
That's just
a quick screenshot.

63
00:03:18,467 --> 00:03:20,767
So why did we choose Mercurial?

64
00:03:20,767 --> 00:03:24,534
This was the source
of many great discussions.

65
00:03:24,534 --> 00:03:26,701
It was sort of entertaining

66
00:03:26,701 --> 00:03:29,000
if you like angry people.

67
00:03:29,000 --> 00:03:34,801
So, you know, why would we
choose Mercurial and not Git

68
00:03:34,801 --> 00:03:37,601
or Bazaar
or many of the other systems

69
00:03:37,601 --> 00:03:40,434
shown on the previous slides?

70
00:03:40,434 --> 00:03:42,400
Any individual might have
personal reasons

71
00:03:42,400 --> 00:03:44,100
to like one or the other.

72
00:03:44,100 --> 00:03:45,868
If you were
to grossly over-generalize,

73
00:03:45,868 --> 00:03:49,100
you might like Mercurial's
simple, orthogonal workflow.

74
00:03:49,100 --> 00:03:53,300
You might like Git's ability
to do almost anything.

75
00:03:53,300 --> 00:03:57,801
Our decision was primarily
technical and sort of unique

76
00:03:57,801 --> 00:03:59,167
to our situation.

77
00:03:59,167 --> 00:04:03,434
Mercurial has a really fantastic
wire protocol

78
00:04:03,434 --> 00:04:06,167
that is over HTTP.

79
00:04:06,167 --> 00:04:09,100
And that
is what Google is built on.

80
00:04:09,100 --> 00:04:11,167
Almost everything we do is HTTP

81
00:04:11,167 --> 00:04:12,868
with a handful
of exceptions,

82
00:04:12,868 --> 00:04:15,868
like Google Talk,
which is Jabber/XMPP.

83
00:04:15,868 --> 00:04:21,834
And that's something that was
sort of unique to Mercurial

84
00:04:21,834 --> 00:04:26,534
that makes it a very good fit
for our infrastructure.

85
00:04:26,534 --> 00:04:30,300
That is the only stupid keynote
transition I am going to use

86
00:04:30,300 --> 00:04:31,901
in this whole presentation,
but I had to,

87
00:04:31,901 --> 00:04:33,334
'cause it's a flamewar.

88
00:04:33,334 --> 00:04:35,801
And it's the point
where people were starting

89
00:04:35,801 --> 00:04:38,067
to evade our +1 filters

90
00:04:38,067 --> 00:04:40,767
that we decided to make
that issue read-only.

91
00:04:40,767 --> 00:04:42,200
Right.
Okay.

92
00:04:42,200 --> 00:04:46,701
So if you're not familiar
with--well, first of all,

93
00:04:46,701 --> 00:04:50,501
how many people here use on,
say, a day-to-day

94
00:04:50,501 --> 00:04:53,801
or at least weekly basis,
version control?

95
00:04:53,801 --> 00:04:55,701
That's good.
That's really good.

96
00:04:55,701 --> 00:04:59,334
If your hand didn't go up,
you should consider.

97
00:04:59,334 --> 00:05:03,067
It is an investment that pays
itself in spades in time.

98
00:05:03,067 --> 00:05:07,701
So how many people
use distributed version control?

99
00:05:07,701 --> 00:05:08,934
Nice. Nice.

100
00:05:08,934 --> 00:05:11,934
All right, how many people
use Mercurial?

101
00:05:11,934 --> 00:05:16,300
Pretty good.
Git?

102
00:05:16,300 --> 00:05:18,968
All right. Fight?
All right. Okay.

103
00:05:18,968 --> 00:05:21,167
I stole that joke
from Fitz and Ben, thanks.

104
00:05:21,167 --> 00:05:22,467
All right?

105
00:05:22,467 --> 00:05:25,167
So if you're not familiar,
the basic workflow

106
00:05:25,167 --> 00:05:28,100
is you've got your, instead of
being on some server somewhere,

107
00:05:28,100 --> 00:05:30,367
you just have your repository
sitting on disk.

108
00:05:30,367 --> 00:05:33,601
You initialize it,
you hack a bunch,

109
00:05:33,601 --> 00:05:37,200
and then, when you feel you have
a coherent change that--

110
00:05:37,200 --> 00:05:39,734
say, like a single patch
that you would mail out--

111
00:05:39,734 --> 00:05:40,868
then you just commit that,

112
00:05:40,868 --> 00:05:42,434
hack some more,
and commit that.

113
00:05:42,434 --> 00:05:43,601
And you keep doing that,

114
00:05:43,601 --> 00:05:47,601
and you build up your list
of changes.

115
00:05:47,601 --> 00:05:50,467
And when you feel that
you have something to share--

116
00:05:50,467 --> 00:05:53,367
which, hopefully, if you
attended Ben and Fitz's talk,

117
00:05:53,367 --> 00:05:55,400
is relatively early--

118
00:05:55,400 --> 00:05:59,100
then you push it out
to some public URL.

119
00:05:59,100 --> 00:06:02,067
And then some other random
person can come and clone it,

120
00:06:02,067 --> 00:06:04,467
and they get a copy
of your repository

121
00:06:04,467 --> 00:06:06,567
with complete history
locally on their disk.

122
00:06:06,567 --> 00:06:09,467
And they hack a bunch, and
they can do their own commits.

123
00:06:09,467 --> 00:06:11,767
And they have something
to share back to you,

124
00:06:11,767 --> 00:06:14,133
they push to their server.

125
00:06:14,133 --> 00:06:16,934
And their changes
are in red there.

126
00:06:16,934 --> 00:06:19,367
And then, meanwhile,
you've done some more hacking,

127
00:06:19,367 --> 00:06:20,801
and then at some point,
you decide,

128
00:06:20,801 --> 00:06:23,501
"Oh, hey, so-and-so just
emailed me with a cool feature.

129
00:06:23,501 --> 00:06:25,667
I'll merge it back in."

130
00:06:25,667 --> 00:06:28,334
So you get it
from their repository,

131
00:06:28,334 --> 00:06:31,901
and now all of a sudden,
you have--at the front

132
00:06:31,901 --> 00:06:34,000
of your repository,
you have a change

133
00:06:34,000 --> 00:06:35,601
and they have a change.

134
00:06:35,601 --> 00:06:37,234
And then you merge them in,

135
00:06:37,234 --> 00:06:39,534
and hopefully
there are no conflicts,

136
00:06:39,534 --> 00:06:44,701
and then you have the tip
of your repository,

137
00:06:44,701 --> 00:06:46,734
the single front point
of history.

138
00:06:46,734 --> 00:06:51,968
And merging is something
that is really scary,

139
00:06:51,968 --> 00:06:54,501
historically at least.

140
00:06:54,501 --> 00:06:59,000
You just don't know
what crazy state

141
00:06:59,000 --> 00:07:01,868
the code will be in
when you are done.

142
00:07:01,868 --> 00:07:04,767
That used to be the case,
and one advantage

143
00:07:04,767 --> 00:07:07,901
of distributed version control
is that this is something

144
00:07:07,901 --> 00:07:09,133
that happens all the time--

145
00:07:09,133 --> 00:07:10,901
pretty much anytime
you integrate a change

146
00:07:10,901 --> 00:07:13,567
that someone else did
simultaneously with you--

147
00:07:13,567 --> 00:07:17,601
and it's relatively
pain-free, so...

148
00:07:17,601 --> 00:07:20,400
The other advantages
is everyone--

149
00:07:20,400 --> 00:07:22,801
this person who submitted
the change doesn't have to be

150
00:07:22,801 --> 00:07:24,934
a core contributor
to be able to use

151
00:07:24,934 --> 00:07:26,501
the same tools that I do,

152
00:07:26,501 --> 00:07:28,601
and have their own...

153
00:07:28,601 --> 00:07:30,801
to keep track of history
and so forth.

154
00:07:30,801 --> 00:07:32,534
And you can do this--

155
00:07:32,534 --> 00:07:35,000
So these two repositories
can be totally equal,

156
00:07:35,000 --> 00:07:37,267
or your social structure
might be set up

157
00:07:37,267 --> 00:07:39,300
so that one repository's
considered central.

158
00:07:39,300 --> 00:07:41,267
You might have several
central repositories,

159
00:07:41,267 --> 00:07:43,334
some more bleeding edge
than others.

160
00:07:43,334 --> 00:07:47,167
But you're not constrained
by technical limitations

161
00:07:47,167 --> 00:07:51,334
for how you choose to structure
your repositories.

162
00:07:51,334 --> 00:07:52,767
And if you've tried
to do things

163
00:07:52,767 --> 00:07:55,067
like sync from one repository
to another in Subversion,

164
00:07:55,067 --> 00:07:56,267
it's sort of a pain.

165
00:07:56,267 --> 00:07:59,400
So this solves
that problem well too.

166
00:07:59,400 --> 00:08:02,234
So moving on to:
How does Mercurial

167
00:08:02,234 --> 00:08:03,734
actually implement this?

168
00:08:03,734 --> 00:08:07,968
So the first thing to note
is that this repository here

169
00:08:07,968 --> 00:08:11,100
is not a linear list
of changes.

170
00:08:11,100 --> 00:08:12,601
It's a graph.

171
00:08:12,601 --> 00:08:16,133
Specifically it's a directed--
a cyclic graph.

172
00:08:16,133 --> 00:08:18,934
You don't--
I mean, internally, Mercurial--

173
00:08:18,934 --> 00:08:20,634
Well, Mercurial
might present to you

174
00:08:20,634 --> 00:08:23,667
a numbered list of changes,
but those numbers

175
00:08:23,667 --> 00:08:25,667
are totally specific
to your repository.

176
00:08:25,667 --> 00:08:28,000
Someone who integrated their
changes in a different order

177
00:08:28,000 --> 00:08:29,767
might have different numbers.

178
00:08:29,767 --> 00:08:32,534
So when we were actually talking
to other people,

179
00:08:32,534 --> 00:08:35,968
we identified changes
by a unique identifier

180
00:08:35,968 --> 00:08:40,133
that happens to be
the hash of some states

181
00:08:40,133 --> 00:08:41,968
of the repository.

182
00:08:41,968 --> 00:08:44,434
So we've got this graph here.

183
00:08:44,434 --> 00:08:48,634
Each node in the graph
is a changeset, a single patch.

184
00:08:48,634 --> 00:08:51,868
And the edges in the graph
are ancestry relationships.

185
00:08:51,868 --> 00:08:56,067
We identify a changeset
by the hash of its contents.

186
00:08:56,067 --> 00:08:57,834
And the contents are enough

187
00:08:57,834 --> 00:09:00,767
to uniquely identify
the changeset.

188
00:09:00,767 --> 00:09:03,567
It is, you know, the log
message, the user, the date,

189
00:09:03,567 --> 00:09:07,501
a pointer to the manifest,
which has the list of files,

190
00:09:07,501 --> 00:09:12,234
and the parents
of the change

191
00:09:12,234 --> 00:09:14,968
if it is not the first one
in your repository.

192
00:09:14,968 --> 00:09:17,434
So that's kind of the key point,
because that means

193
00:09:17,434 --> 00:09:19,067
two changes that happen
to touch

194
00:09:19,067 --> 00:09:21,000
the same file
and have the same message,

195
00:09:21,000 --> 00:09:24,267
they're still identified by--

196
00:09:24,267 --> 00:09:27,300
they're still unique
because their parents,

197
00:09:27,300 --> 00:09:29,334
which are different,
are included as part

198
00:09:29,334 --> 00:09:30,434
of the hash.

199
00:09:30,434 --> 00:09:33,000
And so that means,
because of all this,

200
00:09:33,000 --> 00:09:36,267
a single changeset
is entirely immutable.

201
00:09:36,267 --> 00:09:39,901
And this is a difference
from other systems like Git.

202
00:09:39,901 --> 00:09:44,667
You can't change the contents
of a changeset without--

203
00:09:44,667 --> 00:09:47,300
If you--say you
were to compress a bunch

204
00:09:47,300 --> 00:09:49,434
so it still represented
the same final state

205
00:09:49,434 --> 00:09:51,000
but had
different ancestry.

206
00:09:51,000 --> 00:09:53,334
Then it has a different I.D.,

207
00:09:53,334 --> 00:09:54,934
which means
it's a different changeset,

208
00:09:54,934 --> 00:09:57,033
because you identify them
by I.D.

209
00:09:57,033 --> 00:10:01,267
So this means that Mercurial
really is not much a fan

210
00:10:01,267 --> 00:10:02,601
of rewriting history.

211
00:10:02,601 --> 00:10:05,067
There are extensions to do it,
but it happens really

212
00:10:05,067 --> 00:10:10,400
before a repository
has been published, typically.

213
00:10:10,400 --> 00:10:13,801
All right,
so we actually have--

214
00:10:13,801 --> 00:10:17,667
The user visible graph
is the graph of changesets,

215
00:10:17,667 --> 00:10:20,400
but conceptually
there are many others.

216
00:10:20,400 --> 00:10:24,667
I mentioned earlier
that the manifest is the list

217
00:10:24,667 --> 00:10:27,234
of files in the changesets.

218
00:10:27,234 --> 00:10:31,434
That is also versioned in the
same way that changesets are.

219
00:10:31,434 --> 00:10:35,567
Every time you make a commit,
if the list of files changes,

220
00:10:35,567 --> 00:10:38,868
that is a new node
in the manifest graph,

221
00:10:38,868 --> 00:10:41,734
with its parent being
the previous list of files.

222
00:10:41,734 --> 00:10:46,667
And then each individual file
conceptually has its own graph,

223
00:10:46,667 --> 00:10:50,567
which, each time
you change the file--

224
00:10:50,567 --> 00:10:52,567
change the contents
of the file,

225
00:10:52,567 --> 00:10:56,567
it gets a new node identified
as the hash of its contents.

226
00:10:56,567 --> 00:10:59,734
And then so you're building up
these graphs here.

227
00:10:59,734 --> 00:11:02,501
The changesets point down
to the manifests,

228
00:11:02,501 --> 00:11:06,267
and manifests point down
to the version of the file

229
00:11:06,267 --> 00:11:08,701
at that particular point.

230
00:11:08,701 --> 00:11:12,100
And then to be able to do
certain operations efficiently,

231
00:11:12,100 --> 00:11:14,901
you also have a link
back up.

232
00:11:14,901 --> 00:11:18,367
Files and manifests have links
back up to the changesets.

233
00:11:18,367 --> 00:11:21,133
So that's actually--

234
00:11:21,133 --> 00:11:24,734
It's a very simple model
of history.

235
00:11:24,734 --> 00:11:27,400
A handful of other concepts
that are good to know:

236
00:11:27,400 --> 00:11:29,834
The heads of the repository
are simply

237
00:11:29,834 --> 00:11:36,534
the most recent changesets
that do not have any children.

238
00:11:36,534 --> 00:11:38,634
Typically, at least
in the public repository,

239
00:11:38,634 --> 00:11:40,400
there's exactly one head.

240
00:11:40,400 --> 00:11:41,868
It's a good state
to be in.

241
00:11:41,868 --> 00:11:43,834
You might
have multiple branches,

242
00:11:43,834 --> 00:11:49,567
which are just named heads,
and, well, named heads

243
00:11:49,567 --> 00:11:51,467
coupled with their parents...

244
00:11:51,467 --> 00:11:53,801
And then you have tags,
which is just a name

245
00:11:53,801 --> 00:11:58,667
attached to a particular
revision, say, for a release.

246
00:11:58,667 --> 00:12:00,767
All right.

247
00:12:00,767 --> 00:12:05,934
So how is this
actually stored on disk?

248
00:12:05,934 --> 00:12:09,968
Mercurial uses a structure
called a revlog that,

249
00:12:09,968 --> 00:12:14,767
if you've noticed, these graphs
are fundamentally the same

250
00:12:14,767 --> 00:12:17,300
whether they're operating
on files, manifests,

251
00:12:17,300 --> 00:12:19,300
or changesets.

252
00:12:19,300 --> 00:12:23,133
So they're stored in a format
called a revlog

253
00:12:23,133 --> 00:12:25,167
that is designed to meet
the requirements

254
00:12:25,167 --> 00:12:26,801
of what Mercurial has to do,

255
00:12:26,801 --> 00:12:30,434
which is you have to be able
to append to it,

256
00:12:30,434 --> 00:12:33,601
because you need to add
new changesets to your history.

257
00:12:33,601 --> 00:12:34,767
You need to be able

258
00:12:34,767 --> 00:12:38,434
to access it at random
to be able to, say,

259
00:12:38,434 --> 00:12:40,434
walk the history
of a particular file,

260
00:12:40,434 --> 00:12:43,334
or to look up a
file-particular revision.

261
00:12:43,334 --> 00:12:46,434
And it has to be fast,
and it has to be compact.

262
00:12:46,434 --> 00:12:50,133
So there are two components
to this file.

263
00:12:50,133 --> 00:12:53,901
You have--Well, first of all,
there is one revlog

264
00:12:53,901 --> 00:12:55,334
for each conceptual graph.

265
00:12:55,334 --> 00:12:58,634
There's one for changelogs,
one for manifests,

266
00:12:58,634 --> 00:13:02,634
and one per file tracked
in the repository.

267
00:13:02,634 --> 00:13:04,267
It's divided
into two components.

268
00:13:04,267 --> 00:13:07,033
You have an index
and a data file.

269
00:13:07,033 --> 00:13:09,901
And to add a new node
to one of these graphs,

270
00:13:09,901 --> 00:13:12,334
you simply add a new BLOB
of data

271
00:13:12,334 --> 00:13:14,734
to the end of the data file

272
00:13:14,734 --> 00:13:17,667
and add a new record
to the index.

273
00:13:17,667 --> 00:13:20,834
The index is just a list
affixed with records

274
00:13:20,834 --> 00:13:27,234
that tells you, for a particular
changeset number or file number,

275
00:13:27,234 --> 00:13:29,968
what is its identifier,
what are its parents,

276
00:13:29,968 --> 00:13:33,868
and importantly where is
it located in the data file.

277
00:13:33,868 --> 00:13:36,567
So the index tends
to be very compact,

278
00:13:36,567 --> 00:13:39,667
such that you can--
when you hit it a bunch,

279
00:13:39,667 --> 00:13:41,634
it tends to stick around
in memory,

280
00:13:41,634 --> 00:13:43,567
and it's only 64 bytes
per node.

281
00:13:43,567 --> 00:13:47,400
It doesn't take up
very much space in memory.

282
00:13:47,400 --> 00:13:51,701
And so the data file--
I sort of said

283
00:13:51,701 --> 00:13:54,634
that you just keep appending
to the end of it,

284
00:13:54,634 --> 00:13:57,167
which is true,
but if you're doing that

285
00:13:57,167 --> 00:14:01,968
for, say, a megabyte--a file
that's a megabyte in size,

286
00:14:01,968 --> 00:14:05,334
each time you changed it,
that would grow quickly.

287
00:14:05,334 --> 00:14:08,534
So you actually just store
deltas in this file.

288
00:14:08,534 --> 00:14:10,367
You keep appending
to a list of deltas,

289
00:14:10,367 --> 00:14:13,133
which would have
its own problem,

290
00:14:13,133 --> 00:14:15,701
and that's--to reconstruct
the actual file,

291
00:14:15,701 --> 00:14:19,167
you would have to walk
several revisions,

292
00:14:19,167 --> 00:14:23,000
and so the way Mercurial
strikes a compromise here

293
00:14:23,000 --> 00:14:27,167
is that simply once the size
of the accumulated deltas

294
00:14:27,167 --> 00:14:29,167
exceeds the actual size
of the file,

295
00:14:29,167 --> 00:14:31,334
it records a new snapshot.

296
00:14:31,334 --> 00:14:35,234
So typically, it doesn't have
to read very many entries

297
00:14:35,234 --> 00:14:39,434
in this revlog to reconstruct
a particular version

298
00:14:39,434 --> 00:14:41,167
of a particular node.

299
00:14:41,167 --> 00:14:46,234
All right.
And so...

300
00:14:46,234 --> 00:14:49,434
I just talked about all of that.
Great.

301
00:14:49,434 --> 00:14:51,734
Writing to the repository
is as I described,

302
00:14:51,734 --> 00:14:54,968
and the only thing is you do
need to lock the repository

303
00:14:54,968 --> 00:14:57,667
when you're doing this,
so that you don't present

304
00:14:57,667 --> 00:15:02,467
an inconsistent state
to any other instance

305
00:15:02,467 --> 00:15:06,000
of the hg command
that happens to be running.

306
00:15:06,000 --> 00:15:07,634
All right, so when you--

307
00:15:07,634 --> 00:15:09,634
to, say, make a new commit
to the repository,

308
00:15:09,634 --> 00:15:13,667
we lock it and we compute
the list of modified files,

309
00:15:13,667 --> 00:15:15,400
which--it has to be locked
during that--

310
00:15:15,400 --> 00:15:17,133
and we show the--
you know,

311
00:15:17,133 --> 00:15:19,667
we invite the user
to type in a log message,

312
00:15:19,667 --> 00:15:22,701
and then we write
a new list of files,

313
00:15:22,701 --> 00:15:25,534
and then the new manifest
and then the new changeset.

314
00:15:25,534 --> 00:15:28,267
We go in that order
to make rollbacks easier

315
00:15:28,267 --> 00:15:30,400
in case the user cancels
at some point.

316
00:15:30,400 --> 00:15:33,734
And so when I say
it's locked,

317
00:15:33,734 --> 00:15:36,634
I mean--
and then I say

318
00:15:36,634 --> 00:15:40,033
we ask the user to type in a
description of their changeset.

319
00:15:40,033 --> 00:15:42,033
It's very locked.

320
00:15:42,033 --> 00:15:44,734
Because that's
an arbitrarily long operation.

321
00:15:44,734 --> 00:15:46,400
So this is only a write-lock.

322
00:15:46,400 --> 00:15:47,868
So you can still read
the repository

323
00:15:47,868 --> 00:15:49,067
while this is going on,

324
00:15:49,067 --> 00:15:52,868
but it's very much,
you know, one operation

325
00:15:52,868 --> 00:15:55,133
at a time--
one write operation

326
00:15:55,133 --> 00:15:56,501
at a time
on this repository.

327
00:15:56,501 --> 00:15:58,200
So those are all things

328
00:15:58,200 --> 00:16:00,334
that are just happening on disk,
which is great.

329
00:16:00,334 --> 00:16:03,434
It's really fast, and you can
do it on an airplane.

330
00:16:03,434 --> 00:16:05,667
To actually exchange
with other people,

331
00:16:05,667 --> 00:16:08,868
the network options we have
to do are pushes and pulls.

332
00:16:08,868 --> 00:16:12,067
That's how we exchange fragments
of our repository

333
00:16:12,067 --> 00:16:15,267
or, more typically, the whole
thing with other people.

334
00:16:15,267 --> 00:16:21,534
So to do a push is very easy,
assuming that you are up to date

335
00:16:21,534 --> 00:16:25,167
with the remote server
that you're trying to push to.

336
00:16:25,167 --> 00:16:27,167
I'll gloss over the case
where you're not up to date.

337
00:16:27,167 --> 00:16:29,267
It's like doing a pull,
then a push, sort of.

338
00:16:29,267 --> 00:16:32,901
So to do a push,
you ask the remote repository,

339
00:16:32,901 --> 00:16:34,400
"What are your heads?

340
00:16:34,400 --> 00:16:37,534
What are the most recent
revisions in your repository?"

341
00:16:37,534 --> 00:16:42,200
And then you find those
in your repository,

342
00:16:42,200 --> 00:16:45,033
because you have more stuff
than they do, typically.

343
00:16:45,033 --> 00:16:47,901
And then you say, "Okay,
everything from that point

344
00:16:47,901 --> 00:16:51,267
forward is typically
what I'm going to send you."

345
00:16:51,267 --> 00:16:54,200
And then you bundle that up
into a changeset

346
00:16:54,200 --> 00:16:57,234
and then upload it.

347
00:16:57,234 --> 00:16:59,167
It's a very straightforward
and fast operation.

348
00:16:59,167 --> 00:17:01,634
Pull is slightly
more complicated,

349
00:17:01,634 --> 00:17:05,200
because there's this negotiation
process where you have

350
00:17:05,200 --> 00:17:11,234
to figure out what the remote
has that you don't have,

351
00:17:11,234 --> 00:17:13,934
so that you transfer
the minimum amount--

352
00:17:13,934 --> 00:17:18,000
so the minimum amount necessary
is transferred to you.

353
00:17:18,000 --> 00:17:22,467
So in this case,
I have the nodes in blue

354
00:17:22,467 --> 00:17:25,934
and the remote has all
of these new ones in yellow.

355
00:17:25,934 --> 00:17:28,400
So I ask, "What are your heads,
3, 9, and 13?

356
00:17:28,400 --> 00:17:30,634
"Oh, I don't have 9 and 13.

357
00:17:30,634 --> 00:17:34,367
Tell me about, you know,
what is some ancestry of 9?"

358
00:17:34,367 --> 00:17:37,501
And it says,
"Well, 9 follows a bunch of--

359
00:17:37,501 --> 00:17:40,167
it goes back until 6,
and 6 has parents 2 and 5."

360
00:17:40,167 --> 00:17:42,601
I say, "Oh, good, I have 5.
We're getting somewhere."

361
00:17:42,601 --> 00:17:47,801
And you keep going
with this sort of 20 questions

362
00:17:47,801 --> 00:17:52,133
of figuring out
what you need to get.

363
00:17:52,133 --> 00:17:58,534
And your goal here is
to identify nodes 5 and 10.

364
00:17:58,534 --> 00:18:03,767
Those are the farthest back
nodes that you don't have.

365
00:18:03,767 --> 00:18:06,767
And then I tell the server,
"Please send me everything

366
00:18:06,767 --> 00:18:08,133
from 5 and 10 forward."

367
00:18:08,133 --> 00:18:10,334
And it bundles them up
and sends.

368
00:18:10,334 --> 00:18:12,467
So there's a lot of--
it's a little chatty

369
00:18:12,467 --> 00:18:17,868
at the beginning, but that's
only transferring information

370
00:18:17,868 --> 00:18:19,734
about changesets.

371
00:18:19,734 --> 00:18:23,868
The actual changeset,
the potentially large operation,

372
00:18:23,868 --> 00:18:30,367
is getting the actual bundle
of new data.

373
00:18:30,367 --> 00:18:34,234
But that is a single response
from the server.

374
00:18:34,234 --> 00:18:38,400
So that is something that's--
this is what I am referring to

375
00:18:38,400 --> 00:18:42,434
when I say that it is well
designed for our infrastructure,

376
00:18:42,434 --> 00:18:44,901
as I'll get to.

377
00:18:44,901 --> 00:18:50,434
All right, so how does
our implementation--

378
00:18:50,434 --> 00:18:52,734
What did we have to do
to get this running?

379
00:18:52,734 --> 00:18:56,300
Well, so there's good news
and bad news

380
00:18:56,300 --> 00:18:59,667
about the way
Mercurial is set up

381
00:18:59,667 --> 00:19:01,200
and how we're set up.

382
00:19:01,200 --> 00:19:05,133
The good news is we don't have
to do, like, commits

383
00:19:05,133 --> 00:19:08,767
and anything that the hg clients
would want to do

384
00:19:08,767 --> 00:19:10,701
to our repository,
any extensions or something,

385
00:19:10,701 --> 00:19:13,334
'cause those all happen on
the users' local repositories.

386
00:19:13,334 --> 00:19:16,267
We only care
about the network operations,

387
00:19:16,267 --> 00:19:19,200
that is push and pull,
and we care about whatever

388
00:19:19,200 --> 00:19:21,901
we have to do to support
our Web front-end,

389
00:19:21,901 --> 00:19:24,033
the source browser.

390
00:19:24,033 --> 00:19:26,434
Oh, and we have to do
very simple commits

391
00:19:26,434 --> 00:19:30,601
for the wiki, which--
project wiki is stored

392
00:19:30,601 --> 00:19:34,267
in a Mercurial repository
as well.

393
00:19:34,267 --> 00:19:36,133
But other than that,
it's mostly push and pull

394
00:19:36,133 --> 00:19:37,767
and some querying.

395
00:19:37,767 --> 00:19:41,067
So it's all...

396
00:19:41,067 --> 00:19:43,534
It's mostly
just this DAG walking

397
00:19:43,534 --> 00:19:45,100
that I'll get to.

398
00:19:45,100 --> 00:19:47,667
But Mercurial makes a lot
of assumptions

399
00:19:47,667 --> 00:19:51,067
that don't work for us.

400
00:19:51,067 --> 00:19:55,400
For instance, it can--
a single process is running

401
00:19:55,400 --> 00:19:57,000
on a single machine.

402
00:19:57,000 --> 00:19:59,067
It can access the file system
directly.

403
00:19:59,067 --> 00:20:01,267
The file system--
a single hard drive

404
00:20:01,267 --> 00:20:04,634
holding the Mercurial
repository--it can lock it.

405
00:20:04,634 --> 00:20:09,934
It can load all
of the index files that it needs

406
00:20:09,934 --> 00:20:13,634
into memory and do fast
random access on them.

407
00:20:13,634 --> 00:20:16,267
Most of these assumptions
don't work for us

408
00:20:16,267 --> 00:20:21,167
at all at Google,
because we've got sort of--

409
00:20:21,167 --> 00:20:26,267
well, see, here's a particular
Google cluster, right?

410
00:20:26,267 --> 00:20:29,234
That's actually
a picture of one

411
00:20:29,234 --> 00:20:33,100
of the first Google server
environments back at Stanford,

412
00:20:33,100 --> 00:20:37,100
but we tend to have racks
that look like that.

413
00:20:37,100 --> 00:20:39,801
We have--our whole
infrastructure is built

414
00:20:39,801 --> 00:20:42,801
on the assumption
that we have lots and lots

415
00:20:42,801 --> 00:20:46,100
and lots
of relatively cheap computers.

416
00:20:46,100 --> 00:20:48,701
I mean, we would--used to say
"commodity computers."

417
00:20:48,701 --> 00:20:51,267
They're not strictly commodity.

418
00:20:51,267 --> 00:20:53,601
We're not buying them
from Dell or anything.

419
00:20:53,601 --> 00:20:58,133
But they're certainly not
the beefiest servers

420
00:20:58,133 --> 00:21:00,868
that money can buy.

421
00:21:00,868 --> 00:21:05,434
On top of that, we have our
layers like GFS and BigTable,

422
00:21:05,434 --> 00:21:08,234
which I'll talk about.

423
00:21:08,234 --> 00:21:11,901
The whole point of this
is that, when you've got

424
00:21:11,901 --> 00:21:17,000
the volume that we do,
you're going to have

425
00:21:17,000 --> 00:21:18,634
lots and lots of computers
anyway,

426
00:21:18,634 --> 00:21:21,133
and as soon as you have
lots and lots of servers,

427
00:21:21,133 --> 00:21:23,534
you're going to have failures
all the time.

428
00:21:23,534 --> 00:21:26,567
And so there's really
no point in over-engineering

429
00:21:26,567 --> 00:21:28,601
because
you'll still have failures,

430
00:21:28,601 --> 00:21:30,834
and your software will
still have to handle them,

431
00:21:30,834 --> 00:21:36,334
so we prefer just giant clusters
and write the software

432
00:21:36,334 --> 00:21:38,167
as robustly as we can
to operate on them.

433
00:21:38,167 --> 00:21:42,968
So the first layer for that
is the Google File System, GFS.

434
00:21:42,968 --> 00:21:48,968
It was built way early on
to serve the needs of Search,

435
00:21:48,968 --> 00:21:51,434
so the primary need
that it has to be robust

436
00:21:51,434 --> 00:21:54,400
in the face of random computers
or RACs

437
00:21:54,400 --> 00:21:56,267
or data centers vanishing.

438
00:21:56,267 --> 00:22:00,100
It has to hold hundreds
of terabytes,

439
00:22:00,100 --> 00:22:03,734
and these numbers probably
are all low balls, pro tip.

440
00:22:03,734 --> 00:22:08,667
And, you know,
multi-gigabyte files...

441
00:22:08,667 --> 00:22:10,234
The unique workload
of searches,

442
00:22:10,234 --> 00:22:13,734
you need to be able to stream
these files really fast.

443
00:22:13,734 --> 00:22:15,334
Like, say you're running
a MapReduce,

444
00:22:15,334 --> 00:22:16,701
a computation across them.

445
00:22:16,701 --> 00:22:18,567
So you just need to be able
to stream it really fast,

446
00:22:18,567 --> 00:22:21,334
and you need to append
to it very fast,

447
00:22:21,334 --> 00:22:23,634
and you need to be able
to append to it concurrently.

448
00:22:23,634 --> 00:22:25,968
Say you have lots of workers
all appending to the same thing.

449
00:22:25,968 --> 00:22:27,801
They need to be able to do that
without stepping

450
00:22:27,801 --> 00:22:29,367
on each other's toes.

451
00:22:29,367 --> 00:22:31,334
And maybe you need
to do random access,

452
00:22:31,334 --> 00:22:33,067
but it's not
your primary workload,

453
00:22:33,067 --> 00:22:34,367
and it needs to be possible

454
00:22:34,367 --> 00:22:35,901
but it doesn't need
to be fast.

455
00:22:35,901 --> 00:22:38,968
So there's a system
called Google File System.

456
00:22:38,968 --> 00:22:41,667
There is--it's published.
There's a paper about it.

457
00:22:41,667 --> 00:22:43,167
It's not open source.

458
00:22:43,167 --> 00:22:45,968
But it's
a single master system,

459
00:22:45,968 --> 00:22:49,400
just to keep
the implementation sane.

460
00:22:49,400 --> 00:22:53,300
And then it farms out--
it divides a single file

461
00:22:53,300 --> 00:22:55,934
into multiple chunks
that are 64 megs each,

462
00:22:55,934 --> 00:23:00,000
farms those out
to a bunch of servers,

463
00:23:00,000 --> 00:23:03,534
multiple copies--
it might be three or four copies

464
00:23:03,534 --> 00:23:07,734
of it on separate machines--

465
00:23:07,734 --> 00:23:10,534
and then you always
query the master,

466
00:23:10,534 --> 00:23:12,501
"Hey, where can I find
this file?"

467
00:23:12,501 --> 00:23:16,467
And it tells you, "Oh, there are
chunks here, here, and here,"

468
00:23:16,467 --> 00:23:18,901
and then you hit
the actual file servers.

469
00:23:18,901 --> 00:23:21,634
And those might--if they die,
then you go back

470
00:23:21,634 --> 00:23:23,234
to the master
and ask it again,

471
00:23:23,234 --> 00:23:25,267
and eventually it will figure--
it keeps it in sync.

472
00:23:25,267 --> 00:23:27,701
But so would we just--

473
00:23:27,701 --> 00:23:30,167
well, that actually sounds
sort of attractive.

474
00:23:30,167 --> 00:23:34,234
We need fast appends and--

475
00:23:34,234 --> 00:23:36,868
but so do--will we just
build straight on GFS?

476
00:23:36,868 --> 00:23:41,334
No, and actually most teams
at Google don't do that

477
00:23:41,334 --> 00:23:45,100
because, first of all,
GFS doesn't handle replication

478
00:23:45,100 --> 00:23:47,634
between data centers,
and we like keeping our data

479
00:23:47,634 --> 00:23:49,033
in more than one data center,

480
00:23:49,033 --> 00:23:52,300
so if one vanishes
from the face of the Earth,

481
00:23:52,300 --> 00:23:54,200
we don't have to go
and tell people,

482
00:23:54,200 --> 00:23:56,200
"Hey, guys, you know
all those repositories

483
00:23:56,200 --> 00:23:57,734
we were holding on to for you?"

484
00:23:57,734 --> 00:23:59,067
So that would be embarrassing.

485
00:23:59,067 --> 00:24:01,701
So we don't want to have
to write that ourselves.

486
00:24:01,701 --> 00:24:03,000
We need to be on top of GFS.

487
00:24:03,000 --> 00:24:06,801
And also the performance
characteristics are, you know,

488
00:24:06,801 --> 00:24:08,968
sort of quirky
and this whole, for instance,

489
00:24:08,968 --> 00:24:11,167
if you need to fetch
a byte from a file,

490
00:24:11,167 --> 00:24:13,734
you have to swap it in
in 64 megabyte chunks,

491
00:24:13,734 --> 00:24:17,000
and that's sort of suboptimal.

492
00:24:17,000 --> 00:24:18,801
It would not jive very well

493
00:24:18,801 --> 00:24:23,634
to simply have the revlogs
correspond to GFS files.

494
00:24:23,634 --> 00:24:25,067
It would have saved us
a lot of coding,

495
00:24:25,067 --> 00:24:26,400
but it wouldn't have worked.

496
00:24:26,400 --> 00:24:29,434
So on top of that,
there's BigTable,

497
00:24:29,434 --> 00:24:32,701
which is the primary database
technology used at Google.

498
00:24:32,701 --> 00:24:36,267
It's used by lots of teams.

499
00:24:36,267 --> 00:24:39,100
It is not a relational database.

500
00:24:39,100 --> 00:24:43,100
It is sort of
a row/column database.

501
00:24:43,100 --> 00:24:49,267
It is built to meet the diverse
needs of many Google teams.

502
00:24:49,267 --> 00:24:53,467
So it has--
but the primary example,

503
00:24:53,467 --> 00:24:55,400
you know,
is in the papers about it--

504
00:24:55,400 --> 00:24:57,501
tend to deal with Search,
imagine that.

505
00:24:57,501 --> 00:25:01,100
So your rows
are just arbitrary strings

506
00:25:01,100 --> 00:25:03,434
that are lexicographically
ordered.

507
00:25:03,434 --> 00:25:08,534
Those are single-table,
which is ginormous.

508
00:25:08,534 --> 00:25:10,133
It can be ginormous.

509
00:25:10,133 --> 00:25:13,701
So it's chunked out
to different servers

510
00:25:13,701 --> 00:25:19,767
by the row space, so different
sections vertically.

511
00:25:19,767 --> 00:25:22,367
And then--
or horizontally, yeah.

512
00:25:22,367 --> 00:25:25,434
The columns
are also arbitrary strings.

513
00:25:25,434 --> 00:25:27,667
So it's sort of a,
you know, you end up

514
00:25:27,667 --> 00:25:30,367
with this sparse matrix
where you don't have to have

515
00:25:30,367 --> 00:25:31,567
alleys for every column.

516
00:25:31,567 --> 00:25:34,701
And they're grouped
into families

517
00:25:34,701 --> 00:25:36,667
also for locality
of access.

518
00:25:36,667 --> 00:25:39,868
And then the values
you actually store, well,

519
00:25:39,868 --> 00:25:41,601
it might be a single value
per cell.

520
00:25:41,601 --> 00:25:44,734
It might be a list
of values by timestamp,

521
00:25:44,734 --> 00:25:47,567
which is a feature
that we are not too reliant on,

522
00:25:47,567 --> 00:25:49,067
so I'll gloss over it.

523
00:25:49,067 --> 00:25:53,367
And the actual values
you store are opaque BLOBs.

524
00:25:53,367 --> 00:25:57,167
There's no sort of, you know,
referential integrity

525
00:25:57,167 --> 00:25:59,467
or SQL-like thing going on here.

526
00:25:59,467 --> 00:26:01,200
You're just storing BLOBs
in this,

527
00:26:01,200 --> 00:26:03,734
and now that it's open source,
we can talk about it.

528
00:26:03,734 --> 00:26:06,000
So these BLOBs
often are protocol buffers.

529
00:26:06,000 --> 00:26:07,501
All right.

530
00:26:07,501 --> 00:26:11,534
The operations that you do,
you look up by a particular row

531
00:26:11,534 --> 00:26:12,968
and column name.

532
00:26:12,968 --> 00:26:17,000
You might scan a set of rows,
and you might, of course,

533
00:26:17,000 --> 00:26:19,200
write to it,
and you have the ability

534
00:26:19,200 --> 00:26:21,133
to lock a particular row

535
00:26:21,133 --> 00:26:24,334
to write values into it,
which is important.

536
00:26:24,334 --> 00:26:25,467
We care about that.

537
00:26:25,467 --> 00:26:27,467
And this also--
it's not open source,

538
00:26:27,467 --> 00:26:29,067
but there's a paper
about it,

539
00:26:29,067 --> 00:26:31,300
and the Hadoop project
from Apache

540
00:26:31,300 --> 00:26:34,267
I believe has an open source
implementation

541
00:26:34,267 --> 00:26:36,701
of a BigTable-like system.

542
00:26:36,701 --> 00:26:42,033
So BigTable is what
we would like to build on.

543
00:26:42,033 --> 00:26:44,601
It's widely used
inside Google.

544
00:26:44,601 --> 00:26:47,968
So it turns out
that we've got

545
00:26:47,968 --> 00:26:49,834
all these things
indexed by hash.

546
00:26:49,834 --> 00:26:53,868
That is a very good match
for BigTable,

547
00:26:53,868 --> 00:26:57,767
which we can treat essentially
as a giant hash table

548
00:26:57,767 --> 00:27:00,667
with some other features.

549
00:27:00,667 --> 00:27:05,868
So those changesets that we
identify or--sorry, these nodes

550
00:27:05,868 --> 00:27:09,200
in the graph, which might be
changesets, might be file--

551
00:27:09,200 --> 00:27:13,968
particular versions of files,
we store those in our row space,

552
00:27:13,968 --> 00:27:19,167
identified by this hash,
by the repository name,

553
00:27:19,167 --> 00:27:22,033
and by what kind of node it is.

554
00:27:22,033 --> 00:27:27,400
The "C" there is for changesets.
The "M" is for manifest.

555
00:27:27,400 --> 00:27:28,734
"F" is for files.

556
00:27:28,734 --> 00:27:30,901
And if it's a file,
it's also identified

557
00:27:30,901 --> 00:27:32,801
by what's its path.

558
00:27:32,801 --> 00:27:37,133
Because as I mentioned, these
are sorted lexicographically,

559
00:27:37,133 --> 00:27:38,434
so this has the advantage--

560
00:27:38,434 --> 00:27:42,167
And they're split
into tablets

561
00:27:42,167 --> 00:27:48,734
where rows that are close
together are likely to end up

562
00:27:48,734 --> 00:27:51,434
on the same machine
and can be accessed

563
00:27:51,434 --> 00:27:53,734
very efficiently together.

564
00:27:53,734 --> 00:27:56,467
So all the changesets
for a single repository

565
00:27:56,467 --> 00:27:58,968
end up next to each other
lexicographically.

566
00:27:58,968 --> 00:28:01,634
Same with the manifests,
same with the different versions

567
00:28:01,634 --> 00:28:03,033
of each file.

568
00:28:03,033 --> 00:28:05,334
And then--
so the values that we store

569
00:28:05,334 --> 00:28:09,300
split up
into these column families here.

570
00:28:09,300 --> 00:28:12,100
So for files we store
the contents of the file,

571
00:28:12,100 --> 00:28:13,100
obviously enough.

572
00:28:13,100 --> 00:28:16,300
We actually fragment them

573
00:28:16,300 --> 00:28:19,868
because there are row size
limitations in BigTable.

574
00:28:19,868 --> 00:28:24,534
But we can still retrieve those
linearly by row.

575
00:28:24,534 --> 00:28:28,534
And then for manifests
we just store the list of files,

576
00:28:28,534 --> 00:28:32,133
and for changesets, we store
the changed contents,

577
00:28:32,133 --> 00:28:33,767
the log message, and so forth.

578
00:28:33,767 --> 00:28:36,067
Just basic data
and metadata.

579
00:28:36,067 --> 00:28:40,434
And so that's
all just the raw contents

580
00:28:40,434 --> 00:28:42,968
of the graph that we throw
into Table.

581
00:28:42,968 --> 00:28:46,634
And so I actually identify
a single repository.

582
00:28:46,634 --> 00:28:50,667
We have its own row indexed
by our repository name.

583
00:28:50,667 --> 00:28:55,467
And it has simply
the list of heads

584
00:28:55,467 --> 00:28:59,634
that refers back to the
changesets stored in the table.

585
00:28:59,634 --> 00:29:02,067
So that which is enough
to uniquely identify

586
00:29:02,067 --> 00:29:03,868
the current state
of the repository.

587
00:29:03,868 --> 00:29:08,634
So for the operations
that we actually want to do,

588
00:29:08,634 --> 00:29:11,634
and why they are efficient--

589
00:29:11,634 --> 00:29:13,701
this is--first of all,
to clarify,

590
00:29:13,701 --> 00:29:15,501
this is--when I say
push and pull here,

591
00:29:15,501 --> 00:29:18,334
this is all
from the client's perspective.

592
00:29:18,334 --> 00:29:22,868
So if I'm pushing something
into Google's servers,

593
00:29:22,868 --> 00:29:26,767
well, all we have to do
when we receive

594
00:29:26,767 --> 00:29:31,300
this incoming graph data
is just shovel it

595
00:29:31,300 --> 00:29:33,634
into this row space
we talked about earlier,

596
00:29:33,634 --> 00:29:36,367
and it's all sort of--
it's garbage.

597
00:29:36,367 --> 00:29:40,367
It's unlinked.
It's not referenced anywhere.

598
00:29:40,367 --> 00:29:42,100
So we are free to do that

599
00:29:42,100 --> 00:29:44,467
without acquiring
any sort of lock,

600
00:29:44,467 --> 00:29:46,434
because it's not messing up
the current state

601
00:29:46,434 --> 00:29:48,834
of the repository,
because we haven't changed

602
00:29:48,834 --> 00:29:49,901
the list of heads.

603
00:29:49,901 --> 00:29:52,634
So once we are done
with all that,

604
00:29:52,634 --> 00:29:56,934
we've noted what we think
the current heads are

605
00:29:56,934 --> 00:29:58,133
in the repository.

606
00:29:58,133 --> 00:29:59,400
And if that's still the same,

607
00:29:59,400 --> 00:30:01,834
that means nothing else
has happened to this,

608
00:30:01,834 --> 00:30:06,968
so we can go ahead
and lock the repository row,

609
00:30:06,968 --> 00:30:09,667
check to make sure
it hasn't changed,

610
00:30:09,667 --> 00:30:13,300
and then write the new list
of heads that we computed.

611
00:30:13,300 --> 00:30:16,167
And then--well,
then we're done.

612
00:30:16,167 --> 00:30:18,968
The repository instantly
refers to this new data.

613
00:30:18,968 --> 00:30:20,434
We just add it
to the table.

614
00:30:20,434 --> 00:30:22,334
And that's all something
that, you know, can be done--

615
00:30:22,334 --> 00:30:25,701
if you have multiple pushes
going at the same time,

616
00:30:25,701 --> 00:30:30,400
they pretty much all succeed
and they all happen in parallel.

617
00:30:30,400 --> 00:30:33,434
One of them will win for
this actual very small write

618
00:30:33,434 --> 00:30:35,133
at the end
for the repository row.

619
00:30:35,133 --> 00:30:37,601
And the other one will have
to do a little more computation

620
00:30:37,601 --> 00:30:39,200
before it can update
that row again.

621
00:30:39,200 --> 00:30:41,701
But it still gets to succeed.

622
00:30:41,701 --> 00:30:44,000
Now if the client
is pulling from us,

623
00:30:44,000 --> 00:30:46,234
we have to answer
that game of 20 questions

624
00:30:46,234 --> 00:30:48,434
that I described
earlier of the repository--

625
00:30:48,434 --> 00:30:52,367
of the client asking us,
"Well, what do you have?"

626
00:30:52,367 --> 00:30:56,734
And so that is mostly

627
00:30:56,734 --> 00:31:01,634
just tracing back the history
of the repository in this table.

628
00:31:01,634 --> 00:31:03,534
We look up a changeset.

629
00:31:03,534 --> 00:31:06,133
We look up its parents,
keep going until we find

630
00:31:06,133 --> 00:31:07,868
the information
the client wants.

631
00:31:07,868 --> 00:31:12,667
And once the client has
identified, "Okay, I want you

632
00:31:12,667 --> 00:31:17,033
to send me everything
from these two changes forward,"

633
00:31:17,033 --> 00:31:21,667
then we can get
the actual changeset contents

634
00:31:21,667 --> 00:31:24,334
from the table
and then stream those out

635
00:31:24,334 --> 00:31:25,901
to the client.

636
00:31:25,901 --> 00:31:27,901
That is--
so at the beginning,

637
00:31:27,901 --> 00:31:30,367
there's some graph-blocking,
but to actually read

638
00:31:30,367 --> 00:31:32,567
the changesets
and build up this bundle,

639
00:31:32,567 --> 00:31:36,067
that is something that we can
rely on BigTable's parallelism

640
00:31:36,067 --> 00:31:39,434
to just--we basically can send
them out to the client

641
00:31:39,434 --> 00:31:40,801
as fast as we can read them.

642
00:31:40,801 --> 00:31:43,267
And then the last major
operation we have to do

643
00:31:43,267 --> 00:31:45,067
is for the source browser,

644
00:31:45,067 --> 00:31:47,434
the graphical front end
that we've written,

645
00:31:47,434 --> 00:31:50,334
and that is things like
getting the next and previous

646
00:31:50,334 --> 00:31:51,901
revisions of a file,

647
00:31:51,901 --> 00:31:53,067
and getting the history--

648
00:31:53,067 --> 00:31:55,534
or at a particular path,

649
00:31:55,534 --> 00:31:57,200
getting the next
and previous revisions,

650
00:31:57,200 --> 00:31:59,467
getting the contents of a file

651
00:31:59,467 --> 00:32:00,868
at a particular revision,

652
00:32:00,868 --> 00:32:02,067
that sort of thing.

653
00:32:02,067 --> 00:32:04,968
That is all just graph walking,
so it's--

654
00:32:04,968 --> 00:32:09,400
Well, we'll get into
the performance of that.

655
00:32:09,400 --> 00:32:10,767
There's--also we got--

656
00:32:10,767 --> 00:32:14,567
Well, there's a lot of
optimizations that we can do

657
00:32:14,567 --> 00:32:17,834
that are--or really
that BigTable does for us.

658
00:32:17,834 --> 00:32:19,701
The thing we need to avoid

659
00:32:19,701 --> 00:32:22,968
is doing a sequential
read or write,

660
00:32:22,968 --> 00:32:25,033
which is ask BigTable
for something,

661
00:32:25,033 --> 00:32:26,567
wait for an answer,

662
00:32:26,567 --> 00:32:28,100
ask it for something else.

663
00:32:28,100 --> 00:32:30,167
Because Mercurial is sitting
on a local file system.

664
00:32:30,167 --> 00:32:31,467
It can do that very quickly.

665
00:32:31,467 --> 00:32:33,701
And it's typically--
it'll all be in memory,

666
00:32:33,701 --> 00:32:35,901
and for us that is maybe,
I don't know,

667
00:32:35,901 --> 00:32:38,200
20 millisecond round-trip
each time.

668
00:32:38,200 --> 00:32:41,534
So our goal is to let BigTable
do the concurrency.

669
00:32:41,534 --> 00:32:43,367
We throw all of our,
you know--

670
00:32:43,367 --> 00:32:44,901
If we have writes,

671
00:32:44,901 --> 00:32:46,801
we the throw them into a pool

672
00:32:46,801 --> 00:32:48,934
and wait for all of them
to finish,

673
00:32:48,934 --> 00:32:51,033
and BigTable gets back
to us eventually.

674
00:32:51,033 --> 00:32:52,601
Same with reads.

675
00:32:52,601 --> 00:32:55,367
And then we do a little bit
of computation

676
00:32:55,367 --> 00:32:57,200
to minimize
this graph walking

677
00:32:57,200 --> 00:33:00,167
for things that we know
the client is going to ask us.

678
00:33:00,167 --> 00:33:03,834
It's going to ask,
"Hey, for this particular node

679
00:33:03,834 --> 00:33:05,033
"that I don't have,

680
00:33:05,033 --> 00:33:07,601
"what is the farthest back node

681
00:33:07,601 --> 00:33:09,067
before a merge?"

682
00:33:09,067 --> 00:33:10,601
'Cause that's
a single line of history

683
00:33:10,601 --> 00:33:12,501
that it's going to want
to investigate further,

684
00:33:12,501 --> 00:33:14,334
so that's the sort of thing
we can pre-compute,

685
00:33:14,334 --> 00:33:15,734
because it's all in the past,

686
00:33:15,734 --> 00:33:17,200
and it's guaranteed
never to change.

687
00:33:17,200 --> 00:33:20,200
So we can just store it
when we do the writes.

688
00:33:20,200 --> 00:33:25,467
So the actual results
we get from our implementation,

689
00:33:25,467 --> 00:33:26,968
pushing--

690
00:33:26,968 --> 00:33:28,267
When the client
is pushing to us,

691
00:33:28,267 --> 00:33:31,200
that is ridiculously fast.

692
00:33:31,200 --> 00:33:34,300
We just accept data
and writes into the table,

693
00:33:34,300 --> 00:33:36,567
and because there are many,
many machines involved here,

694
00:33:36,567 --> 00:33:38,667
this can happen way faster

695
00:33:38,667 --> 00:33:42,467
than an actual
file system writes.

696
00:33:42,467 --> 00:33:47,634
The pull, that negotiation
process at the beginning,

697
00:33:47,634 --> 00:33:50,133
is still a certain mound
of synchronous reads

698
00:33:50,133 --> 00:33:51,534
where we have to wait
for an answer,

699
00:33:51,534 --> 00:33:54,267
and that's something
that's even--

700
00:33:54,267 --> 00:33:57,701
We can't do anything about
a lot of those round-trips,

701
00:33:57,701 --> 00:33:59,534
so even at the best case,

702
00:33:59,534 --> 00:34:02,601
once we're finished optimizing
our implementation,

703
00:34:02,601 --> 00:34:05,767
we might still be, say,
twice as slow as Mercurial,

704
00:34:05,767 --> 00:34:07,534
because of the difference
in architecture.

705
00:34:07,534 --> 00:34:09,734
And then
for the source browser,

706
00:34:09,734 --> 00:34:13,067
we're very fast
for certain operations.

707
00:34:13,067 --> 00:34:15,534
Retrieving a particular
revision of the file--

708
00:34:15,534 --> 00:34:17,801
that's just a table lookup.

709
00:34:17,801 --> 00:34:20,634
Retrieving the history
of the file--

710
00:34:20,634 --> 00:34:21,767
so in Mercurial,

711
00:34:21,767 --> 00:34:24,968
that is just tracing
a single revlog

712
00:34:24,968 --> 00:34:27,200
that holds the whole contents
of a file.

713
00:34:27,200 --> 00:34:29,067
That's slow for us,

714
00:34:29,067 --> 00:34:31,868
'cause we have to do
a whole bunch of graph walking,

715
00:34:31,868 --> 00:34:33,567
and that's something
we're working on.

716
00:34:33,567 --> 00:34:36,534
You'll notice that's slow
on the web front end and we're--

717
00:34:36,534 --> 00:34:38,400
but we have some stuff

718
00:34:38,400 --> 00:34:41,701
we can do
to make it faster still.

719
00:34:41,701 --> 00:34:44,968
But overall, though--

720
00:34:44,968 --> 00:34:47,334
So those numbers
for a single repository

721
00:34:47,334 --> 00:34:50,701
also hold true for however much
we want to serve.

722
00:34:50,701 --> 00:34:54,434
A, you know, single job
running in a data center,

723
00:34:54,434 --> 00:34:56,767
we can serve hundreds
of queries per second

724
00:34:56,767 --> 00:34:59,534
on the source browser across
all sorts of repositories.

725
00:34:59,534 --> 00:35:02,467
And for the pushing
and pulling,

726
00:35:02,467 --> 00:35:04,534
we can do tens
of megabits per second

727
00:35:04,534 --> 00:35:05,701
from the single job,

728
00:35:05,701 --> 00:35:08,734
which is rather fast
for a Python program

729
00:35:08,734 --> 00:35:10,100
on a single computer.

730
00:35:10,100 --> 00:35:13,968
So we don't run into things
like lock contention

731
00:35:13,968 --> 00:35:16,234
as much as you would

732
00:35:16,234 --> 00:35:18,267
if you had
the stock Mercurial server

733
00:35:18,267 --> 00:35:19,634
trying to do
that sort of thing.

734
00:35:19,634 --> 00:35:23,934
So the lessons we can learn
from this is, you know,

735
00:35:23,934 --> 00:35:27,534
engineering, it's really
about trade-offs,

736
00:35:27,534 --> 00:35:29,868
and there are things that are--

737
00:35:29,868 --> 00:35:33,868
The design goals very much
affect the end product.

738
00:35:33,868 --> 00:35:36,334
Our design goal is that

739
00:35:36,334 --> 00:35:41,200
if the entire project-hosting
ecosystem--

740
00:35:41,200 --> 00:35:42,667
Well, if all of Google code

741
00:35:42,667 --> 00:35:45,367
decided to switch their projects
today to Mercurial,

742
00:35:45,367 --> 00:35:47,501
we could handle it maybe

743
00:35:47,501 --> 00:35:49,834
by throwing a couple more
computers at it,

744
00:35:49,834 --> 00:35:51,901
bring up a couple more jobs,

745
00:35:51,901 --> 00:35:54,267
and we can
handle the traffic fine.

746
00:35:54,267 --> 00:35:57,200
But at the same time,

747
00:35:57,200 --> 00:35:59,534
that, I mean,
involves a lot of--

748
00:35:59,534 --> 00:36:03,467
When you're sharding things
across computers like that,

749
00:36:03,467 --> 00:36:05,968
it's always--
there are certain operations

750
00:36:05,968 --> 00:36:08,601
that you're not
going to be able to do as fast

751
00:36:08,601 --> 00:36:11,234
as if you just had
a single process

752
00:36:11,234 --> 00:36:13,167
talking directly to disk.

753
00:36:13,167 --> 00:36:17,767
So the scalability there
will always have a price.

754
00:36:17,767 --> 00:36:19,033
So that's something that--

755
00:36:19,033 --> 00:36:20,634
When you're starting
to design a system,

756
00:36:20,634 --> 00:36:22,400
these are the things
you need to keep in mind.

757
00:36:22,400 --> 00:36:27,634
And one more cool thing
that we have...

758
00:36:27,634 --> 00:36:28,934
I think that's
a Lego clone army.

759
00:36:28,934 --> 00:36:29,934
I don't know.

760
00:36:29,934 --> 00:36:33,033
But so you notice that--

761
00:36:33,033 --> 00:36:36,067
We'll go back to this...

762
00:36:36,067 --> 00:36:39,567
All of that data
in that top table,

763
00:36:39,567 --> 00:36:41,834
that's all immutable.

764
00:36:41,834 --> 00:36:47,133
And one thing that's very common
in a distributed workflow

765
00:36:47,133 --> 00:36:51,033
is having, you know,
multiple copies of this--

766
00:36:51,033 --> 00:36:53,400
more or less,
the same repository.

767
00:36:53,400 --> 00:36:56,501
And that is, for Mercurial,

768
00:36:56,501 --> 00:37:00,400
that is something that if you
want to clone a local repository

769
00:37:00,400 --> 00:37:01,467
that's sitting on disk...

770
00:37:01,467 --> 00:37:03,267
Well, it doesn't do any work.

771
00:37:03,267 --> 00:37:07,934
It actually hard-links
the new repository to the old,

772
00:37:07,934 --> 00:37:10,934
and then when you
actually do a write,

773
00:37:10,934 --> 00:37:14,734
it then goes, "Whoa, this file
has two references to it.

774
00:37:14,734 --> 00:37:16,000
It's linked somewhere else."

775
00:37:16,000 --> 00:37:17,567
And then it actually
does the copy then.

776
00:37:17,567 --> 00:37:19,501
So cloning is wicked fast.

777
00:37:19,501 --> 00:37:22,100
But you have--
Oh, I should stop doing that.

778
00:37:22,100 --> 00:37:26,601
But it will slow down
your operations randomly later.

779
00:37:26,601 --> 00:37:28,734
So it sort of...it works.

780
00:37:28,734 --> 00:37:30,901
We can do a little bit
better than that,

781
00:37:30,901 --> 00:37:33,200
because all that--

782
00:37:33,200 --> 00:37:35,734
If we were to clone a repository
on the service side,

783
00:37:35,734 --> 00:37:38,868
all that actual revision data
that's stored in that table,

784
00:37:38,868 --> 00:37:41,200
that's all immutable,

785
00:37:41,200 --> 00:37:44,801
and whatever happens
for the divergent history

786
00:37:44,801 --> 00:37:46,834
of these two repositories,

787
00:37:46,834 --> 00:37:49,067
that data can remain shared.

788
00:37:49,067 --> 00:37:51,801
So the only thing that uniquely
identifies a repository

789
00:37:51,801 --> 00:37:53,501
is that list of heads,

790
00:37:53,501 --> 00:37:55,868
and the list of branches
and things like that,

791
00:37:55,868 --> 00:37:58,467
and also meant if we have
any sort of references

792
00:37:58,467 --> 00:38:00,334
pointing forward
that we've pre-computed,

793
00:38:00,334 --> 00:38:02,000
those are things we have
to watch out for,

794
00:38:02,000 --> 00:38:04,701
but the bulk of the data
is shared.

795
00:38:04,701 --> 00:38:08,133
So that's something that we can
certainly do pretty easily

796
00:38:08,133 --> 00:38:10,601
from a technical perspective.

797
00:38:10,601 --> 00:38:13,501
Getting the right UI

798
00:38:13,501 --> 00:38:16,000
and integration with our
existing project hosting

799
00:38:16,000 --> 00:38:18,434
is something that'll
take more effort,

800
00:38:18,434 --> 00:38:20,968
but it's something that you can
look forward to

801
00:38:20,968 --> 00:38:23,300
in the near future
in your projects.

802
00:38:23,300 --> 00:38:25,000
And we believe that,
you know,

803
00:38:25,000 --> 00:38:26,868
the distributed workflow,

804
00:38:26,868 --> 00:38:28,567
I mean,
it's not really just--

805
00:38:28,567 --> 00:38:30,701
You don't want to be able
to use Mercurial.

806
00:38:30,701 --> 00:38:32,300
Though you might enjoy
using Mercurial,

807
00:38:32,300 --> 00:38:34,200
you want to be able
to take advantage

808
00:38:34,200 --> 00:38:37,467
of the workflow of
distributed version control,

809
00:38:37,467 --> 00:38:39,367
and that's what we hope
to support.

810
00:38:39,367 --> 00:38:41,968
Thank you.
Any questions?

811
00:38:41,968 --> 00:38:44,968
[applause]

812
00:38:47,868 --> 00:38:48,868
man: I have one.

813
00:38:48,868 --> 00:38:49,868
Lee: Yeah.

814
00:38:49,868 --> 00:38:51,267
man: Kind of unrelated,

815
00:38:51,267 --> 00:38:53,601
but we are always
looking for ways

816
00:38:53,601 --> 00:38:55,467
to let our, like,
graphic designers

817
00:38:55,467 --> 00:38:57,534
store big Photoshop files.

818
00:38:57,534 --> 00:39:00,501
Kind of doesn't work
in Service Control,

819
00:39:00,501 --> 00:39:03,767
but I've never seen
another solution.

820
00:39:03,767 --> 00:39:06,400
You know, we want revisioning
in that process.

821
00:39:06,400 --> 00:39:08,767
But, you know.
Do you have any solutions?

822
00:39:08,767 --> 00:39:11,934
Lee: Write one
and tell us about it.

823
00:39:11,934 --> 00:39:15,467
man: No, you're Google.
You should know things.

824
00:39:15,467 --> 00:39:18,167
Lee: Well, actually, for
projects that are doing this,

825
00:39:18,167 --> 00:39:21,133
we recommend using
our downloads server,

826
00:39:21,133 --> 00:39:24,834
which you can at least give,
you know, revision numbers.

827
00:39:24,834 --> 00:39:26,701
You have to do it yourself,
it's a pain,

828
00:39:26,701 --> 00:39:27,901
but it's doable,

829
00:39:27,901 --> 00:39:29,534
and that is relying
on a different,

830
00:39:29,534 --> 00:39:31,367
totally different
massive storage system.

831
00:39:31,367 --> 00:39:32,601
man: All right.

832
00:39:32,601 --> 00:39:35,601
Well, maybe we'll start
an open source project.

833
00:39:35,601 --> 00:39:37,100
man: Hi.

834
00:39:37,100 --> 00:39:39,367
You talked about
the changesets

835
00:39:39,367 --> 00:39:42,000
sort of having
a similar hash value,

836
00:39:42,000 --> 00:39:44,200
and then that's why
they hash together--

837
00:39:44,200 --> 00:39:46,434
well, close to each other.

838
00:39:46,434 --> 00:39:47,701
Is that--

839
00:39:47,701 --> 00:39:51,334
Lee: Well, say a change
and its parents

840
00:39:51,334 --> 00:39:53,100
will have totally different
hashes, right?

841
00:39:53,100 --> 00:39:56,701
Because it tries to be
a reasonably smooth function,

842
00:39:56,701 --> 00:39:59,534
or reasonably
arbitrary function.

843
00:39:59,534 --> 00:40:02,701
But they all have
the same prefix

844
00:40:02,701 --> 00:40:03,801
of the repository name

845
00:40:03,801 --> 00:40:05,067
and then "C."

846
00:40:05,067 --> 00:40:07,901
As opposed to, say,
the files that are manifest,

847
00:40:07,901 --> 00:40:09,434
that are also stored
in the same table.

848
00:40:09,434 --> 00:40:11,868
To be clear,
that was all one BigTable.

849
00:40:11,868 --> 00:40:14,267
man: Yeah, so, I mean,

850
00:40:14,267 --> 00:40:17,767
so my question is more probably
related to BigTable.

851
00:40:17,767 --> 00:40:21,634
So this sort of the same
prefix hashing

852
00:40:21,634 --> 00:40:24,434
to similar locations,

853
00:40:24,434 --> 00:40:27,434
is that something that is
by default in BigTable,

854
00:40:27,434 --> 00:40:29,000
or did you have to do
something for that?

855
00:40:29,000 --> 00:40:31,267
Lee:
No, that's how it works.

856
00:40:31,267 --> 00:40:33,767
Rows are stored
lexicographically

857
00:40:33,767 --> 00:40:36,834
and then sharded
by their prefix.

858
00:40:36,834 --> 00:40:39,234
man: So it's a
location-preserving hash table?

859
00:40:39,234 --> 00:40:40,300
Lee: Sorry?

860
00:40:40,300 --> 00:40:41,601
man:
Like, I mean, BigTable

861
00:40:41,601 --> 00:40:44,133
is like a
location-preserving hash...

862
00:40:44,133 --> 00:40:47,734
I mean, it preserves,
like, I mean, based on--

863
00:40:47,734 --> 00:40:51,367
Lee: No, no, it'll just--
it'll start on one tab,

864
00:40:51,367 --> 00:40:52,567
and then when it gets big enough

865
00:40:52,567 --> 00:40:55,701
it'll split it up
as it deems appropriate.

866
00:40:55,701 --> 00:40:57,267
man: Thanks.

867
00:40:57,267 --> 00:40:59,300
Lee: It's not something
we really have to deal with.

868
00:40:59,300 --> 00:41:02,133
It's BigTable magic.

869
00:41:02,133 --> 00:41:03,667
man:
I was just wondering

870
00:41:03,667 --> 00:41:07,000
if you imagine Google eventually
using something like Mercurial

871
00:41:07,000 --> 00:41:09,234
for its own
internal development,

872
00:41:09,234 --> 00:41:11,067
and compared to, you know,

873
00:41:11,067 --> 00:41:12,968
big systems like Perforce
have trade-offs,

874
00:41:12,968 --> 00:41:15,234
and can you talk a little about
what those trade-offs are,

875
00:41:15,234 --> 00:41:16,634
and what systems like Perforce

876
00:41:16,634 --> 00:41:18,133
do better or worse
than Mercurial

877
00:41:18,133 --> 00:41:19,667
and sort of how
you think that through?

878
00:41:19,667 --> 00:41:22,133
Lee: Well, we're sort of
unique at Google.

879
00:41:22,133 --> 00:41:26,734
We have our--
basically one giant repository

880
00:41:26,734 --> 00:41:29,367
for, like, everything.

881
00:41:29,367 --> 00:41:31,434
So Perforce scales...

882
00:41:31,434 --> 00:41:36,367
Well, crack engineers whom I'm--
don't know who they are

883
00:41:36,367 --> 00:41:38,200
do a good job of scaling it,

884
00:41:38,200 --> 00:41:40,100
and so I don't know actually

885
00:41:40,100 --> 00:41:43,734
if there are any developments
on that front.

886
00:41:43,734 --> 00:41:45,334
man: I've been trying
to evaluate

887
00:41:45,334 --> 00:41:47,400
the different distributed
version control systems,

888
00:41:47,400 --> 00:41:49,200
and one of the big things
in my environment

889
00:41:49,200 --> 00:41:52,133
is being able to import existing
subversion repositories

890
00:41:52,133 --> 00:41:54,200
into whatever it is,

891
00:41:54,200 --> 00:41:56,100
and I ran into
quite a few problems

892
00:41:56,100 --> 00:41:57,534
using Mercurial and such.

893
00:41:57,534 --> 00:41:59,200
I've been kind of
leaning towards Bazaar,

894
00:41:59,200 --> 00:42:01,567
and I was just wondering what
was your experience with that,

895
00:42:01,567 --> 00:42:02,734
and how poorly did it go,

896
00:42:02,734 --> 00:42:04,200
and that kind of thing?

897
00:42:04,200 --> 00:42:08,467
Lee: Well, the actual import,
I found, is straightforward.

898
00:42:08,467 --> 00:42:11,167
Getting all
of the correct bindings

899
00:42:11,167 --> 00:42:14,000
is a pain in the neck
right now.

900
00:42:14,000 --> 00:42:17,901
You have to get
the subversion Python bindings,

901
00:42:17,901 --> 00:42:20,167
because Mercurial is written
all in Python.

902
00:42:20,167 --> 00:42:22,133
That's kind of
the most annoying one.

903
00:42:22,133 --> 00:42:24,834
If you have, say,
a recent Ubuntu distribution,

904
00:42:24,834 --> 00:42:26,834
you might have it
all out of the box.

905
00:42:26,834 --> 00:42:30,467
Otherwise you have
some compiling from source

906
00:42:30,467 --> 00:42:32,033
in your future,
and that's loads of fun.

907
00:42:32,033 --> 00:42:35,267
So that's something--
It would probably be, I mean,

908
00:42:35,267 --> 00:42:37,634
GitHub I know actually has

909
00:42:37,634 --> 00:42:39,801
some sort of automated imports

910
00:42:39,801 --> 00:42:42,601
for existing
subversion repositories,

911
00:42:42,601 --> 00:42:43,601
which is really cool.

912
00:42:43,601 --> 00:42:45,267
So...

913
00:42:45,267 --> 00:42:46,501
Yeah?

914
00:42:46,501 --> 00:42:48,634
man: Do you offer
transition from subversion

915
00:42:48,634 --> 00:42:50,367
to Mercurial currently?

916
00:42:50,367 --> 00:42:51,367
Lee: Yes.

917
00:42:51,367 --> 00:42:52,767
As of this afternoon,

918
00:42:52,767 --> 00:42:54,367
you can select
from the little drop-down

919
00:42:54,367 --> 00:42:55,367
which system to use,

920
00:42:55,367 --> 00:42:57,000
but unfortunately you do
have to do

921
00:42:57,000 --> 00:42:58,234
the migration yourself,

922
00:42:58,234 --> 00:42:59,501
which we know is annoying.

923
00:42:59,501 --> 00:43:01,334
man: Just interested,

924
00:43:01,334 --> 00:43:03,100
can you extend this concept

925
00:43:03,100 --> 00:43:04,934
to content repositories?

926
00:43:04,934 --> 00:43:06,567
Like, say, does Google Docs

927
00:43:06,567 --> 00:43:08,834
also use
similar version systems?

928
00:43:08,834 --> 00:43:10,367
Lee: Sorry?

929
00:43:10,367 --> 00:43:11,367
man: Like, Google Docs,

930
00:43:11,367 --> 00:43:13,534
does it use BigTable
for its content?

931
00:43:13,534 --> 00:43:15,901
Lee: Oh.
I don't know what Docs uses.

932
00:43:15,901 --> 00:43:19,501
A lot of teams at Google
use BigTable,

933
00:43:19,501 --> 00:43:22,968
but, I mean, Docs and sites
all do versioning,

934
00:43:22,968 --> 00:43:26,000
but they're certainly not,
like, using Mercurial

935
00:43:26,000 --> 00:43:27,167
or Git behind the scenes.

936
00:43:27,167 --> 00:43:30,334
man: I was wondering
about your experience

937
00:43:30,334 --> 00:43:33,434
while changing the,
let's say,

938
00:43:33,434 --> 00:43:36,868
writing or disk back-end of
Mercurial to work with BigTable.

939
00:43:36,868 --> 00:43:39,734
If you're, for instance,

940
00:43:39,734 --> 00:43:42,367
going to release these
modifications to Mercurial

941
00:43:42,367 --> 00:43:43,467
to the public,

942
00:43:43,467 --> 00:43:45,167
as a first partial question,

943
00:43:45,167 --> 00:43:47,868
and then what's your opinion
or your advice,

944
00:43:47,868 --> 00:43:49,601
'cause I'm very interested

945
00:43:49,601 --> 00:43:51,467
in being able to change
that back-end

946
00:43:51,467 --> 00:43:53,067
instead of writing
directly to disk--

947
00:43:53,067 --> 00:43:55,801
writing, for example,
to our relational database.

948
00:43:55,801 --> 00:43:57,834
Lee: Ooh. That'd be fun.

949
00:43:57,834 --> 00:43:59,567
Well, it turns out,

950
00:43:59,567 --> 00:44:02,601
so we're not that fundamental
a structure of the revlog.

951
00:44:02,601 --> 00:44:05,767
We had to totally
replace that,

952
00:44:05,767 --> 00:44:09,501
and that's sort of the bulk
of the interesting operat--

953
00:44:09,501 --> 00:44:10,801
That coupled with us

954
00:44:10,801 --> 00:44:13,033
only dealing
with the network operations

955
00:44:13,033 --> 00:44:16,901
means we use the little bits of,
say, like the parsing code,

956
00:44:16,901 --> 00:44:21,501
but most of the actual
implementation is internal.

957
00:44:21,501 --> 00:44:25,234
So it'd be something
that's sort of challenging

958
00:44:25,234 --> 00:44:27,901
to open source because of
the dependency on BigTable,

959
00:44:27,901 --> 00:44:29,534
but I hope at the very least

960
00:44:29,534 --> 00:44:32,868
you can expect maybe a white
paper or something from us.

961
00:44:32,868 --> 00:44:35,501
If not,
as upside of...yeah.

962
00:44:35,501 --> 00:44:37,033
man:
I was mainly thinking of just

963
00:44:37,033 --> 00:44:39,267
maybe a small extraction layer

964
00:44:39,267 --> 00:44:44,200
where you can hook your,
let's say, persistent strategy.

965
00:44:44,200 --> 00:44:47,634
Lee: Yeah, you can--
the Mercurial code base

966
00:44:47,634 --> 00:44:49,167
is relatively clean.

967
00:44:49,167 --> 00:44:51,567
It'd be sort of doable.

968
00:44:51,567 --> 00:44:53,667
But you have to keep in mind

969
00:44:53,667 --> 00:44:57,267
your access patterns
are going to--

970
00:44:57,267 --> 00:45:00,567
or your performance
characteristics

971
00:45:00,567 --> 00:45:02,033
are going to be
totally different.

972
00:45:02,033 --> 00:45:05,000
So if it hopes to be able
to do random access

973
00:45:05,000 --> 00:45:09,667
by integer alias
for changesets,

974
00:45:09,667 --> 00:45:10,934
and do that quickly,

975
00:45:10,934 --> 00:45:12,334
you need to be able
to support that.

976
00:45:12,334 --> 00:45:13,634
Which, actually,
in, you know,

977
00:45:13,634 --> 00:45:15,067
say, a
stock-relational database,

978
00:45:15,067 --> 00:45:16,067
probably would be doable.

979
00:45:16,067 --> 00:45:17,701
We don't use integer I.D.s,

980
00:45:17,701 --> 00:45:19,868
you know, anywhere
in our implementation.

981
00:45:19,868 --> 00:45:23,667
It's only hashes, so ours
is pretty quirky in that, so...

982
00:45:23,667 --> 00:45:25,901
man: Okay, and just
a very small question more.

983
00:45:25,901 --> 00:45:32,334
Do you support for sub-treat
cloning or exporting?

984
00:45:32,334 --> 00:45:35,334
Yeah, I mean, instead
of the full repository,

985
00:45:35,334 --> 00:45:38,467
just the subset of the path.

986
00:45:38,467 --> 00:45:41,100
Lee: No, I don't think
Mercurial does that.

987
00:45:41,100 --> 00:45:42,267
man: Mercurial does not.

988
00:45:42,267 --> 00:45:43,601
Lee: Yeah, no,
so we don't either.

989
00:45:43,601 --> 00:45:44,601
man: Okay, thank you.

990
00:45:44,601 --> 00:45:47,534
Lee: It's not in the protocol.

991
00:45:47,534 --> 00:45:48,701
man: Hi.

992
00:45:48,701 --> 00:45:51,934
A lot of CM systems
set up at the beginning

993
00:45:51,934 --> 00:45:54,534
to facilitate the rest
of the engineering process.

994
00:45:54,534 --> 00:45:57,267
Do you have any plans
to integrate or support

995
00:45:57,267 --> 00:46:00,300
continuous integration
on the back end,

996
00:46:00,300 --> 00:46:02,334
tying into bug systems

997
00:46:02,334 --> 00:46:04,868
where you can track changes

998
00:46:04,868 --> 00:46:06,200
both in the
issue tracking system

999
00:46:06,200 --> 00:46:08,400
and in the quote system
linked together?

1000
00:46:08,400 --> 00:46:10,767
Lee: Some of that
is possible right now.

1001
00:46:10,767 --> 00:46:12,100
We support web hooks,

1002
00:46:12,100 --> 00:46:14,701
so when there's a new commit
in the repository

1003
00:46:14,701 --> 00:46:16,567
or a new push for Mercurial,

1004
00:46:16,567 --> 00:46:20,400
we just hit an external URL.

1005
00:46:20,400 --> 00:46:22,767
That URL then could get
that revision

1006
00:46:22,767 --> 00:46:25,934
and run, say, a continuous
build from that.

1007
00:46:25,934 --> 00:46:27,968
It's something that--
it would be sort of challenging

1008
00:46:27,968 --> 00:46:29,133
for us to support internally,

1009
00:46:29,133 --> 00:46:30,467
just 'cause every build system

1010
00:46:30,467 --> 00:46:32,000
is so radically unique,

1011
00:46:32,000 --> 00:46:33,734
so that's the best bet
for now.

1012
00:46:33,734 --> 00:46:39,234
man: And what about integration
with bug tracking?

1013
00:46:39,234 --> 00:46:41,234
Lee:
What sort of integration?

1014
00:46:41,234 --> 00:46:43,868
man: Well, a lot of
well developed CM systems

1015
00:46:43,868 --> 00:46:45,567
have this notion
that you have a change,

1016
00:46:45,567 --> 00:46:48,067
and the change incorporates
both the code change

1017
00:46:48,067 --> 00:46:50,467
and the issues
that are associated with it.

1018
00:46:50,467 --> 00:46:52,434
Lee: Versioned issues.
No, we--

1019
00:46:52,434 --> 00:46:53,734
man:
Not versioning the issues,

1020
00:46:53,734 --> 00:46:54,901
but tying the issues together

1021
00:46:54,901 --> 00:46:56,100
with the source-code changes.

1022
00:46:56,100 --> 00:46:57,667
Lee:
We have some integration

1023
00:46:57,667 --> 00:47:00,601
where your commits
include commands

1024
00:47:00,601 --> 00:47:01,634
to the issue tracker.

1025
00:47:01,634 --> 00:47:04,000
Like, "Fixes issue number 23."

1026
00:47:04,000 --> 00:47:06,601
It will actually close
issue 23,

1027
00:47:06,601 --> 00:47:07,667
so that's sort of
the most we do.

1028
00:47:07,667 --> 00:47:09,934
man: Okay.

1029
00:47:09,934 --> 00:47:11,634
Lee: All right?

1030
00:47:11,634 --> 00:47:13,167
Thank you.
We have T-shirts.

1031
00:47:13,167 --> 00:47:14,434
[applause]

